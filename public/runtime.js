var SpeRuntime = (() => {
    var Ix = Object.create;
    var Ao = Object.defineProperty,
        Lx = Object.defineProperties,
        Dx = Object.getOwnPropertyDescriptor,
        Px = Object.getOwnPropertyDescriptors,
        Bx = Object.getOwnPropertyNames,
        sd = Object.getOwnPropertySymbols,
        Ox = Object.getPrototypeOf,
        od = Object.prototype.hasOwnProperty,
        Rx = Object.prototype.propertyIsEnumerable;
    var ad = (n, e, t) => e in n ? Ao(n, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: t
        }) : n[e] = t,
        Ne = (n, e) => {
            for (var t in e || (e = {})) od.call(e, t) && ad(n, t, e[t]);
            if (sd)
                for (var t of sd(e)) Rx.call(e, t) && ad(n, t, e[t]);
            return n
        },
        je = (n, e) => Lx(n, Px(e)),
        ld = n => Ao(n, "__esModule", {
            value: !0
        });
    var bo = n => {
        if (typeof require != "undefined") return require(n);
        throw new Error('Dynamic require of "' + n + '" is not supported')
    };
    var cd = (n, e) => () => (e || n((e = {
            exports: {}
        }).exports, e), e.exports),
        ud = (n, e) => {
            ld(n);
            for (var t in e) Ao(n, t, {
                get: e[t],
                enumerable: !0
            })
        },
        Fx = (n, e, t) => {
            if (e && typeof e == "object" || typeof e == "function")
                for (let r of Bx(e)) !od.call(n, r) && r !== "default" && Ao(n, r, {
                    get: () => e[r],
                    enumerable: !(t = Dx(e, r)) || t.enumerable
                });
            return n
        },
        W = n => Fx(ld(Ao(n != null ? Ix(Ox(n)) : {}, "default", n && n.__esModule && "default" in n ? {
            get: () => n.default,
            enumerable: !0
        } : {
            value: n,
            enumerable: !0
        })), n);
    var J = cd((vC, fd) => {
        fd.exports = THREE
    });
    var gd = cd((pd, Hc) => {
        (function(n) {
            if (typeof pd == "object" && typeof Hc != "undefined") Hc.exports = n();
            else if (typeof define == "function" && define.amd) define([], n);
            else {
                var e;
                typeof window != "undefined" ? e = window : typeof global != "undefined" ? e = global : typeof self != "undefined" ? e = self : e = this, e.pica = n()
            }
        })(function() {
            var n, e, t;
            return function() {
                function r(i, s, o) {
                    function l(f, h) {
                        if (!s[f]) {
                            if (!i[f]) {
                                var m = typeof bo == "function" && bo;
                                if (!h && m) return m(f, !0);
                                if (a) return a(f, !0);
                                var v = new Error("Cannot find module '" + f + "'");
                                throw v.code = "MODULE_NOT_FOUND", v
                            }
                            var g = s[f] = {
                                exports: {}
                            };
                            i[f][0].call(g.exports, function(y) {
                                var A = i[f][1][y];
                                return l(A || y)
                            }, g, g.exports, r, i, s, o)
                        }
                        return s[f].exports
                    }
                    for (var a = typeof bo == "function" && bo, c = 0; c < o.length; c++) l(o[c]);
                    return l
                }
                return r
            }()({
                1: [function(r, i, s) {
                    "use strict";
                    var o = r("inherits"),
                        l = r("multimath"),
                        a = r("./mm_unsharp_mask"),
                        c = r("./mm_resize");

                    function f(h) {
                        var m = h || [],
                            v = {
                                js: m.indexOf("js") >= 0,
                                wasm: m.indexOf("wasm") >= 0
                            };
                        l.call(this, v), this.features = {
                            js: v.js,
                            wasm: v.wasm && this.has_wasm()
                        }, this.use(a), this.use(c)
                    }
                    o(f, l), f.prototype.resizeAndUnsharp = function(m, v) {
                        var g = this.resize(m, v);
                        return m.unsharpAmount && this.unsharp_mask(g, m.toWidth, m.toHeight, m.unsharpAmount, m.unsharpRadius, m.unsharpThreshold), g
                    }, i.exports = f
                }, {
                    "./mm_resize": 4,
                    "./mm_unsharp_mask": 9,
                    inherits: 19,
                    multimath: 20
                }],
                2: [function(r, i, s) {
                    "use strict";

                    function o(c) {
                        return c < 0 ? 0 : c > 255 ? 255 : c
                    }

                    function l(c, f, h, m, v, g) {
                        var y, A, w, C, S, E, M, L, I, z, O, X = 0,
                            k = 0;
                        for (I = 0; I < m; I++) {
                            for (S = 0, z = 0; z < v; z++) {
                                for (E = g[S++], M = g[S++], L = X + E * 4 | 0, y = A = w = C = 0; M > 0; M--) O = g[S++], C = C + O * c[L + 3] | 0, w = w + O * c[L + 2] | 0, A = A + O * c[L + 1] | 0, y = y + O * c[L] | 0, L = L + 4 | 0;
                                f[k + 3] = o(C + (1 << 13) >> 14), f[k + 2] = o(w + (1 << 13) >> 14), f[k + 1] = o(A + (1 << 13) >> 14), f[k] = o(y + (1 << 13) >> 14), k = k + m * 4 | 0
                            }
                            k = (I + 1) * 4 | 0, X = (I + 1) * h * 4 | 0
                        }
                    }

                    function a(c, f, h, m, v, g) {
                        var y, A, w, C, S, E, M, L, I, z, O, X = 0,
                            k = 0;
                        for (I = 0; I < m; I++) {
                            for (S = 0, z = 0; z < v; z++) {
                                for (E = g[S++], M = g[S++], L = X + E * 4 | 0, y = A = w = C = 0; M > 0; M--) O = g[S++], C = C + O * c[L + 3] | 0, w = w + O * c[L + 2] | 0, A = A + O * c[L + 1] | 0, y = y + O * c[L] | 0, L = L + 4 | 0;
                                f[k + 3] = o(C + (1 << 13) >> 14), f[k + 2] = o(w + (1 << 13) >> 14), f[k + 1] = o(A + (1 << 13) >> 14), f[k] = o(y + (1 << 13) >> 14), k = k + m * 4 | 0
                            }
                            k = (I + 1) * 4 | 0, X = (I + 1) * h * 4 | 0
                        }
                    }
                    i.exports = {
                        convolveHorizontally: l,
                        convolveVertically: a
                    }
                }, {}],
                3: [function(r, i, s) {
                    "use strict";
                    i.exports = "AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEXA2AAAGAGf39/f39/AGAHf39/f39/fwACDwEDZW52Bm1lbW9yeQIAAAMEAwABAgYGAX8AQQALB1cFEV9fd2FzbV9jYWxsX2N0b3JzAAAIY29udm9sdmUAAQpjb252b2x2ZUhWAAIMX19kc29faGFuZGxlAwAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAAK7AMDAwABC8YDAQ9/AkAgA0UNACAERQ0AA0AgDCENQQAhE0EAIQcDQCAHQQJqIQYCfyAHQQF0IAVqIgcuAQIiFEUEQEGAwAAhCEGAwAAhCUGAwAAhCkGAwAAhCyAGDAELIBIgBy4BAGohCEEAIQsgFCEHQQAhDiAGIQlBACEPQQAhEANAIAUgCUEBdGouAQAiESAAIAhBAnRqKAIAIgpBGHZsIBBqIRAgCkH/AXEgEWwgC2ohCyAKQRB2Qf8BcSARbCAPaiEPIApBCHZB/wFxIBFsIA5qIQ4gCEEBaiEIIAlBAWohCSAHQQFrIgcNAAsgC0GAQGshCCAOQYBAayEJIA9BgEBrIQogEEGAQGshCyAGIBRqCyEHIAEgDUECdGogCUEOdSIGQf8BIAZB/wFIGyIGQQAgBkEAShtBCHRBgP4DcSAKQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG0EQdEGAgPwHcSALQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG0EYdHJyIAhBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobcjYCACADIA1qIQ0gE0EBaiITIARHDQALIAxBAWoiDCACbCESIAMgDEcNAAsLCx4AQQAgAiADIAQgBSAAEAEgAkEAIAQgBSAGIAEQAQs="
                }, {}],
                4: [function(r, i, s) {
                    "use strict";
                    i.exports = {
                        name: "resize",
                        fn: r("./resize"),
                        wasm_fn: r("./resize_wasm"),
                        wasm_src: r("./convolve_wasm_base64")
                    }
                }, {
                    "./convolve_wasm_base64": 3,
                    "./resize": 5,
                    "./resize_wasm": 8
                }],
                5: [function(r, i, s) {
                    "use strict";
                    var o = r("./resize_filter_gen"),
                        l = r("./convolve").convolveHorizontally,
                        a = r("./convolve").convolveVertically;

                    function c(f, h, m) {
                        for (var v = 3, g = h * m * 4 | 0; v < g;) f[v] = 255, v = v + 4 | 0
                    }
                    i.exports = function(h) {
                        var m = h.src,
                            v = h.width,
                            g = h.height,
                            y = h.toWidth,
                            A = h.toHeight,
                            w = h.scaleX || h.toWidth / h.width,
                            C = h.scaleY || h.toHeight / h.height,
                            S = h.offsetX || 0,
                            E = h.offsetY || 0,
                            M = h.dest || new Uint8Array(y * A * 4),
                            L = typeof h.quality == "undefined" ? 3 : h.quality,
                            I = h.alpha || !1,
                            z = o(L, v, y, w, S),
                            O = o(L, g, A, C, E),
                            X = new Uint8Array(y * g * 4);
                        return l(m, X, v, g, y, z), a(X, M, g, y, A, O), I || c(M, y, A), M
                    }
                }, {
                    "./convolve": 2,
                    "./resize_filter_gen": 6
                }],
                6: [function(r, i, s) {
                    "use strict";
                    var o = r("./resize_filter_info"),
                        l = 14;

                    function a(c) {
                        return Math.round(c * ((1 << l) - 1))
                    }
                    i.exports = function(f, h, m, v, g) {
                        var y = o[f].filter,
                            A = 1 / v,
                            w = Math.min(1, v),
                            C = o[f].win / w,
                            S, E, M, L, I, z, O, X, k, Q, te, Z, le, B, U, G, V, j = Math.floor((C + 1) * 2),
                            ne = new Int16Array((j + 2) * m),
                            F = 0,
                            Y = !ne.subarray || !ne.set;
                        for (S = 0; S < m; S++) {
                            for (E = (S + .5) * A + g, M = Math.max(0, Math.floor(E - C)), L = Math.min(h - 1, Math.ceil(E + C)), I = L - M + 1, z = new Float32Array(I), O = new Int16Array(I), X = 0, k = M, Q = 0; k <= L; k++, Q++) te = y((k + .5 - E) * w), X += te, z[Q] = te;
                            for (Z = 0, Q = 0; Q < z.length; Q++) le = z[Q] / X, Z += le, O[Q] = a(le);
                            for (O[m >> 1] += a(1 - Z), B = 0; B < O.length && O[B] === 0;) B++;
                            if (B < O.length) {
                                for (U = O.length - 1; U > 0 && O[U] === 0;) U--;
                                if (G = M + B, V = U - B + 1, ne[F++] = G, ne[F++] = V, !Y) ne.set(O.subarray(B, U + 1), F), F += V;
                                else
                                    for (Q = B; Q <= U; Q++) ne[F++] = O[Q]
                            } else ne[F++] = 0, ne[F++] = 0
                        }
                        return ne
                    }
                }, {
                    "./resize_filter_info": 7
                }],
                7: [function(r, i, s) {
                    "use strict";
                    i.exports = [{
                        win: .5,
                        filter: function(l) {
                            return l >= -.5 && l < .5 ? 1 : 0
                        }
                    }, {
                        win: 1,
                        filter: function(l) {
                            if (l <= -1 || l >= 1) return 0;
                            if (l > -11920929e-14 && l < 11920929e-14) return 1;
                            var a = l * Math.PI;
                            return Math.sin(a) / a * (.54 + .46 * Math.cos(a / 1))
                        }
                    }, {
                        win: 2,
                        filter: function(l) {
                            if (l <= -2 || l >= 2) return 0;
                            if (l > -11920929e-14 && l < 11920929e-14) return 1;
                            var a = l * Math.PI;
                            return Math.sin(a) / a * Math.sin(a / 2) / (a / 2)
                        }
                    }, {
                        win: 3,
                        filter: function(l) {
                            if (l <= -3 || l >= 3) return 0;
                            if (l > -11920929e-14 && l < 11920929e-14) return 1;
                            var a = l * Math.PI;
                            return Math.sin(a) / a * Math.sin(a / 3) / (a / 3)
                        }
                    }]
                }, {}],
                8: [function(r, i, s) {
                    "use strict";
                    var o = r("./resize_filter_gen");

                    function l(h, m, v) {
                        for (var g = 3, y = m * v * 4 | 0; g < y;) h[g] = 255, g = g + 4 | 0
                    }

                    function a(h) {
                        return new Uint8Array(h.buffer, 0, h.byteLength)
                    }
                    var c = !0;
                    try {
                        c = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1
                    } catch (h) {}

                    function f(h, m, v) {
                        if (c) {
                            m.set(a(h), v);
                            return
                        }
                        for (var g = v, y = 0; y < h.length; y++) {
                            var A = h[y];
                            m[g++] = A & 255, m[g++] = A >> 8 & 255
                        }
                    }
                    i.exports = function(m) {
                        var v = m.src,
                            g = m.width,
                            y = m.height,
                            A = m.toWidth,
                            w = m.toHeight,
                            C = m.scaleX || m.toWidth / m.width,
                            S = m.scaleY || m.toHeight / m.height,
                            E = m.offsetX || 0,
                            M = m.offsetY || 0,
                            L = m.dest || new Uint8Array(A * w * 4),
                            I = typeof m.quality == "undefined" ? 3 : m.quality,
                            z = m.alpha || !1,
                            O = o(I, g, A, C, E),
                            X = o(I, y, w, S, M),
                            k = 0,
                            Q = this.__align(k + Math.max(v.byteLength, L.byteLength)),
                            te = this.__align(Q + y * A * 4),
                            Z = this.__align(te + O.byteLength),
                            le = Z + X.byteLength,
                            B = this.__instance("resize", le),
                            U = new Uint8Array(this.__memory.buffer),
                            G = new Uint32Array(this.__memory.buffer),
                            V = new Uint32Array(v.buffer);
                        G.set(V), f(O, U, te), f(X, U, Z);
                        var j = B.exports.convolveHV || B.exports._convolveHV;
                        j(te, Z, Q, g, y, A, w);
                        var ne = new Uint32Array(L.buffer);
                        return ne.set(new Uint32Array(this.__memory.buffer, 0, w * A)), z || l(L, A, w), L
                    }
                }, {
                    "./resize_filter_gen": 6
                }],
                9: [function(r, i, s) {
                    "use strict";
                    i.exports = {
                        name: "unsharp_mask",
                        fn: r("./unsharp_mask"),
                        wasm_fn: r("./unsharp_mask_wasm"),
                        wasm_src: r("./unsharp_mask_wasm_base64")
                    }
                }, {
                    "./unsharp_mask": 10,
                    "./unsharp_mask_wasm": 11,
                    "./unsharp_mask_wasm_base64": 12
                }],
                10: [function(r, i, s) {
                    "use strict";
                    var o = r("glur/mono16");

                    function l(a, c, f) {
                        for (var h = c * f, m = new Uint16Array(h), v, g, y, A, w = 0; w < h; w++) v = a[4 * w], g = a[4 * w + 1], y = a[4 * w + 2], A = v >= g && v >= y ? v : g >= y && g >= v ? g : y, m[w] = A << 8;
                        return m
                    }
                    i.exports = function(c, f, h, m, v, g) {
                        var y, A, w, C, S;
                        if (!(m === 0 || v < .5)) {
                            v > 2 && (v = 2);
                            var E = l(c, f, h),
                                M = new Uint16Array(E);
                            o(M, f, h, v);
                            for (var L = m / 100 * 4096 + .5 | 0, I = g << 8, z = f * h, O = 0; O < z; O++) y = E[O], C = y - M[O], Math.abs(C) >= I && (A = y + (L * C + 2048 >> 12), A = A > 65280 ? 65280 : A, A = A < 0 ? 0 : A, y = y !== 0 ? y : 1, w = (A << 12) / y | 0, S = O * 4, c[S] = c[S] * w + 2048 >> 12, c[S + 1] = c[S + 1] * w + 2048 >> 12, c[S + 2] = c[S + 2] * w + 2048 >> 12)
                        }
                    }
                }, {
                    "glur/mono16": 18
                }],
                11: [function(r, i, s) {
                    "use strict";
                    i.exports = function(l, a, c, f, h, m) {
                        if (!(f === 0 || h < .5)) {
                            h > 2 && (h = 2);
                            var v = a * c,
                                g = v * 4,
                                y = v * 2,
                                A = v * 2,
                                w = Math.max(a, c) * 4,
                                C = 8 * 4,
                                S = 0,
                                E = g,
                                M = E + y,
                                L = M + A,
                                I = L + A,
                                z = I + w,
                                O = this.__instance("unsharp_mask", g + y + A * 2 + w + C, {
                                    exp: Math.exp
                                }),
                                X = new Uint32Array(l.buffer),
                                k = new Uint32Array(this.__memory.buffer);
                            k.set(X);
                            var Q = O.exports.hsv_v16 || O.exports._hsv_v16;
                            Q(S, E, a, c), Q = O.exports.blurMono16 || O.exports._blurMono16, Q(E, M, L, I, z, a, c, h), Q = O.exports.unsharp || O.exports._unsharp, Q(S, S, E, M, a, c, f, m), X.set(new Uint32Array(this.__memory.buffer, 0, v))
                        }
                    }
                }, {}],
                12: [function(r, i, s) {
                    "use strict";
                    i.exports = "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"
                }, {}],
                13: [function(r, i, s) {
                    "use strict";
                    var o = 100;

                    function l(a, c) {
                        this.create = a, this.available = [], this.acquired = {}, this.lastId = 1, this.timeoutId = 0, this.idle = c || 2e3
                    }
                    l.prototype.acquire = function() {
                        var a = this,
                            c;
                        return this.available.length !== 0 ? c = this.available.pop() : (c = this.create(), c.id = this.lastId++, c.release = function() {
                            return a.release(c)
                        }), this.acquired[c.id] = c, c
                    }, l.prototype.release = function(a) {
                        var c = this;
                        delete this.acquired[a.id], a.lastUsed = Date.now(), this.available.push(a), this.timeoutId === 0 && (this.timeoutId = setTimeout(function() {
                            return c.gc()
                        }, o))
                    }, l.prototype.gc = function() {
                        var a = this,
                            c = Date.now();
                        this.available = this.available.filter(function(f) {
                            return c - f.lastUsed > a.idle ? (f.destroy(), !1) : !0
                        }), this.available.length !== 0 ? this.timeoutId = setTimeout(function() {
                            return a.gc()
                        }, o) : this.timeoutId = 0
                    }, i.exports = l
                }, {}],
                14: [function(r, i, s) {
                    "use strict";
                    var o = 2;
                    i.exports = function(a, c, f, h, m, v) {
                        var g = f / a,
                            y = h / c,
                            A = (2 * v + o + 1) / m;
                        if (A > .5) return [
                            [f, h]
                        ];
                        var w = Math.ceil(Math.log(Math.min(g, y)) / Math.log(A));
                        if (w <= 1) return [
                            [f, h]
                        ];
                        for (var C = [], S = 0; S < w; S++) {
                            var E = Math.round(Math.pow(Math.pow(a, w - S - 1) * Math.pow(f, S + 1), 1 / w)),
                                M = Math.round(Math.pow(Math.pow(c, w - S - 1) * Math.pow(h, S + 1), 1 / w));
                            C.push([E, M])
                        }
                        return C
                    }
                }, {}],
                15: [function(r, i, s) {
                    "use strict";
                    var o = 1e-5;

                    function l(c) {
                        var f = Math.round(c);
                        return Math.abs(c - f) < o ? f : Math.floor(c)
                    }

                    function a(c) {
                        var f = Math.round(c);
                        return Math.abs(c - f) < o ? f : Math.ceil(c)
                    }
                    i.exports = function(f) {
                        var h = f.toWidth / f.width,
                            m = f.toHeight / f.height,
                            v = l(f.srcTileSize * h) - 2 * f.destTileBorder,
                            g = l(f.srcTileSize * m) - 2 * f.destTileBorder;
                        if (v < 1 || g < 1) throw new Error("Internal error in pica: target tile width/height is too small.");
                        var y, A, w, C, S, E, M = [],
                            L;
                        for (C = 0; C < f.toHeight; C += g)
                            for (w = 0; w < f.toWidth; w += v) y = w - f.destTileBorder, y < 0 && (y = 0), S = w + v + f.destTileBorder - y, y + S >= f.toWidth && (S = f.toWidth - y), A = C - f.destTileBorder, A < 0 && (A = 0), E = C + g + f.destTileBorder - A, A + E >= f.toHeight && (E = f.toHeight - A), L = {
                                toX: y,
                                toY: A,
                                toWidth: S,
                                toHeight: E,
                                toInnerX: w,
                                toInnerY: C,
                                toInnerWidth: v,
                                toInnerHeight: g,
                                offsetX: y / h - l(y / h),
                                offsetY: A / m - l(A / m),
                                scaleX: h,
                                scaleY: m,
                                x: l(y / h),
                                y: l(A / m),
                                width: a(S / h),
                                height: a(E / m)
                            }, M.push(L);
                        return M
                    }
                }, {}],
                16: [function(r, i, s) {
                    "use strict";

                    function o(l) {
                        return Object.prototype.toString.call(l)
                    }
                    i.exports.isCanvas = function(a) {
                        var c = o(a);
                        return c === "[object HTMLCanvasElement]" || c === "[object OffscreenCanvas]" || c === "[object Canvas]"
                    }, i.exports.isImage = function(a) {
                        return o(a) === "[object HTMLImageElement]"
                    }, i.exports.isImageBitmap = function(a) {
                        return o(a) === "[object ImageBitmap]"
                    }, i.exports.limiter = function(a) {
                        var c = 0,
                            f = [];

                        function h() {
                            c < a && f.length && (c++, f.shift()())
                        }
                        return function(v) {
                            return new Promise(function(g, y) {
                                f.push(function() {
                                    v().then(function(A) {
                                        g(A), c--, h()
                                    }, function(A) {
                                        y(A), c--, h()
                                    })
                                }), h()
                            })
                        }
                    }, i.exports.cib_quality_name = function(a) {
                        switch (a) {
                            case 0:
                                return "pixelated";
                            case 1:
                                return "low";
                            case 2:
                                return "medium"
                        }
                        return "high"
                    }, i.exports.cib_support = function(a) {
                        return Promise.resolve().then(function() {
                            if (typeof createImageBitmap == "undefined") return !1;
                            var c = a(100, 100);
                            return createImageBitmap(c, 0, 0, 100, 100, {
                                resizeWidth: 10,
                                resizeHeight: 10,
                                resizeQuality: "high"
                            }).then(function(f) {
                                var h = f.width === 10;
                                return f.close(), c = null, h
                            })
                        }).catch(function() {
                            return !1
                        })
                    }, i.exports.worker_offscreen_canvas_support = function() {
                        return new Promise(function(a, c) {
                            if (typeof OffscreenCanvas == "undefined") {
                                a(!1);
                                return
                            }

                            function f(v) {
                                if (typeof createImageBitmap == "undefined") {
                                    v.postMessage(!1);
                                    return
                                }
                                Promise.resolve().then(function() {
                                    var g = new OffscreenCanvas(10, 10),
                                        y = g.getContext("2d");
                                    return y.rect(0, 0, 1, 1), createImageBitmap(g, 0, 0, 1, 1)
                                }).then(function() {
                                    return v.postMessage(!0)
                                }, function() {
                                    return v.postMessage(!1)
                                })
                            }
                            var h = btoa("(".concat(f.toString(), ")(self);")),
                                m = new Worker("data:text/javascript;base64,".concat(h));
                            m.onmessage = function(v) {
                                return a(v.data)
                            }, m.onerror = c
                        }).then(function(a) {
                            return a
                        }, function() {
                            return !1
                        })
                    }, i.exports.can_use_canvas = function(a) {
                        var c = !1;
                        try {
                            var f = a(2, 1),
                                h = f.getContext("2d"),
                                m = h.createImageData(2, 1);
                            m.data[0] = 12, m.data[1] = 23, m.data[2] = 34, m.data[3] = 255, m.data[4] = 45, m.data[5] = 56, m.data[6] = 67, m.data[7] = 255, h.putImageData(m, 0, 0), m = null, m = h.getImageData(0, 0, 2, 1), m.data[0] === 12 && m.data[1] === 23 && m.data[2] === 34 && m.data[3] === 255 && m.data[4] === 45 && m.data[5] === 56 && m.data[6] === 67 && m.data[7] === 255 && (c = !0)
                        } catch (v) {}
                        return c
                    }, i.exports.cib_can_use_region = function() {
                        return new Promise(function(a) {
                            if (typeof createImageBitmap == "undefined") {
                                a(!1);
                                return
                            }
                            var c = new Image;
                            c.src = "data:image/jpeg;base64,/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRcZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRAf/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z", c.onload = function() {
                                createImageBitmap(c, 0, 0, c.width, c.height).then(function(f) {
                                    f.width === c.width && f.height === c.height ? a(!0) : a(!1)
                                }, function() {
                                    return a(!1)
                                })
                            }, c.onerror = function() {
                                return a(!1)
                            }
                        })
                    }
                }, {}],
                17: [function(r, i, s) {
                    "use strict";
                    i.exports = function() {
                        var o = r("./mathlib"),
                            l;
                        onmessage = function(c) {
                            var f = c.data.opts,
                                h = !1;
                            if (!f.src && f.srcBitmap) {
                                var m = new OffscreenCanvas(f.width, f.height),
                                    v = m.getContext("2d", {
                                        alpha: Boolean(f.alpha)
                                    });
                                v.drawImage(f.srcBitmap, 0, 0), f.src = v.getImageData(0, 0, f.width, f.height).data, m.width = m.height = 0, m = null, f.srcBitmap.close(), f.srcBitmap = null, h = !0
                            }
                            l || (l = new o(c.data.features));
                            var g = l.resizeAndUnsharp(f);
                            if (h) {
                                var y = new ImageData(new Uint8ClampedArray(g), f.toWidth, f.toHeight),
                                    A = new OffscreenCanvas(f.toWidth, f.toHeight),
                                    w = A.getContext("2d", {
                                        alpha: Boolean(f.alpha)
                                    });
                                w.putImageData(y, 0, 0), createImageBitmap(A).then(function(C) {
                                    postMessage({
                                        bitmap: C
                                    }, [C])
                                })
                            } else postMessage({
                                data: g
                            }, [g.buffer])
                        }
                    }
                }, {
                    "./mathlib": 1
                }],
                18: [function(r, i, s) {
                    var o, l, a, c, f, h, m, v;

                    function g(w) {
                        w < .5 && (w = .5);
                        var C = Math.exp(.726 * .726) / w,
                            S = Math.exp(-C),
                            E = Math.exp(-2 * C),
                            M = (1 - S) * (1 - S) / (1 + 2 * C * S - E);
                        return o = M, l = M * (C - 1) * S, a = M * (C + 1) * S, c = -M * E, f = 2 * S, h = -E, m = (o + l) / (1 - f - h), v = (a + c) / (1 - f - h), new Float32Array([o, l, a, c, f, h, m, v])
                    }

                    function y(w, C, S, E, M, L) {
                        var I, z, O, X, k, Q, te, Z, le, B, U, G, V, j;
                        for (le = 0; le < L; le++) {
                            for (Q = le * M, te = le, Z = 0, I = w[Q], k = I * E[6], X = k, U = E[0], G = E[1], V = E[4], j = E[5], B = 0; B < M; B++) z = w[Q], O = z * U + I * G + X * V + k * j, k = X, X = O, I = z, S[Z] = X, Z++, Q++;
                            for (Q--, Z--, te += L * (M - 1), I = w[Q], k = I * E[7], X = k, z = I, U = E[2], G = E[3], B = M - 1; B >= 0; B--) O = z * U + I * G + X * V + k * j, k = X, X = O, I = z, z = w[Q], C[te] = S[Z] + X, Q--, Z--, te -= L
                        }
                    }

                    function A(w, C, S, E) {
                        if (!!E) {
                            var M = new Uint16Array(w.length),
                                L = new Float32Array(Math.max(C, S)),
                                I = g(E);
                            y(w, M, L, I, C, S, E), y(M, w, L, I, S, C, E)
                        }
                    }
                    i.exports = A
                }, {}],
                19: [function(r, i, s) {
                    typeof Object.create == "function" ? i.exports = function(l, a) {
                        a && (l.super_ = a, l.prototype = Object.create(a.prototype, {
                            constructor: {
                                value: l,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }))
                    } : i.exports = function(l, a) {
                        if (a) {
                            l.super_ = a;
                            var c = function() {};
                            c.prototype = a.prototype, l.prototype = new c, l.prototype.constructor = l
                        }
                    }
                }, {}],
                20: [function(r, i, s) {
                    "use strict";
                    var o = r("object-assign"),
                        l = r("./lib/base64decode"),
                        a = r("./lib/wa_detect"),
                        c = {
                            js: !0,
                            wasm: !0
                        };

                    function f(h) {
                        if (!(this instanceof f)) return new f(h);
                        var m = o({}, c, h || {});
                        if (this.options = m, this.__cache = {}, this.__init_promise = null, this.__modules = m.modules || {}, this.__memory = null, this.__wasm = {}, this.__isLE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1, !this.options.js && !this.options.wasm) throw new Error('mathlib: at least "js" or "wasm" should be enabled')
                    }
                    f.prototype.has_wasm = a, f.prototype.use = function(h) {
                        return this.__modules[h.name] = h, this.options.wasm && this.has_wasm() && h.wasm_fn ? this[h.name] = h.wasm_fn : this[h.name] = h.fn, this
                    }, f.prototype.init = function() {
                        if (this.__init_promise) return this.__init_promise;
                        if (!this.options.js && this.options.wasm && !this.has_wasm()) return Promise.reject(new Error(`mathlib: only "wasm" was enabled, but it's not supported`));
                        var h = this;
                        return this.__init_promise = Promise.all(Object.keys(h.__modules).map(function(m) {
                            var v = h.__modules[m];
                            return !h.options.wasm || !h.has_wasm() || !v.wasm_fn || h.__wasm[m] ? null : WebAssembly.compile(h.__base64decode(v.wasm_src)).then(function(g) {
                                h.__wasm[m] = g
                            })
                        })).then(function() {
                            return h
                        }), this.__init_promise
                    }, f.prototype.__base64decode = l, f.prototype.__reallocate = function(m) {
                        if (!this.__memory) return this.__memory = new WebAssembly.Memory({
                            initial: Math.ceil(m / (64 * 1024))
                        }), this.__memory;
                        var v = this.__memory.buffer.byteLength;
                        return v < m && this.__memory.grow(Math.ceil((m - v) / (64 * 1024))), this.__memory
                    }, f.prototype.__instance = function(m, v, g) {
                        if (v && this.__reallocate(v), !this.__wasm[m]) {
                            var y = this.__modules[m];
                            this.__wasm[m] = new WebAssembly.Module(this.__base64decode(y.wasm_src))
                        }
                        if (!this.__cache[m]) {
                            var A = {
                                memoryBase: 0,
                                memory: this.__memory,
                                tableBase: 0,
                                table: new WebAssembly.Table({
                                    initial: 0,
                                    element: "anyfunc"
                                })
                            };
                            this.__cache[m] = new WebAssembly.Instance(this.__wasm[m], {
                                env: o(A, g || {})
                            })
                        }
                        return this.__cache[m]
                    }, f.prototype.__align = function(m, v) {
                        v = v || 8;
                        var g = m % v;
                        return m + (g ? v - g : 0)
                    }, i.exports = f
                }, {
                    "./lib/base64decode": 21,
                    "./lib/wa_detect": 22,
                    "object-assign": 23
                }],
                21: [function(r, i, s) {
                    "use strict";
                    var o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                    i.exports = function(a) {
                        for (var c = a.replace(/[\r\n=]/g, ""), f = c.length, h = new Uint8Array(f * 3 >> 2), m = 0, v = 0, g = 0; g < f; g++) g % 4 == 0 && g && (h[v++] = m >> 16 & 255, h[v++] = m >> 8 & 255, h[v++] = m & 255), m = m << 6 | o.indexOf(c.charAt(g));
                        var y = f % 4 * 6;
                        return y === 0 ? (h[v++] = m >> 16 & 255, h[v++] = m >> 8 & 255, h[v++] = m & 255) : y === 18 ? (h[v++] = m >> 10 & 255, h[v++] = m >> 2 & 255) : y === 12 && (h[v++] = m >> 4 & 255), h
                    }
                }, {}],
                22: [function(r, i, s) {
                    "use strict";
                    var o;
                    i.exports = function() {
                        if (typeof o != "undefined" || (o = !1, typeof WebAssembly == "undefined")) return o;
                        try {
                            var a = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11]),
                                c = new WebAssembly.Module(a),
                                f = new WebAssembly.Instance(c, {});
                            return f.exports.test(4) !== 0 && (o = !0), o
                        } catch (h) {}
                        return o
                    }
                }, {}],
                23: [function(r, i, s) {
                    "use strict";
                    var o = Object.getOwnPropertySymbols,
                        l = Object.prototype.hasOwnProperty,
                        a = Object.prototype.propertyIsEnumerable;

                    function c(h) {
                        if (h == null) throw new TypeError("Object.assign cannot be called with null or undefined");
                        return Object(h)
                    }

                    function f() {
                        try {
                            if (!Object.assign) return !1;
                            var h = new String("abc");
                            if (h[5] = "de", Object.getOwnPropertyNames(h)[0] === "5") return !1;
                            for (var m = {}, v = 0; v < 10; v++) m["_" + String.fromCharCode(v)] = v;
                            var g = Object.getOwnPropertyNames(m).map(function(A) {
                                return m[A]
                            });
                            if (g.join("") !== "0123456789") return !1;
                            var y = {};
                            return "abcdefghijklmnopqrst".split("").forEach(function(A) {
                                y[A] = A
                            }), Object.keys(Object.assign({}, y)).join("") === "abcdefghijklmnopqrst"
                        } catch (A) {
                            return !1
                        }
                    }
                    i.exports = f() ? Object.assign : function(h, m) {
                        for (var v, g = c(h), y, A = 1; A < arguments.length; A++) {
                            v = Object(arguments[A]);
                            for (var w in v) l.call(v, w) && (g[w] = v[w]);
                            if (o) {
                                y = o(v);
                                for (var C = 0; C < y.length; C++) a.call(v, y[C]) && (g[y[C]] = v[y[C]])
                            }
                        }
                        return g
                    }
                }, {}],
                24: [function(r, i, s) {
                    var o = arguments[3],
                        l = arguments[4],
                        a = arguments[5],
                        c = JSON.stringify;
                    i.exports = function(f, h) {
                        for (var m, v = Object.keys(a), g = 0, y = v.length; g < y; g++) {
                            var A = v[g],
                                w = a[A].exports;
                            if (w === f || w && w.default === f) {
                                m = A;
                                break
                            }
                        }
                        if (!m) {
                            m = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
                            for (var C = {}, g = 0, y = v.length; g < y; g++) {
                                var A = v[g];
                                C[A] = A
                            }
                            l[m] = ["function(require,module,exports){" + f + "(self); }", C]
                        }
                        var S = Math.floor(Math.pow(16, 8) * Math.random()).toString(16),
                            E = {};
                        E[m] = m, l[S] = ["function(require,module,exports){var f = require(" + c(m) + ");(f.default ? f.default : f)(self);}", E];
                        var M = {};
                        L(S);

                        function L(Q) {
                            M[Q] = !0;
                            for (var te in l[Q][1]) {
                                var Z = l[Q][1][te];
                                M[Z] || L(Z)
                            }
                        }
                        var I = "(" + o + ")({" + Object.keys(M).map(function(Q) {
                                return c(Q) + ":[" + l[Q][0] + "," + c(l[Q][1]) + "]"
                            }).join(",") + "},{},[" + c(S) + "])",
                            z = window.URL || window.webkitURL || window.mozURL || window.msURL,
                            O = new Blob([I], {
                                type: "text/javascript"
                            });
                        if (h && h.bare) return O;
                        var X = z.createObjectURL(O),
                            k = new Worker(X);
                        return k.objectURL = X, k
                    }
                }, {}],
                "/index.js": [function(r, i, s) {
                    "use strict";

                    function o(B, U) {
                        return h(B) || f(B, U) || a(B, U) || l()
                    }

                    function l() {
                        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                    }

                    function a(B, U) {
                        if (!!B) {
                            if (typeof B == "string") return c(B, U);
                            var G = Object.prototype.toString.call(B).slice(8, -1);
                            if (G === "Object" && B.constructor && (G = B.constructor.name), G === "Map" || G === "Set") return Array.from(B);
                            if (G === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(G)) return c(B, U)
                        }
                    }

                    function c(B, U) {
                        (U == null || U > B.length) && (U = B.length);
                        for (var G = 0, V = new Array(U); G < U; G++) V[G] = B[G];
                        return V
                    }

                    function f(B, U) {
                        var G = B == null ? null : typeof Symbol != "undefined" && B[Symbol.iterator] || B["@@iterator"];
                        if (G != null) {
                            var V = [],
                                j = !0,
                                ne = !1,
                                F, Y;
                            try {
                                for (G = G.call(B); !(j = (F = G.next()).done) && (V.push(F.value), !(U && V.length === U)); j = !0);
                            } catch ($) {
                                ne = !0, Y = $
                            } finally {
                                try {
                                    !j && G.return != null && G.return()
                                } finally {
                                    if (ne) throw Y
                                }
                            }
                            return V
                        }
                    }

                    function h(B) {
                        if (Array.isArray(B)) return B
                    }
                    var m = r("object-assign"),
                        v = r("webworkify"),
                        g = r("./lib/mathlib"),
                        y = r("./lib/pool"),
                        A = r("./lib/utils"),
                        w = r("./lib/worker"),
                        C = r("./lib/stepper"),
                        S = r("./lib/tiler"),
                        E = {},
                        M = !1;
                    try {
                        typeof navigator != "undefined" && navigator.userAgent && (M = navigator.userAgent.indexOf("Safari") >= 0)
                    } catch (B) {}
                    var L = 1;
                    typeof navigator != "undefined" && (L = Math.min(navigator.hardwareConcurrency || 1, 4));
                    var I = {
                            tile: 1024,
                            concurrency: L,
                            features: ["js", "wasm", "ww"],
                            idle: 2e3,
                            createCanvas: function(U, G) {
                                var V = document.createElement("canvas");
                                return V.width = U, V.height = G, V
                            }
                        },
                        z = {
                            quality: 3,
                            alpha: !1,
                            unsharpAmount: 0,
                            unsharpRadius: 0,
                            unsharpThreshold: 0
                        },
                        O = !1,
                        X = !1,
                        k = !1,
                        Q = !1,
                        te = !1;

                    function Z() {
                        return {
                            value: v(w),
                            destroy: function() {
                                if (this.value.terminate(), typeof window != "undefined") {
                                    var U = window.URL || window.webkitURL || window.mozURL || window.msURL;
                                    U && U.revokeObjectURL && this.value.objectURL && U.revokeObjectURL(this.value.objectURL)
                                }
                            }
                        }
                    }

                    function le(B) {
                        if (!(this instanceof le)) return new le(B);
                        this.options = m({}, I, B || {});
                        var U = "lk_".concat(this.options.concurrency);
                        this.__limit = E[U] || A.limiter(this.options.concurrency), E[U] || (E[U] = this.__limit), this.features = {
                            js: !1,
                            wasm: !1,
                            cib: !1,
                            ww: !1
                        }, this.__workersPool = null, this.__requested_features = [], this.__mathlib = null
                    }
                    le.prototype.init = function() {
                        var B = this;
                        if (this.__initPromise) return this.__initPromise;
                        if (typeof ImageData != "undefined" && typeof Uint8ClampedArray != "undefined") try {
                            new ImageData(new Uint8ClampedArray(400), 10, 10), O = !0
                        } catch ($) {}
                        typeof ImageBitmap != "undefined" && (ImageBitmap.prototype && ImageBitmap.prototype.close ? X = !0 : this.debug("ImageBitmap does not support .close(), disabled"));
                        var U = this.options.features.slice();
                        if (U.indexOf("all") >= 0 && (U = ["cib", "wasm", "js", "ww"]), this.__requested_features = U, this.__mathlib = new g(U), U.indexOf("ww") >= 0 && typeof window != "undefined" && "Worker" in window) try {
                            var G = r("webworkify")(function() {});
                            G.terminate(), this.features.ww = !0;
                            var V = "wp_".concat(JSON.stringify(this.options));
                            E[V] ? this.__workersPool = E[V] : (this.__workersPool = new y(Z, this.options.idle), E[V] = this.__workersPool)
                        } catch ($) {}
                        var j = this.__mathlib.init().then(function($) {
                                m(B.features, $.features)
                            }),
                            ne;
                        X ? ne = A.cib_support(this.options.createCanvas).then(function($) {
                            if (B.features.cib && U.indexOf("cib") < 0) {
                                B.debug("createImageBitmap() resize supported, but disabled by config");
                                return
                            }
                            U.indexOf("cib") >= 0 && (B.features.cib = $)
                        }) : ne = Promise.resolve(!1), k = A.can_use_canvas(this.options.createCanvas);
                        var F;
                        X && O && U.indexOf("ww") !== -1 ? F = A.worker_offscreen_canvas_support() : F = Promise.resolve(!1), F = F.then(function($) {
                            Q = $
                        });
                        var Y = A.cib_can_use_region().then(function($) {
                            te = $
                        });
                        return this.__initPromise = Promise.all([j, ne, F, Y]).then(function() {
                            return B
                        }), this.__initPromise
                    }, le.prototype.__invokeResize = function(B, U) {
                        var G = this;
                        return U.__mathCache = U.__mathCache || {}, Promise.resolve().then(function() {
                            return G.features.ww ? new Promise(function(V, j) {
                                var ne = G.__workersPool.acquire();
                                U.cancelToken && U.cancelToken.catch(function(Y) {
                                    return j(Y)
                                }), ne.value.onmessage = function(Y) {
                                    ne.release(), Y.data.err ? j(Y.data.err) : V(Y.data)
                                };
                                var F = [];
                                B.src && F.push(B.src.buffer), B.srcBitmap && F.push(B.srcBitmap), ne.value.postMessage({
                                    opts: B,
                                    features: G.__requested_features,
                                    preload: {
                                        wasm_nodule: G.__mathlib.__
                                    }
                                }, F)
                            }) : {
                                data: G.__mathlib.resizeAndUnsharp(B, U.__mathCache)
                            }
                        })
                    }, le.prototype.__extractTileData = function(B, U, G, V, j) {
                        if (this.features.ww && Q && (A.isCanvas(U) || te)) return this.debug("Create tile for OffscreenCanvas"), createImageBitmap(V.srcImageBitmap || U, B.x, B.y, B.width, B.height).then(function(Y) {
                            return j.srcBitmap = Y, j
                        });
                        if (A.isCanvas(U)) return V.srcCtx || (V.srcCtx = U.getContext("2d", {
                            alpha: Boolean(G.alpha)
                        })), this.debug("Get tile pixel data"), j.src = V.srcCtx.getImageData(B.x, B.y, B.width, B.height).data, j;
                        this.debug("Draw tile imageBitmap/image to temporary canvas");
                        var ne = this.options.createCanvas(B.width, B.height),
                            F = ne.getContext("2d", {
                                alpha: Boolean(G.alpha)
                            });
                        return F.globalCompositeOperation = "copy", F.drawImage(V.srcImageBitmap || U, B.x, B.y, B.width, B.height, 0, 0, B.width, B.height), this.debug("Get tile pixel data"), j.src = F.getImageData(0, 0, B.width, B.height).data, ne.width = ne.height = 0, j
                    }, le.prototype.__landTileData = function(B, U, G) {
                        var V;
                        if (this.debug("Convert raw rgba tile result to ImageData"), U.bitmap) return G.toCtx.drawImage(U.bitmap, B.toX, B.toY), null;
                        if (O) V = new ImageData(new Uint8ClampedArray(U.data), B.toWidth, B.toHeight);
                        else if (V = G.toCtx.createImageData(B.toWidth, B.toHeight), V.data.set) V.data.set(U.data);
                        else
                            for (var j = V.data.length - 1; j >= 0; j--) V.data[j] = U.data[j];
                        return this.debug("Draw tile"), M ? G.toCtx.putImageData(V, B.toX, B.toY, B.toInnerX - B.toX, B.toInnerY - B.toY, B.toInnerWidth + 1e-5, B.toInnerHeight + 1e-5) : G.toCtx.putImageData(V, B.toX, B.toY, B.toInnerX - B.toX, B.toInnerY - B.toY, B.toInnerWidth, B.toInnerHeight), null
                    }, le.prototype.__tileAndResize = function(B, U, G) {
                        var V = this,
                            j = {
                                srcCtx: null,
                                srcImageBitmap: null,
                                isImageBitmapReused: !1,
                                toCtx: null
                            },
                            ne = function(Y) {
                                return V.__limit(function() {
                                    if (G.canceled) return G.cancelToken;
                                    var $ = {
                                        width: Y.width,
                                        height: Y.height,
                                        toWidth: Y.toWidth,
                                        toHeight: Y.toHeight,
                                        scaleX: Y.scaleX,
                                        scaleY: Y.scaleY,
                                        offsetX: Y.offsetX,
                                        offsetY: Y.offsetY,
                                        quality: G.quality,
                                        alpha: G.alpha,
                                        unsharpAmount: G.unsharpAmount,
                                        unsharpRadius: G.unsharpRadius,
                                        unsharpThreshold: G.unsharpThreshold
                                    };
                                    return V.debug("Invoke resize math"), Promise.resolve($).then(function(re) {
                                        return V.__extractTileData(Y, B, G, j, re)
                                    }).then(function(re) {
                                        return V.debug("Invoke resize math"), V.__invokeResize(re, G)
                                    }).then(function(re) {
                                        return G.canceled ? G.cancelToken : (j.srcImageData = null, V.__landTileData(Y, re, j))
                                    })
                                })
                            };
                        return Promise.resolve().then(function() {
                            if (j.toCtx = U.getContext("2d", {
                                    alpha: Boolean(G.alpha)
                                }), A.isCanvas(B)) return null;
                            if (A.isImageBitmap(B)) return j.srcImageBitmap = B, j.isImageBitmapReused = !0, null;
                            if (A.isImage(B)) return X ? (V.debug("Decode image via createImageBitmap"), createImageBitmap(B).then(function(F) {
                                j.srcImageBitmap = F
                            }).catch(function(F) {
                                return null
                            })) : null;
                            throw new Error('Pica: ".from" should be Image, Canvas or ImageBitmap')
                        }).then(function() {
                            if (G.canceled) return G.cancelToken;
                            V.debug("Calculate tiles");
                            var F = S({
                                    width: G.width,
                                    height: G.height,
                                    srcTileSize: V.options.tile,
                                    toWidth: G.toWidth,
                                    toHeight: G.toHeight,
                                    destTileBorder: G.__destTileBorder
                                }),
                                Y = F.map(function(re) {
                                    return ne(re)
                                });

                            function $(re) {
                                re.srcImageBitmap && (re.isImageBitmapReused || re.srcImageBitmap.close(), re.srcImageBitmap = null)
                            }
                            return V.debug("Process tiles"), Promise.all(Y).then(function() {
                                return V.debug("Finished!"), $(j), U
                            }, function(re) {
                                throw $(j), re
                            })
                        })
                    }, le.prototype.__processStages = function(B, U, G, V) {
                        var j = this;
                        if (V.canceled) return V.cancelToken;
                        var ne = B.shift(),
                            F = o(ne, 2),
                            Y = F[0],
                            $ = F[1],
                            re = B.length === 0;
                        V = m({}, V, {
                            toWidth: Y,
                            toHeight: $,
                            quality: re ? V.quality : Math.min(1, V.quality)
                        });
                        var fe;
                        return re || (fe = this.options.createCanvas(Y, $)), this.__tileAndResize(U, re ? G : fe, V).then(function() {
                            return re ? G : (V.width = Y, V.height = $, j.__processStages(B, fe, G, V))
                        }).then(function(ye) {
                            return fe && (fe.width = fe.height = 0), ye
                        })
                    }, le.prototype.__resizeViaCreateImageBitmap = function(B, U, G) {
                        var V = this,
                            j = U.getContext("2d", {
                                alpha: Boolean(G.alpha)
                            });
                        return this.debug("Resize via createImageBitmap()"), createImageBitmap(B, {
                            resizeWidth: G.toWidth,
                            resizeHeight: G.toHeight,
                            resizeQuality: A.cib_quality_name(G.quality)
                        }).then(function(ne) {
                            if (G.canceled) return G.cancelToken;
                            if (!G.unsharpAmount) return j.drawImage(ne, 0, 0), ne.close(), j = null, V.debug("Finished!"), U;
                            V.debug("Unsharp result");
                            var F = V.options.createCanvas(G.toWidth, G.toHeight),
                                Y = F.getContext("2d", {
                                    alpha: Boolean(G.alpha)
                                });
                            Y.drawImage(ne, 0, 0), ne.close();
                            var $ = Y.getImageData(0, 0, G.toWidth, G.toHeight);
                            return V.__mathlib.unsharp_mask($.data, G.toWidth, G.toHeight, G.unsharpAmount, G.unsharpRadius, G.unsharpThreshold), j.putImageData($, 0, 0), F.width = F.height = 0, $ = Y = F = j = null, V.debug("Finished!"), U
                        })
                    }, le.prototype.resize = function(B, U, G) {
                        var V = this;
                        this.debug("Start resize...");
                        var j = m({}, z);
                        if (isNaN(G) ? G && (j = m(j, G)) : j = m(j, {
                                quality: G
                            }), j.toWidth = U.width, j.toHeight = U.height, j.width = B.naturalWidth || B.width, j.height = B.naturalHeight || B.height, U.width === 0 || U.height === 0) return Promise.reject(new Error("Invalid output size: ".concat(U.width, "x").concat(U.height)));
                        j.unsharpRadius > 2 && (j.unsharpRadius = 2), j.canceled = !1, j.cancelToken && (j.cancelToken = j.cancelToken.then(function(F) {
                            throw j.canceled = !0, F
                        }, function(F) {
                            throw j.canceled = !0, F
                        }));
                        var ne = 3;
                        return j.__destTileBorder = Math.ceil(Math.max(ne, 2.5 * j.unsharpRadius | 0)), this.init().then(function() {
                            if (j.canceled) return j.cancelToken;
                            if (V.features.cib) return V.__resizeViaCreateImageBitmap(B, U, j);
                            if (!k) {
                                var F = new Error("Pica: cannot use getImageData on canvas, make sure fingerprinting protection isn't enabled");
                                throw F.code = "ERR_GET_IMAGE_DATA", F
                            }
                            var Y = C(j.width, j.height, j.toWidth, j.toHeight, V.options.tile, j.__destTileBorder);
                            return V.__processStages(Y, B, U, j)
                        })
                    }, le.prototype.resizeBuffer = function(B) {
                        var U = this,
                            G = m({}, z, B);
                        return this.init().then(function() {
                            return U.__mathlib.resizeAndUnsharp(G)
                        })
                    }, le.prototype.toBlob = function(B, U, G) {
                        return U = U || "image/png", new Promise(function(V) {
                            if (B.toBlob) {
                                B.toBlob(function($) {
                                    return V($)
                                }, U, G);
                                return
                            }
                            if (B.convertToBlob) {
                                V(B.convertToBlob({
                                    type: U,
                                    quality: G
                                }));
                                return
                            }
                            for (var j = atob(B.toDataURL(U, G).split(",")[1]), ne = j.length, F = new Uint8Array(ne), Y = 0; Y < ne; Y++) F[Y] = j.charCodeAt(Y);
                            V(new Blob([F], {
                                type: U
                            }))
                        })
                    }, le.prototype.debug = function() {}, i.exports = le
                }, {
                    "./lib/mathlib": 1,
                    "./lib/pool": 13,
                    "./lib/stepper": 14,
                    "./lib/tiler": 15,
                    "./lib/utils": 16,
                    "./lib/worker": 17,
                    "object-assign": 23,
                    webworkify: 24
                }]
            }, {}, [])("/index.js")
        })
    });
    var mC = {};
    ud(mC, {
        Application: () => qv
    });
    var Ge = W(J()),
        kc = {
            type: "change"
        },
        Gx = {
            type: "changeZoom"
        },
        tl = {
            type: "start"
        },
        Uc = {
            type: "end"
        },
        dd = navigator.platform.toUpperCase().indexOf("MAC") >= 0,
        jc = class extends Ge.EventDispatcher {
            constructor(e, t) {
                super();
                t === void 0 && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = e, this.domElement = t, this.enabled = !0, this.useKeyEvents = !0, this.target = new Ge.Vector3, this.object.getTarget(this.target), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0 + 1 * Ge.MathUtils.DEG2RAD, this.maxPolarAngle = Math.PI - 1 * Ge.MathUtils.DEG2RAD, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .1, this.enableZoom = !0, this.zoomSpeed = 2, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.autoRotateClockwise = !0, this.keys = {
                    LEFT: "ArrowLeft",
                    UP: "ArrowUp",
                    RIGHT: "ArrowRight",
                    BOTTOM: "ArrowDown"
                }, this.mouseButtons = {
                    LEFT: Ge.MOUSE.ROTATE,
                    MIDDLE: Ge.MOUSE.DOLLY,
                    RIGHT: Ge.MOUSE.PAN
                }, this.touches = {
                    ONE: Ge.TOUCH.ROTATE,
                    TWO: Ge.TOUCH.DOLLY_PAN
                }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function() {
                    return m.phi
                }, this.getAzimuthalAngle = function() {
                    return m.theta
                }, this.saveState = function() {
                    a.target0.copy(a.target), a.position0.copy(a.object.position), a.zoom0 = a.object.zoom
                }, this.reset = function() {
                    a.target.copy(a.target0), a.object.position.copy(a.position0), a.object.zoom = a.zoom0, r = 0, a.object.updateProjectionMatrix(), a.dispatchEvent(kc), a.update(), f = c.NONE
                }, this.update = function() {
                    let P = new Ge.Vector3,
                        Je = new Ge.Quaternion().setFromUnitVectors(e.up, new Ge.Vector3(0, 1, 0)),
                        wt = Je.clone().invert(),
                        tt = new Ge.Vector3,
                        Zt = new Ge.Quaternion,
                        vi = 2 * Math.PI;
                    return function() {
                        let Ra = a.object.position;
                        P.copy(Ra).sub(a.target), P.applyQuaternion(Je), m.setFromVector3(P), a.autoRotate && f === c.NONE && (a.autoRotateClockwise === !0 ? te(k()) : Z(k())), a.rotationLimitsMode !== a.rotationLimitsOptions.HORIZONTAL && (m.phi += v.phi), (a.rotationLimitsMode !== a.rotationLimitsOptions.VERTICAL || a.autoRotate === !0) && (m.theta += v.theta), (a.rotationLimitsMode === a.rotationLimitsOptions.VERTICAL || a.rotationLimitsMode === a.rotationLimitsOptions.BOTH) && (m.phi = Math.max(i, Math.min(s, m.phi))), (a.rotationLimitsMode === a.rotationLimitsOptions.HORIZONTAL || a.rotationLimitsMode === a.rotationLimitsOptions.BOTH) && (r += v.theta, r > a.rotationHorizontalOffset.max ? (m.theta = l, r = a.rotationHorizontalOffset.max) : r < -a.rotationHorizontalOffset.min && (m.theta = o, r = -a.rotationHorizontalOffset.min));
                        let Xr = a.minAzimuthAngle,
                            qr = a.maxAzimuthAngle;
                        return isFinite(Xr) && isFinite(qr) && (Xr < -Math.PI ? Xr += vi : Xr > Math.PI && (Xr -= vi), qr < -Math.PI ? qr += vi : qr > Math.PI && (qr -= vi), Xr <= qr ? m.theta = Math.max(Xr, Math.min(qr, m.theta)) : m.theta = m.theta > (Xr + qr) / 2 ? Math.max(Xr, m.theta) : Math.min(qr, m.theta)), m.phi = Math.max(a.minPolarAngle, Math.min(a.maxPolarAngle, m.phi)), m.makeSafe(), m.radius *= g, m.radius = Math.max(a.minDistance, Math.min(a.maxDistance, m.radius)), a.target.add(y), P.setFromSpherical(m), P.applyQuaternion(wt), Ra.copy(a.target).add(P), a.object.lookAt(a.target), a.enableDamping === !0 ? (v.theta *= 1 - a.dampingFactor, v.phi *= 1 - a.dampingFactor) : v.set(0, 0, 0), y.set(0, 0, 0), g = 1, A || tt.distanceToSquared(a.object.position) > h || 8 * (1 - Zt.dot(a.object.quaternion)) > h ? (a.dispatchEvent(kc), A && a.dispatchEvent(Gx), tt.copy(a.object.position), Zt.copy(a.object.quaternion), A = !1, !0) : !1
                    }
                }(), this.dispose = function() {
                    a.domElement.removeEventListener("contextmenu", mr), a.domElement.removeEventListener("pointerdown", dr), a.domElement.removeEventListener("wheel", ho), a.domElement.removeEventListener("touchstart", hr), a.domElement.removeEventListener("touchend", mo), a.domElement.removeEventListener("touchmove", Oa), a.domElement.ownerDocument.removeEventListener("pointermove", zt), a.domElement.ownerDocument.removeEventListener("pointerup", gi), a.domElement.removeEventListener("gesturestart", se), a.domElement.removeEventListener("gesturechange", se), a.domElement.removeEventListener("gestureend", se), window.removeEventListener("keydown", ns, !1), window.removeEventListener("keyup", Sn, !1)
                }, this.zoomOut = function() {
                    V(Q())
                }, this.zoomIn = function() {
                    j(Q())
                }, this.setEnableDampingSpeed = function(P) {
                    this.enableDamping = P, this.rotateSpeed = P === !0 ? .2 : 1
                }, this.resetTo = function(P, Je, wt) {
                    a.target.copy(P), a.object.position.copy(Je), a.object.zoom = wt, a.object.updateProjectionMatrix(), a.dispatchEvent(kc), a.update(), f = c.NONE
                }, this.updateTarget = function() {
                    this.object.getTarget(this.target), this.update()
                };
                let r, i, s, o, l;
                this.rotationVerticalOffset = {
                    min: Math.PI * .5,
                    max: Math.PI * .5
                }, this.rotationHorizontalOffset = {
                    min: Math.PI * .5,
                    max: Math.PI * .5
                }, this.rotationLimitsOptions = {
                    DEFAULT: 0,
                    VERTICAL: 1,
                    HORIZONTAL: 2,
                    BOTH: 3
                }, this.rotationLimitsMode = this.rotationLimitsOptions.DEFAULT, this.updateRotationOffetLimits = function() {
                    r = 0, i = rl(m.phi - a.rotationVerticalOffset.min), s = rl(m.phi + a.rotationVerticalOffset.max), i < 0 && (i = a.minPolarAngle), s < 0 && (s = a.maxPolarAngle), o = rl(m.theta - a.rotationHorizontalOffset.min), l = rl(m.theta + a.rotationHorizontalOffset.max)
                }, this.toJSON = function() {
                    let P = {};
                    return a.useKeyEvents && (P.useKeyEvents = !0), a.enableDamping && (P.enableDamping = !0), a.enablePan && (P.enablePan = !0), a.enableZoom && (P.enableZoom = !0), a.enableRotate && (P.enableRotate = !0), P.rotationLimitsMode = a.rotationLimitsMode, (a.rotationLimitsMode === a.rotationLimitsOptions.VERTICAL || a.rotationLimitsMode === a.rotationLimitsOptions.BOTH) && (P.rotationVerticalOffset = {
                        min: a.rotationVerticalOffset.min,
                        max: a.rotationVerticalOffset.max
                    }), (a.rotationLimitsMode === a.rotationLimitsOptions.HORIZONTAL || a.rotationLimitsMode === a.rotationLimitsOptions.BOTH) && (P.rotationHorizontalOffset = {
                        min: a.rotationHorizontalOffset.min,
                        max: a.rotationHorizontalOffset.max
                    }), a.autoRotate && (P.autoRotate = !0, P.autoRotateSpeed = a.autoRotateSpeed, a.autoRotateClockwise && (P.autoRotateClockwise = !0)), P
                }, this.fromJSON = function(P) {
                    a.useKeyEvents = P.useKeyEvents === !0, a.setEnableDampingSpeed(P.enableDamping === !0), a.enablePan = P.enablePan === !0, a.enableZoom = P.enableZoom === !0, a.enableRotate = P.enableRotate === !0, P.rotationLimitsMode !== void 0 && (a.rotationLimitsMode = P.rotationLimitsMode), P.rotationVerticalOffset && (a.rotationVerticalOffset = {
                        min: P.rotationVerticalOffset.min,
                        max: P.rotationVerticalOffset.max
                    }), P.rotationHorizontalOffset && (a.rotationHorizontalOffset = {
                        min: P.rotationHorizontalOffset.min,
                        max: P.rotationHorizontalOffset.max
                    }), a.autoRotate = P.autoRotate === !0, P.autoRotateSpeed && (a.autoRotateSpeed = P.autoRotateSpeed), a.autoRotateClockwise = P.autoRotateClockwise === !0, a.updateRotationOffetLimits()
                };
                let a = this,
                    c = {
                        NONE: -1,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2,
                        TOUCH_ROTATE: 3,
                        TOUCH_PAN: 4,
                        TOUCH_DOLLY_PAN: 5,
                        TOUCH_DOLLY_ROTATE: 6
                    },
                    f = c.NONE,
                    h = 1e-6,
                    m = new Ge.Spherical,
                    v = new Ge.Spherical,
                    g = 1,
                    y = new Ge.Vector3,
                    A = !1,
                    w = new Ge.Vector2,
                    C = new Ge.Vector2,
                    S = new Ge.Vector2,
                    E = new Ge.Vector2,
                    M = new Ge.Vector2,
                    L = new Ge.Vector2,
                    I = new Ge.Vector2,
                    z = new Ge.Vector2,
                    O = new Ge.Vector2,
                    X = {};

                function k() {
                    return 2 * Math.PI / 60 / 60 * a.autoRotateSpeed
                }

                function Q() {
                    return Math.pow(.95, a.zoomSpeed)
                }

                function te(P) {
                    v.theta -= P
                }

                function Z(P) {
                    v.theta += P
                }

                function le(P) {
                    v.phi -= P
                }
                let B = function() {
                        let P = new Ge.Vector3;
                        return function(wt, tt) {
                            P.setFromMatrixColumn(tt, 0), P.multiplyScalar(-wt), y.add(P)
                        }
                    }(),
                    U = function() {
                        let P = new Ge.Vector3;
                        return function(wt, tt) {
                            a.screenSpacePanning === !0 ? P.setFromMatrixColumn(tt, 1) : (P.setFromMatrixColumn(tt, 0), P.crossVectors(a.object.up, P)), P.multiplyScalar(wt), y.add(P)
                        }
                    }(),
                    G = function() {
                        let P = new Ge.Vector3;
                        return function(wt, tt) {
                            let Zt = a.domElement;
                            if (a.object.isPerspectiveCamera) {
                                let vi = a.object.position;
                                P.copy(vi).sub(a.target);
                                let ss = P.length();
                                ss *= Math.tan(a.object.fov / 2 * Math.PI / 180), B(2 * wt * ss / Zt.clientHeight, a.object.matrix), U(2 * tt * ss / Zt.clientHeight, a.object.matrix)
                            } else a.object.isOrthographicCamera ? (B(wt * (a.object.right - a.object.left) / a.object.zoom / Zt.clientWidth, a.object.matrix), U(tt * (a.object.top - a.object.bottom) / a.object.zoom / Zt.clientHeight, a.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), a.enablePan = !1)
                        }
                    }();

                function V(P) {
                    a.object.isPerspectiveCamera ? g /= P : a.object.isOrthographicCamera ? (a.object.zoom = Math.max(a.minZoom, Math.min(a.maxZoom, a.object.zoom * P)), a.object.updateProjectionMatrix(), A = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), a.enableZoom = !1)
                }

                function j(P) {
                    a.object.isPerspectiveCamera ? g *= P : a.object.isOrthographicCamera ? (a.object.zoom = Math.max(a.minZoom, Math.min(a.maxZoom, a.object.zoom / P)), a.object.updateProjectionMatrix(), A = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), a.enableZoom = !1)
                }

                function ne(P) {
                    w.set(P.clientX, P.clientY)
                }

                function F(P) {
                    I.set(P.clientX, P.clientY)
                }

                function Y(P) {
                    E.set(P.clientX, P.clientY)
                }

                function $(P) {
                    C.set(P.clientX, P.clientY), S.subVectors(C, w).multiplyScalar(a.rotateSpeed);
                    let Je = a.domElement;
                    te(2 * Math.PI * S.x / Je.clientHeight), le(2 * Math.PI * S.y / Je.clientHeight), w.copy(C), a.update()
                }

                function re(P) {
                    z.set(P.clientX, P.clientY), O.subVectors(z, I), O.y > 0 ? V(Q()) : O.y < 0 && j(Q()), I.copy(z), a.update()
                }

                function fe(P) {
                    M.set(P.clientX, P.clientY), L.subVectors(M, E).multiplyScalar(a.panSpeed), G(L.x, L.y), E.copy(M), a.update()
                }

                function ye() {}
                let Se = 0;

                function se(P) {
                    if (P.preventDefault(), P.type === "gesturechange") {
                        if (a.enableZoom === !1) return;
                        P.scale > Se ? j(Q()) : P.scale < Se && V(Q()), Se = P.scale
                    }
                }
                let ie = !1,
                    oe, he;

                function pe(P) {
                    return P.wheelDeltaY ? P.wheelDeltaY === -3 * P.deltaY : P.deltaMode === 0
                }

                function q(P) {
                    if (!ie) ie = !0, he = pe(P);
                    else {
                        if (he === !1 || (dd ? P.metaKey : P.ctrlKey)) {
                            if (a.enableZoom === !1) return;
                            P.deltaY < 0 ? j(Q()) : P.deltaY > 0 && V(Q())
                        } else {
                            if (a.enablePan === !1) return;
                            L.set(-P.deltaX, -P.deltaY).multiplyScalar(a.panSpeed), P.altKey ? G(0, L.y) : P.shiftKey ? G(L.x, 0) : G(L.x, L.y)
                        }
                        a.update()
                    }
                    oe && window.clearTimeout(oe), oe = window.setTimeout(() => {
                        ie = !1, he = void 0
                    }, 200)
                }

                function Ae(P) {
                    let Je = !1;
                    switch (P.code) {
                        case a.keys.UP:
                            G(0, a.keyPanSpeed), Je = !0;
                            break;
                        case a.keys.BOTTOM:
                            G(0, -a.keyPanSpeed), Je = !0;
                            break;
                        case a.keys.LEFT:
                            G(a.keyPanSpeed, 0), Je = !0;
                            break;
                        case a.keys.RIGHT:
                            G(-a.keyPanSpeed, 0), Je = !0;
                            break
                    }
                    Je && (P.preventDefault(), a.update())
                }

                function ke(P) {
                    if (P.touches.length == 1) w.set(P.touches[0].pageX, P.touches[0].pageY);
                    else {
                        let Je = .5 * (P.touches[0].pageX + P.touches[1].pageX),
                            wt = .5 * (P.touches[0].pageY + P.touches[1].pageY);
                        w.set(Je, wt)
                    }
                }

                function Ce(P) {
                    if (P.touches.length == 1) E.set(P.touches[0].pageX, P.touches[0].pageY);
                    else {
                        let Je = .5 * (P.touches[0].pageX + P.touches[1].pageX),
                            wt = .5 * (P.touches[0].pageY + P.touches[1].pageY);
                        E.set(Je, wt)
                    }
                }

                function Te(P) {
                    let Je = P.touches[0].pageX - P.touches[1].pageX,
                        wt = P.touches[0].pageY - P.touches[1].pageY,
                        tt = Math.sqrt(Je * Je + wt * wt);
                    I.set(0, tt)
                }

                function Fe(P) {
                    a.enableZoom && Te(P), a.enablePan && Ce(P)
                }

                function nt(P) {
                    a.enableZoom && Te(P), a.enableRotate && ke(P)
                }

                function De(P) {
                    if (P.touches.length == 1) C.set(P.touches[0].pageX, P.touches[0].pageY);
                    else {
                        let wt = .5 * (P.touches[0].pageX + P.touches[1].pageX),
                            tt = .5 * (P.touches[0].pageY + P.touches[1].pageY);
                        C.set(wt, tt)
                    }
                    S.subVectors(C, w).multiplyScalar(a.rotateSpeed);
                    let Je = a.domElement;
                    te(2 * Math.PI * S.x / Je.clientHeight), le(2 * Math.PI * S.y / Je.clientHeight), w.copy(C)
                }

                function bt(P) {
                    if (P.touches.length == 1) M.set(P.touches[0].pageX, P.touches[0].pageY);
                    else {
                        let Je = .5 * (P.touches[0].pageX + P.touches[1].pageX),
                            wt = .5 * (P.touches[0].pageY + P.touches[1].pageY);
                        M.set(Je, wt)
                    }
                    L.subVectors(M, E).multiplyScalar(a.panSpeed), G(L.x, L.y), E.copy(M)
                }

                function Mt(P) {
                    let Je = P.touches[0].pageX - P.touches[1].pageX,
                        wt = P.touches[0].pageY - P.touches[1].pageY,
                        tt = Math.sqrt(Je * Je + wt * wt);
                    z.set(0, tt), O.set(0, Math.pow(z.y / I.y, a.zoomSpeed)), V(O.y), I.copy(z)
                }

                function xt(P) {
                    a.enableZoom && Mt(P), a.enablePan && bt(P)
                }

                function tr(P) {
                    a.enableZoom && Mt(P), a.enableRotate && De(P)
                }

                function rr() {}

                function dr(P) {
                    if (a.enabled !== !1) switch (P.pointerType) {
                        case "mouse":
                        case "pen":
                            a.useKeyEvents === !1 ? is(P) : Kr(P);
                            break
                    }
                }

                function zt(P) {
                    if (a.enabled !== !1) switch (P.pointerType) {
                        case "mouse":
                        case "pen":
                            wn(P);
                            break
                    }
                }

                function gi(P) {
                    switch (P.pointerType) {
                        case "mouse":
                        case "pen":
                            en(P);
                            break
                    }
                    a.domElement.ownerDocument.removeEventListener("pointermove", zt), a.domElement.ownerDocument.removeEventListener("pointerup", gi)
                }

                function is(P) {
                    P.preventDefault(), a.domElement.focus ? a.domElement.focus() : window.focus();
                    let Je;
                    switch (P.button) {
                        case 0:
                            Je = a.mouseButtons.LEFT;
                            break;
                        case 1:
                            Je = a.mouseButtons.MIDDLE;
                            break;
                        case 2:
                            Je = a.mouseButtons.RIGHT;
                            break;
                        default:
                            Je = -1
                    }
                    switch (Je) {
                        case Ge.MOUSE.DOLLY:
                            if (a.enablePan === !1) return;
                            Y(P), f = c.PAN;
                            break;
                        case Ge.MOUSE.ROTATE:
                            if (P.ctrlKey || P.metaKey || P.shiftKey) {
                                if (a.enablePan === !1) return;
                                Y(P), f = c.PAN
                            } else {
                                if (a.enableRotate === !1) return;
                                ne(P), f = c.ROTATE
                            }
                            break;
                        case Ge.MOUSE.PAN:
                            if (P.ctrlKey || P.metaKey || P.shiftKey) {
                                if (a.enableRotate === !1) return;
                                ne(P), f = c.ROTATE
                            } else {
                                if (a.enablePan === !1) return;
                                Y(P), f = c.PAN
                            }
                            break;
                        default:
                            f = c.NONE
                    }
                    f !== c.NONE && (a.domElement.ownerDocument.addEventListener("pointermove", zt), a.domElement.ownerDocument.addEventListener("pointerup", gi), a.dispatchEvent(tl))
                }

                function Kr(P) {
                    if (!(a.enabled === !1 || a.object.enableableVectorControls === !0 || a.object.enableableTransformControls === !0 || a.object.enableableResizeControls === "Vertex" || a.object.enableableResizeControls === "Face" || a.object.enableableResizeControls === "Edge" || a.object.enableableScaleControls === "Vertex" || a.object.enableableScaleControls === "Face" || a.object.enableableScaleControls === "Edge")) {
                        switch (P.preventDefault(), a.domElement.focus ? a.domElement.focus() : window.focus(), P.button) {
                            case a.mouseButtons.MIDDLE:
                                if (a.enablePan === !1) return;
                                Y(P), f = c.PAN;
                                break;
                            case a.mouseButtons.LEFT:
                                if (P.altKey === !0 && !P.shiftKey && !(dd ? P.metaKey : P.ctrlKey)) {
                                    if (a.enableRotate === !1) return;
                                    ne(P), f = c.ROTATE
                                } else if (X.code === "Space") {
                                    if (a.enablePan === !1) return;
                                    Y(P), f = c.PAN
                                }
                                break;
                            default:
                                f = c.NONE
                        }
                        f !== c.NONE && (a.domElement.ownerDocument.addEventListener("pointermove", zt), a.domElement.ownerDocument.addEventListener("pointerup", gi), a.dispatchEvent(tl))
                    }
                }

                function wn(P) {
                    if (a.enabled !== !1) switch (P.preventDefault(), f) {
                        case c.ROTATE:
                            if (a.enableRotate === !1) return;
                            $(P);
                            break;
                        case c.DOLLY:
                            if (a.enableZoom === !1) return;
                            re(P);
                            break;
                        case c.PAN:
                            if (a.enablePan === !1) return;
                            fe(P);
                            break
                    }
                }

                function en(P) {
                    a.enabled !== !1 && (ye(P), a.dispatchEvent(Uc), f = c.NONE)
                }

                function ho(P) {
                    a.enabled === !1 || a.enableZoom === !1 || f !== c.NONE && f !== c.ROTATE || (P.preventDefault(), a.dispatchEvent(tl), q(P), a.dispatchEvent(Uc))
                }

                function ns(P) {
                    a.enabled !== !1 && (X = P)
                }

                function Sn() {
                    a.enabled !== !1 && (X = {}, f !== c.NONE && en(new PointerEvent("pointerover")))
                }

                function hr(P) {
                    if (a.enabled !== !1) {
                        switch (P.preventDefault(), P.touches.length) {
                            case 1:
                                switch (a.touches.ONE) {
                                    case Ge.TOUCH.ROTATE:
                                        if (a.enableRotate === !1) return;
                                        ke(P), f = c.TOUCH_ROTATE;
                                        break;
                                    case Ge.TOUCH.PAN:
                                        if (a.enablePan === !1) return;
                                        Ce(P), f = c.TOUCH_PAN;
                                        break;
                                    default:
                                        f = c.NONE
                                }
                                break;
                            case 2:
                                switch (a.touches.TWO) {
                                    case Ge.TOUCH.DOLLY_PAN:
                                        if (a.enableZoom === !1 && a.enablePan === !1) return;
                                        Fe(P), f = c.TOUCH_DOLLY_PAN;
                                        break;
                                    case Ge.TOUCH.DOLLY_ROTATE:
                                        if (a.enableZoom === !1 && a.enableRotate === !1) return;
                                        nt(P), f = c.TOUCH_DOLLY_ROTATE;
                                        break;
                                    default:
                                        f = c.NONE
                                }
                                break;
                            default:
                                f = c.NONE
                        }
                        f !== c.NONE && a.dispatchEvent(tl)
                    }
                }

                function Oa(P) {
                    if (a.enabled !== !1) switch (P.preventDefault(), f) {
                        case c.TOUCH_ROTATE:
                            if (a.enableRotate === !1) return;
                            De(P), a.update();
                            break;
                        case c.TOUCH_PAN:
                            if (a.enablePan === !1) return;
                            bt(P), a.update();
                            break;
                        case c.TOUCH_DOLLY_PAN:
                            if (a.enableZoom === !1 && a.enablePan === !1) return;
                            xt(P), a.update();
                            break;
                        case c.TOUCH_DOLLY_ROTATE:
                            if (a.enableZoom === !1 && a.enableRotate === !1) return;
                            tr(P), a.update();
                            break;
                        default:
                            f = c.NONE
                    }
                }

                function mo(P) {
                    a.enabled !== !1 && (rr(P), a.dispatchEvent(Uc), f = c.NONE)
                }

                function mr(P) {
                    a.enabled !== !1 && P.preventDefault()
                }
                a.domElement.addEventListener("contextmenu", mr), a.domElement.addEventListener("pointerdown", dr), a.domElement.addEventListener("wheel", ho, {
                    passive: !1
                }), a.domElement.addEventListener("touchstart", hr, {
                    passive: !1
                }), a.domElement.addEventListener("touchend", mo), a.domElement.addEventListener("touchmove", Oa, {
                    passive: !1
                }), a.domElement.addEventListener("gesturestart", se), a.domElement.addEventListener("gesturechange", se), a.domElement.addEventListener("gestureend", se), window.addEventListener("keydown", ns, !1), window.addEventListener("keyup", Sn, !1), this.update(), this.updateRotationOffetLimits(), this.setEnableDampingSpeed(!0)
            }
        };

    function rl(n) {
        let e = Math.PI * 2;
        for (; n <= -Math.PI;) n += e;
        for (; n > Math.PI;) n -= e;
        return n
    }
    var pr = W(J()),
        Vc = class extends pr.Raycaster {
            setFromCamera(e, t) {
                t.cameraType === "OrthographicCamera" ? (this.ray.origin.set(e.x, e.y, -1).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : t.cameraType === "PerspectiveCamera" ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : console.error("Raycaster: Unsupported camera type.")
            }
            createRaycastLineHelper() {
                let e = new pr.LineBasicMaterial({
                        color: 16711680,
                        linewidth: 10
                    }),
                    t = new pr.Vector3(this.ray.origin.x, this.ray.origin.y, this.ray.origin.z),
                    r = new pr.Vector3(this.ray.direction.x, this.ray.direction.y, this.ray.direction.z),
                    i = new pr.Vector3().lerpVectors(t, r, .5);
                r.multiplyScalar(0);
                let s = new pr.BufferGeometry;
                return s.setAttribute("position", new pr.BufferAttribute([t.x, t.y, t.z, i.x, i.y, i.z, r.x, r.y, r.z], 3)), new pr.Line(s, e)
            }
        };
    var hd = W(J()),
        md = n => class {
            constructor(t = hd.DefaultLoadingManager) {
                this.manager = t;
                this.loader = new n(t)
            }
        };
    var wm = W(J()),
        fA = W(gd());
    var at = W(J());
    var xd = W(J());
    var Wc = W(J());
    var vd = W(J()),
        we = class {
            constructor(e) {
                this.hashProperties = void 0;
                this.isNode = !0;
                this.shortcuts = {};
                this.uuid = vd.MathUtils.generateUUID(), this.type = e, this.name = "", this.userData = {}
            }
            analyze(e, t) {
                t = t ?? {}, e.analyzing = !0, this.build(e.addFlow(t.slot, t.cache, t.context), "v4"), e.clearVertexNodeCode(), e.clearFragmentNodeCode(), e.removeFlow(), e.analyzing = !1
            }
            analyzeAndFlow(e, t, r) {
                return r = r ?? {}, this.analyze(e, r), this.flow(e, t, r)
            }
            flow(e, t, r) {
                r = r ?? {}, e.addFlow(r.slot, r.cache, r.context);
                let i = {
                    result: this.build(e, t),
                    code: e.clearNodeCode(),
                    extra: e.context.extra
                };
                return e.removeFlow(), i
            }
            build(e, t, r) {
                t = t ?? this.getType(e, t);
                let i = e.getNodeData(r ?? this);
                return e.analyzing && this.appendDepsNode(e, i, t), e.nodes.indexOf(this) === -1 && e.nodes.push(this), this.updateFrame !== void 0 && e.updaters.indexOf(this) === -1 && e.updaters.push(this), this.generate(e, t, r)
            }
            updateFrame(e) {}
            generateReadonly(e, t, r, i, s, o) {
                return ""
            }
            generate(e, t, r, i, s) {
                return ""
            }
            parse(e, t, r, i) {}
            appendDepsNode(e, t, r) {
                t.deps = (t.deps || 0) + 1;
                let i = e.getTypeLength(r);
                (i > (t.outputMax || 0) || this.getType(e, r)) && (t.outputMax = i, t.output = r)
            }
            setName(e) {
                this.name = e
            }
            getName() {
                return this.name
            }
            getType(e, t) {
                return t === "sampler2D" || t === "samplerCube" ? t : this.type
            }
            getJSONNode(e) {
                if (e?.materials && e?.materials[this.uuid] !== void 0) return e.materials[this.uuid]
            }
            getHash() {
                let e = "{",
                    t, r;
                for (t in this) r = this[t], r instanceof we && (e += '"' + t + '":' + r.getHash() + ",");
                if (this.hashProperties)
                    for (let i = 0; i < this.hashProperties.length; i++) t = this.hashProperties[i], r = this[t], e += '"' + t + '":"' + String(r) + '",';
                return e += '"id":"' + this.uuid + '"}', e
            }
            copy(e) {
                return this.name = e.name, e.type && (this.type = e.type), e.frameId && (this.frameId = e.frameId), e.hashProperties && (this.hashProperties = e.hashProperties.map(t => t)), this.userData = JSON.parse(JSON.stringify(e.userData)), this.shortcuts = JSON.parse(JSON.stringify(e.shortcuts)), this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            createJSONNode(e) {
                let t = e === void 0 || typeof e == "string";
                if (typeof this.type != "string") throw new Error("Node does not allow serialization.");
                let r = {};
                return r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), !t && e && (e.nodes[this.uuid] = r), r
            }
            toJSON(e) {
                return this.getJSONNode(e) ?? this.createJSONNode(e)
            }
            fromJSON(e, t) {
                return this.uuid = e.uuid, this.type = e.type, e.name && (this.name = e.name), e.userData && (this.userData = e.userData), this
            }
        };
    var yd = W(J()),
        _e = class extends we {
            constructor(e, t) {
                super(e);
                this.scope = "";
                t = t ?? {}, this.shared = t.shared !== void 0 ? t.shared : !0, this.unique = t.unique !== void 0 ? t.unique : !1
            }
            build(e, t, r, i) {
                if (t = t ?? this.getType(e), this.getShared(e, t)) {
                    let s = this.getUnique(e, t);
                    s && this.uuid === void 0 && (this.uuid = yd.MathUtils.generateUUID()), r = e.getUUID(r ?? this.getUUID(), !s);
                    let o = e.getNodeData(r),
                        l = o.output || this.getType(e);
                    if (e.analyzing) return (o.deps || 0) > 0 || this.getLabel() ? (this.appendDepsNode(e, o, t), this.generate(e, t, r)) : super.build(e, t, r);
                    if (s) return o.name = o.name || super.build(e, t, r), o.name;
                    if (!this.getLabel() && (!this.getShared(e, l) || e.context.ignoreCache || o.deps === 1)) return super.build(e, t, r);
                    r = this.getUUID(!1);
                    let a = this.getTemp(e, r);
                    if (a) return e.format(a, l, t); {
                        a = super.generate(e, t, r, o.output, i);
                        let c = this.generate(e, l, r);
                        return e.addNodeCode(a + " = " + c + ";"), e.format(a, l, t)
                    }
                }
                return super.build(e, t, r)
            }
            getShared(e, t) {
                return t !== "sampler2D" && t !== "samplerCube" && this.shared
            }
            getUnique(e, t) {
                return this.unique
            }
            setLabel(e) {
                return this.label = e, this
            }
            getLabel() {
                return this.label
            }
            getUUID(e) {
                let t = this.uuid;
                return typeof this.scope == "string" && (t = this.scope + "-" + t), t
            }
            getTemp(e, t) {
                t = t || this.uuid;
                let r = e.getVars()[t];
                return r ? r.name : void 0
            }
            generate(e, t, r, i, s) {
                return this.getShared(e, t) || console.error("TempNode is not shared"), r = r ?? this.uuid, e.getTempVar(r, i ?? this.getType(e), s, this.getLabel()).name
            }
        };
    var At = class extends _e {
        constructor(e, t) {
            t = t ?? {}, t.shared = t.shared !== void 0 ? t.shared : !1;
            super(e, t);
            this.readonly = !1
        }
        setReadonly(e) {
            return this.readonly = e, this.hashProperties = this.readonly ? ["value"] : void 0, this
        }
        getReadonly() {
            return this.readonly
        }
        createJSONNode(e) {
            let t = super.createJSONNode(e);
            return this.readonly === !0 && (t.readonly = this.readonly), t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.readonly !== void 0 && this.setReadonly(e.readonly), this
        }
        generate(e, t, r, i, s, o) {
            r = e.getUUID(r ?? this.getUUID()), i = i ?? this.getType(e);
            let l = e.getNodeData(r);
            return this.getReadonly() && this.generateReadonly !== void 0 ? this.generateReadonly(e, t, r, i, s, o) : e.isShader("vertex") ? (l.vertex || (l.vertex = e.createVertexUniform(i, this, s, o, this.getLabel())), e.format(l.vertex.name, i, t)) : (l.fragment || (l.fragment = e.createFragmentUniform(i, this, s, o, this.getLabel())), e.format(l.fragment.name, i, t))
        }
        copy(e) {
            return super.copy(e), this.readonly = e.readonly, this
        }
    };
    var gr = class extends At {
        constructor(e = 0, t, r) {
            super("v3");
            this.nodeType = "Vector3";
            this.value = e instanceof Wc.Vector3 ? e : new Wc.Vector3(e, t, r)
        }
        get x() {
            return this.value.x
        }
        set x(e) {
            this.value.x = e
        }
        get y() {
            return this.value.y
        }
        set y(e) {
            this.value.y = e
        }
        get z() {
            return this.value.z
        }
        set z(e) {
            this.value.z = e
        }
        generateReadonly(e, t, r, i, s, o) {
            return e.format("vec3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")", i, t)
        }
        copy(e) {
            return super.copy(e), this.value.copy(e.value), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.x = this.value.x, t.y = this.value.y, t.z = this.value.z, this.getReadonly() === !0 && (t.readonly = !0)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.x && (this.value.x = e.x), e.y && (this.value.y = e.y), e.z && (this.value.z = e.z), this
        }
    };
    var Qe = class extends At {
        constructor(e) {
            super("i");
            this.nodeType = "Int";
            this.value = Math.floor(e ?? 0)
        }
        generateReadonly(e, t, r, i, s, o) {
            return e.format(this.value.toString(), i, t)
        }
        copy(e) {
            return super.copy(e), this.value = e.value, this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.value = this.value, this.getReadonly() === !0 && (t.readonly = !0)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.value && (this.value = e.value), this
        }
    };
    var pt;
    (function(g) {
        g.POSITION = "position", g.LIGHTING = "light", g.COLOR = "color", g.GRADIENT = "gradient", g.NORMAL = "normal", g.DEPTH = "depth", g.TEXTURE = "texture", g.NOISE = "noise", g.FRESNEL = "fresnel", g.RAINBOW = "rainbow", g.POINTS = "points", g.MATCAP = "matcap", g.LINES = "lines", g.DISPLACE = "displace"
    })(pt || (pt = {}));
    var Ct;
    (function(r) {
        r.POSITION = "position", r.LIGHTING = "light", r.COLOR = "color"
    })(Ct || (Ct = {}));
    var _t = class {
            constructor(e, t, r) {
                this.next = void 0;
                this.uniforms = {};
                this.textures = {};
                this.defines = {};
                this.backLayer = void 0;
                this.isBack = !1;
                if (this.id = e, t) {
                    this.type = t.type;
                    for (let i in t) i !== "type" && i !== "calpha" && (this.uniforms[`f${this.id}_${i}`] = t[i]);
                    for (let i in r) this.defines[i] = r[i]
                }
            }
            copy(e) {
                this.id = e.id, this.type = e.type, this.defines = Ne({}, e.defines);
                for (let t in e.uniforms) this.uniforms[t] ? this.uniforms[t].copy(e.uniforms[t]) : this.uniforms[t] = e.uniforms[t].clone();
                return this
            }
            clone() {
                return new _t(this.id).copy(this)
            }
            fromJSON(e, t) {
                this.id = e.id, this.defines = Ne({}, e.defines);
                for (let r in e.uniforms) this.uniforms[r] = t.getNode(e.uniforms[r]);
                if (e.type === pt.TEXTURE) {
                    if (!(`f${this.id}_textureSize` in this.uniforms)) {
                        let r = this.uniforms[`f${this.id}_texture`].value.image;
                        this.uniforms[`f${e.id}_textureSize`] = new gr(r.width, r.height)
                    }
                    `f${e.id}_axis` in this.uniforms || (this.uniforms[`f${e.id}_axis`] = new Qe(0)), `f${e.id}_projection` in this.uniforms || (this.uniforms[`f${e.id}_projection`] = new Qe(0))
                } else e.type === pt.NOISE && (`f${e.id}_noiseType` in this.uniforms || (this.uniforms[`f${e.id}_noiseType`] = new Qe(0)));
                return this
            }
            toJSON(e) {
                let t = {};
                for (let i in this.uniforms) t[i] = this.uniforms[i].toJSON(e).uuid;
                return {
                    id: this.id,
                    type: this.type,
                    defines: JSON.parse(JSON.stringify(this.defines)),
                    uniforms: t,
                    next: this.next == null ? void 0 : this.next.toJSON(e)
                }
            }
            copyUniforms(e) {
                for (let t in this.uniforms) {
                    let r = this.getName(t);
                    r !== void 0 && e.uniforms[`f${e.id}_${r}`] && this.uniforms[t].copy(e.uniforms[`f${e.id}_${r}`])
                }
                return this
            }
            hasValueByKey(e) {
                return this.uniforms[e] !== void 0
            }
            hasValue(e) {
                return this.hasValueByKey(`f${this.id}_${e}`)
            }
            setValue(e, t) {
                let r = `f${this.id}_${e}`;
                this.hasValueByKey(r) && t !== void 0 && (this.uniforms[r].value = t)
            }
            getValue(e) {
                let t = `f${this.id}_${e}`;
                if (this.hasValueByKey(t)) return this.uniforms[t].value
            }
            getValues() {
                let e = {
                    type: this.type
                };
                for (let t in this.uniforms) {
                    let r = this.getName(t);
                    if (r === void 0) continue;
                    let s = this.uniforms[`f${this.id}_${r}`].value;
                    s !== void 0 && (e[r] = s.clone ? s.clone() : s)
                }
                return e
            }
            getName(e) {
                let r = /f\d+_(.*)/.exec(e);
                if (r && r.length > 1) return r[1];
                console.log(`Layer.getName: error ${e}`)
            }
            getNames() {
                let e = [];
                for (let t in this.uniforms) {
                    let r = this.getName(t);
                    r && e.push(r)
                }
                return e
            }
            isEqual(e) {
                for (let t in e.uniforms) {
                    let r = e.getName(t);
                    if (!r) return !1;
                    let i = this.getValue(r),
                        s = e.uniforms[t].value;
                    if (s.value instanceof xd.Texture) {
                        if (i.image !== s.image) return !1
                    } else if (Array.isArray(s)) {
                        let o = i;
                        for (let l = 0, a = o.length; l < a; ++l)
                            if (o[l] !== s[l]) return !1
                    } else {
                        let o = i;
                        if (o.equals) {
                            if (!o.equals(s)) return !1
                        } else if (i !== s) return !1
                    }
                }
                return !0
            }
            dispose() {}
        },
        Jc = function(n, e) {
            let t = n.id,
                r = n.type;
            return new _t(t, {
                type: r
            }).fromJSON(n, e)
        };

    function il(n) {
        let e = n instanceof _t ? n.type : n;
        return e === "texture" || e === "displace_map" || e === "matcap"
    }
    var nl = W(J());
    var qe = class extends At {
        constructor(e = 0, t, r) {
            super("c");
            this.nodeType = "Color";
            this.value = e instanceof nl.Color ? e : new nl.Color(e || 0, t, r)
        }
        get r() {
            return this.value.r
        }
        set r(e) {
            this.value.r = e
        }
        get g() {
            return this.value.g
        }
        set g(e) {
            this.value.g = e
        }
        get b() {
            return this.value.b
        }
        set b(e) {
            this.value.b = e
        }
        generate(e, t, r, i, s, o) {
            r = e.getUUID(r ?? this.getUUID()), i = i ?? this.getType(e);
            let l = e.getNodeData(r),
                a = this.getReadonly() && this.generateReadonly !== void 0;
            if (this.alpha) {
                let c = this.alpha.build(e, "f");
                e.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${c};`)
            }
            return a ? this.generateReadonly(e, t, r, i, s, o) : e.isShader("vertex") ? (l.vertex || (l.vertex = e.createVertexUniform(i, this, s, o, this.getLabel())), e.format(l.vertex.name, i, t)) : (l.fragment || (l.fragment = e.createFragmentUniform(i, this, s, o, this.getLabel())), e.format(l.fragment.name, i, t))
        }
        generateReadonly(e, t, r, i, s, o) {
            return e.format("vec3(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ")", i, t)
        }
        copy(e) {
            return super.copy(e), this.value.copy(e.value), e.alpha ? this.alpha ? this.alpha.copy(e.alpha) : this.alpha = e.alpha.clone() : this.alpha = void 0, this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.r = this.value.r, t.g = this.value.g, t.b = this.value.b, t.value = this.value.getHex(), t.alpha = this.alpha?.toJSON(e), this.readonly === !0 && (t.readonly = !0)), t.nodeType = this.nodeType, this.alpha && (t.alpha = this.alpha.uuid), t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.value && (this.value = new nl.Color(e.value)), e.alpha && (this.alpha = t.getNode(e.alpha)), this
        }
    };
    var ve = class extends At {
        constructor(e) {
            super("f");
            this.nodeType = "Float";
            this.value = e ?? 0
        }
        generateReadonly(e, t, r, i, s, o) {
            return e.format(this.value + (this.value % 1 ? "" : ".0"), i, t)
        }
        copy(e) {
            return super.copy(e), this.value = e.value, this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.value = this.value, this.getReadonly() === !0 && (t.readonly = !0)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.value && (this.value = e.value), this
        }
    };
    var wo = class extends At {
        constructor(e) {
            super("b");
            this.nodeType = "Bool";
            this.value = e ?? !1
        }
        generateReadonly(e, t, r, i) {
            return e.format(this.value ? "true" : "false", i, t)
        }
        copy(e) {
            return super.copy(e), this.value = e.value, this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.value = this.value, this.getReadonly() === !0 && (t.readonly = !0)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.value && (this.value = e.value), this
        }
    };
    var Qc = W(J());
    var ei = class extends At {
        constructor(e = 0, t) {
            super("v2");
            this.nodeType = "Vector2";
            this.value = e instanceof Qc.Vector2 ? e : new Qc.Vector2(e, t)
        }
        get x() {
            return this.value.x
        }
        set x(e) {
            this.value.x = e
        }
        get y() {
            return this.value.y
        }
        set y(e) {
            this.value.y = e
        }
        generateReadonly(e, t, r, i, s, o) {
            return e.format("vec2(" + this.value.x + ", " + this.value.y + ")", i, t)
        }
        copy(e) {
            return super.copy(e), this.value.copy(e.value), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.x = this.value.x, t.y = this.value.y, this.getReadonly() === !0 && (t.readonly = !0)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.x && (this.value.x = e.x), e.y && (this.value.y = e.y), this
        }
    };
    var sl = W(J());
    var fs = class extends At {
        constructor(e = 1, t) {
            super("v4[]");
            this.nodeType = "Vector4Array";
            this.size = e, this.value = Array.isArray(t) ? t : t instanceof sl.Vector4 ? new Array(e).fill(t) : new Array(e).fill(new sl.Vector4(0))
        }
        copy(e) {
            return super.copy(e), this.value = e.value.map(t => t.clone()), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.value = this.value.map(r => ({
                x: r.x,
                y: r.y,
                z: r.z,
                w: r.w
            }))), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.value && (this.value = e.value.map(r => new sl.Vector4(r.x, r.y, r.z, r.w)), this.size = this.value.length), this
        }
    };
    var ds = class extends At {
        constructor(e = 1, t) {
            super("f[]");
            this.nodeType = "FloatArray";
            this.size = e, this.value = Array.isArray(t) ? t : typeof t == "number" ? new Array(e).fill(t) : new Array(e).fill(0)
        }
        copy(e) {
            return super.copy(e), this.size = e.size, this.value = [...e.value], this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.size = this.size, t.value = [...this.value]), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.value && (this.value = [...e.value]), e.size ? this.size = e.size : e.value && (this.size = this.value.length), this
        }
    };
    var Ad = class {
            constructor() {
                this.nodes = {};
                this.keywords = {}
            }
            add(e) {
                this.nodes[e.name] = e
            }
            addKeyword(e, t, r) {
                r = r !== void 0 ? r : !0, this.keywords[e] = {
                    callback: t,
                    cache: r
                }
            }
            remove(e) {
                delete this.nodes[e.name]
            }
            removeKeyword(e) {
                delete this.keywords[e]
            }
            get(e) {
                return this.nodes[e]
            }
            getKeyword(e, t) {
                return this.keywords[e].callback(t)
            }
            getKeywordData(e) {
                return this.keywords[e]
            }
            contains(e) {
                return this.nodes[e] !== void 0
            }
            containsKeyword(e) {
                return this.keywords[e] !== void 0
            }
        },
        Ut = new Ad;
    var Tn = class extends _e {
        constructor(e) {
            super("v2", {
                shared: !1
            });
            this.nodeType = "UV";
            this.index = e ?? 0
        }
        generate(e, t) {
            e.requires.uv[this.index] = !0;
            let r = this.index > 0 ? this.index + 1 : "",
                i = e.isShader("vertex") ? "uv" + r : "vUv" + r;
            return e.format(i, this.getType(e), t)
        }
        copy(e) {
            return super.copy(e), this.index = e.index, this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.index = this.index), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.index && (this.index = e.index), this
        }
    };
    Ut.addKeyword("uv", function() {
        return new Tn
    });
    Ut.addKeyword("uv2", function() {
        return new Tn(1)
    });
    var vr = W(J());
    var zx = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i,
        bd = /[a-z_0-9]+/gi,
        xe = class extends _e {
            constructor(e, t, r, i, s) {
                super(s);
                this.src = "";
                this.nodeType = "Function";
                this.useKeywords = !0;
                this.includes = [];
                this.extensions = {};
                this.keywords = {};
                this.isMethod = s === void 0, this.isInterface = !1, this.parse(e, t, r, i)
            }
            getShared(e, t) {
                return !this.isMethod
            }
            getType(e) {
                return e.getTypeByFormat(this.type)
            }
            getInputByName(e) {
                if (this.inputs) {
                    let t = this.inputs.length;
                    for (; t--;)
                        if (this.inputs[t].name === e) return this.inputs[t]
                }
            }
            getIncludeByName(e) {
                if (this.includes) {
                    let t = this.includes.length;
                    for (; t--;)
                        if (this.includes[t].name === e) return this.includes[t]
                }
            }
            generate(e, t, r, i, s) {
                let o, l = 0,
                    a = this.src;
                if (this.includes)
                    for (let f = 0; f < this.includes.length; f++) e.include(this.includes[f], this);
                for (let f in this.extensions) e.extensions[f] = !0;
                let c = [];
                for (; o = bd.exec(this.src);) c.push(o);
                for (let f = 0; f < c.length; f++) {
                    let h = c[f],
                        m = h[0],
                        v = this.isMethod ? !this.getInputByName(m) : !0,
                        g = m;
                    if (this.keywords[m] || this.useKeywords && v && Ut.containsKeyword(m)) {
                        let y = this.keywords[m];
                        if (!y) {
                            let A = Ut.getKeywordData(m);
                            A.cache && (y = e.keywords[m]), y = y || Ut.getKeyword(m, e), A.cache && (e.keywords[m] = y)
                        }
                        g = y.build(e)
                    }
                    m !== g && (a = a.substring(0, h.index + l) + g + a.substring(h.index + m.length + l), l += g.length - m.length), this.getIncludeByName(g) === void 0 && Ut.contains(g) && e.include(Ut.get(g))
                }
                return t === "source" ? a : this.isMethod ? (this.isInterface || e.include(this, void 0, a), this.name) : e.format("( " + a + " )", this.getType(e), t)
            }
            parse(e, t, r, i) {
                if (this.src = e || "", this.includes = t ?? [], this.extensions = r ?? {}, this.keywords = i ?? {}, this.isMethod) {
                    let s = zx.exec(this.src);
                    if (this.inputs = [], s && s.length == 4) {
                        this.type = s[1], this.name = s[2];
                        let o = s[3].match(bd);
                        if (o) {
                            let l = 0;
                            for (; l < o.length;) {
                                let a = o[l++],
                                    c;
                                a === "in" || a === "out" || a === "inout" ? c = o[l++] : (c = a, a = "");
                                let f = o[l++];
                                this.inputs.push({
                                    name: f,
                                    type: c,
                                    qualifier: a
                                })
                            }
                        }
                        this.isInterface = this.src.indexOf("{") === -1
                    } else this.type = "", this.name = ""
                }
            }
            copy(e) {
                return super.copy(e), this.isMethod = e.isMethod, this.useKeywords = e.useKeywords, e.type !== void 0 && (this.type = e.type), this.parse(e.src, e.includes, e.extensions, e.keywords), this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                if (!t) {
                    t = this.createJSONNode(e), t.src = this.src, t.isMethod = this.isMethod, t.useKeywords = this.useKeywords, this.isMethod || (t.type = this.type), t.extensions = JSON.parse(JSON.stringify(this.extensions));
                    let r = {};
                    for (let i in this.keywords) r[i] = this.keywords[i].toJSON(e).uuid;
                    if (t.keywords = r, this.includes?.length) {
                        let i = [];
                        for (let s = 0; s < this.includes.length; s++) i.push(this.includes[s].toJSON(e).uuid);
                        t.includes = i
                    }
                    t.isMethod = this.isMethod, t.inputs = this.inputs
                }
                return t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                if (super.fromJSON(e, t), e.inputs !== void 0 && (this.inputs = e.inputs), e.isMethod !== void 0 && (this.isMethod = e.isMethod), e.src && (this.src = e.src), e.isMethod && (this.isMethod = e.isMethod), e.useKeywords && (this.useKeywords = e.useKeywords), e.type && (this.type = e.type), e.extensions && (this.extensions = e.extensions), e.keywords && t) {
                    this.keywords = {};
                    for (let r in e.keywords) this.keywords[r] = t.getNode(e.keywords[r])
                }
                return e.includes && t && (this.includes = e.includes.map(r => t.getNode(r))), this
            }
        };
    var kx = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i,
        Yc = class extends _e {
            constructor(e = "", t) {
                super();
                this.src = "";
                this.useDefine = !1;
                this.nodeType = "Const";
                this.parse(e || Yc.PI, void 0, void 0, void 0, t)
            }
            getType(e) {
                return e.getTypeByFormat(this.type)
            }
            parse(e, t, r, i, s) {
                this.src = e || "";
                let o, l, a = "",
                    c = kx.exec(e);
                this.useDefine = s ?? this.src.charAt(0) === "#", c && c.length > 1 ? (l = c[1], o = c[2], a = c[3]) : (o = this.src, l = "f"), this.name = o, this.type = l, this.value = a
            }
            build(e, t) {
                if (t === "source") {
                    if (this.value) return this.useDefine ? "#define " + this.name + " " + this.value : "const " + this.type + " " + this.name + " = " + this.value + ";";
                    if (this.useDefine) return this.src
                }
                return e.include(this), e.format(this.name, this.getType(e), t)
            }
            generate(e, t, r, i, s) {
                return e.format(this.name, this.getType(e), t)
            }
            copy(e) {
                return super.copy(e), this.parse(e.src, void 0, void 0, void 0, e.useDefine), this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.src = this.src, t.useDefine = this.useDefine, t.value = this.value, t.name = this.name), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.src && (this.src = e.src), e.value && (this.value = e.value), e.name && (this.name = e.name), e.useDefine !== void 0 && (this.useDefine = e.useDefine), this
            }
        },
        Ve = Yc;
    Ve.PI = "PI", Ve.PI2 = "PI2", Ve.RECIPROCAL_PI = "RECIPROCAL_PI", Ve.RECIPROCAL_PI2 = "RECIPROCAL_PI2", Ve.LOG2 = "LOG2", Ve.EPSILON = "EPSILON";
    var Ye = class extends xe {
        constructor(e = "", t, r, i, s) {
            super(e, s, i, r, t);
            this.nodeType = "Expression"
        }
    };
    var En = class extends _e {
            constructor(e = new we, t) {
                super("v4");
                this.nodeType = "ColorSpace";
                this.factor = new we;
                this.input = e, this.method = t ?? En.LINEAR_TO_LINEAR, this.hashProperties = ["method"]
            }
            static getEncodingComponents(e) {
                switch (e) {
                    case vr.LinearEncoding:
                        return ["Linear"];
                    case vr.sRGBEncoding:
                        return ["sRGB"];
                    case vr.RGBEEncoding:
                        return ["RGBE"];
                    case vr.RGBM7Encoding:
                        return ["RGBM", new ve(7).setReadonly(!0)];
                    case vr.RGBM16Encoding:
                        return ["RGBM", new ve(16).setReadonly(!0)];
                    case vr.RGBDEncoding:
                        return ["RGBD", new ve(256).setReadonly(!0)];
                    case vr.GammaEncoding:
                        return ["Gamma", new Ye("float( GAMMA_FACTOR )", "f")];
                    default:
                        return []
                }
            }
            generate(e, t) {
                let r = this.input.build(e, "v4"),
                    i = this.getType(e),
                    s = En.Nodes[this.method],
                    o = e.include(s);
                if (o === En.LINEAR_TO_LINEAR) return e.format(r, i, t);
                if (s.inputs.length === 2) {
                    let l = this.factor.build(e, "f");
                    return e.format(o + "( " + r + ", " + l + " )", i, t)
                } else return e.format(o + "( " + r + " )", i, t)
            }
            fromEncoding(e) {
                let t = En.getEncodingComponents(e);
                this.method = "LinearTo" + t[0], this.factor = t[1]
            }
            fromDecoding(e) {
                let t = En.getEncodingComponents(e);
                this.method = t[0] + "ToLinear", this.factor = t[1]
            }
            copy(e) {
                return super.copy(e), this.input.copy(e.input), this.method = e.method, this.factor.copy(e.factor), this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.input = this.input.toJSON(e).uuid, t.factor = this.factor.toJSON(e).uuid, t.method = this.method), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.input && (this.input = t.getNode(e.input)), e.factor && (this.factor = t.getNode(e.factor)), e.method && (this.method = e.method), this
            }
        },
        St = En;
    St.Nodes = {
        LinearToLinear: new xe(["vec4 LinearToLinear( in vec4 value ) {", "	return value;", "}"].join(`
`)),
        GammaToLinear: new xe(["vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {", "	return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );", "}"].join(`
`)),
        LinearToGamma: new xe(["vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {", "	return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );", "}"].join(`
`)),
        sRGBToLinear: new xe(["vec4 sRGBToLinear( in vec4 value ) {", "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );", "}"].join(`
`)),
        LinearTosRGB: new xe(["vec4 LinearTosRGB( in vec4 value ) {", "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );", "}"].join(`
`)),
        RGBEToLinear: new xe(["vec4 RGBEToLinear( in vec4 value ) {", "	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );", "}"].join(`
`)),
        LinearToRGBE: new xe(["vec4 LinearToRGBE( in vec4 value ) {", "	float maxComponent = max( max( value.r, value.g ), value.b );", "	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );", "	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );", "}"].join(`
`)),
        RGBMToLinear: new xe(["vec3 RGBMToLinear( in vec4 value, in float maxRange ) {", "	return vec4( value.xyz * value.w * maxRange, 1.0 );", "}"].join(`
`)),
        LinearToRGBM: new xe(["vec3 LinearToRGBM( in vec4 value, in float maxRange ) {", "	float maxRGB = max( value.x, max( value.g, value.b ) );", "	float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );", "	M            = ceil( M * 255.0 ) / 255.0;", "	return vec4( value.rgb / ( M * maxRange ), M );", "}"].join(`
`)),
        RGBDToLinear: new xe(["vec3 RGBDToLinear( in vec4 value, in float maxRange ) {", "	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );", "}"].join(`
`)),
        LinearToRGBD: new xe(["vec3 LinearToRGBD( in vec4 value, in float maxRange ) {", "	float maxRGB = max( value.x, max( value.g, value.b ) );", "	float D      = max( maxRange / maxRGB, 1.0 );", "	D            = clamp( floor( D ) / 255.0, 0.0, 1.0 );", "	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );", "}"].join(`
`)),
        cLogLuvM: new Ve("const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );"),
        LinearToLogLuv: new xe(["vec4 LinearToLogLuv( in vec4 value ) {", "	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;", "	Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));", "	vec4 vResult;", "	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;", "	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;", "	vResult.w = fract(Le);", "	vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;", "	return vResult;", "}"].join(`
`), [new Ve("const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );")]),
        cLogLuvInverseM: new Ve("const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );"),
        LogLuvToLinear: new xe(["vec4 LogLuvToLinear( in vec4 value ) {", "	float Le = value.z * 255.0 + value.w;", "	vec3 Xp_Y_XYZp;", "	Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);", "	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;", "	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;", "	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;", "	return vec4( max(vRGB, 0.0), 1.0 );", "}"].join(`
`), [new Ve("const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );")])
    }, St.LINEAR_TO_LINEAR = "LinearToLinear", St.GAMMA_TO_LINEAR = "GammaToLinear", St.LINEAR_TO_GAMMA = "LinearToGamma", St.SRGB_TO_LINEAR = "sRGBToLinear", St.LINEAR_TO_SRGB = "LinearTosRGB", St.RGBE_TO_LINEAR = "RGBEToLinear", St.LINEAR_TO_RGBE = "LinearToRGBE", St.RGBM_TO_LINEAR = "RGBMToLinear", St.LINEAR_TO_RGBM = "LinearToRGBM", St.RGBD_TO_LINEAR = "RGBDToLinear", St.LINEAR_TO_RGBD = "LinearToRGBD", St.LINEAR_TO_LOG_LUV = "LinearToLogLuv", St.LOG_LUV_TO_LINEAR = "LogLuvToLinear";
    var wd = W(J()),
        zi = class extends wd.Texture {
            toJSON(e) {
                let t = super.toJSON(e),
                    r = e === void 0 || typeof e == "string";
                if (this.image !== void 0 && !r) {
                    let i = this.image;
                    if (Array.isArray(i)) {
                        e.images[i.uuid].url = [];
                        for (let s = 0; s < i.length; s++) e.images[i.uuid].url[s] = Sd(i[s])
                    } else e.images[i.uuid].url = Sd(i)
                }
                return t
            }
        };

    function Sd(n) {
        return typeof HTMLImageElement != "undefined" && n instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && n instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && n instanceof ImageBitmap ? Ux(n) : (console.warn("THREE.Texture: Unable to serialize Texture."), "")
    }
    var hs;

    function Ux(n) {
        if (/^data:/i.test(n.src)) return n.src;
        let e;
        if (n instanceof HTMLCanvasElement) e = n;
        else {
            hs === void 0 && (hs = document.createElement("canvas")), hs.width = n.width, hs.height = n.height;
            let t = hs.getContext("2d");
            n instanceof ImageData ? t.putImageData(n, 0, 0) : t.drawImage(n, 0, 0, n.width, n.height), e = hs
        }
        return /\.jpe?g$/i.test(n.src) ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
    }
    var yr = class extends At {
        constructor(e = new zi, t, r, i) {
            super("v4", {
                shared: !0
            });
            this.nodeType = "Texture";
            this.value = e, this.uv = t ?? new Tn, this.bias = r, this.project = i !== void 0 ? i : !1
        }
        getTexture(e, t) {
            return super.generate(e, t, this.value.uuid, "t")
        }
        generate(e, t) {
            if (t === "sampler2D") return this.getTexture(e, t);
            let r = this.getTexture(e, t),
                i = this.uv.build(e, this.project ? "v4" : "v2"),
                s = this.bias ? this.bias.build(e, "f") : void 0;
            s === void 0 && e.context.bias && (s = e.context.bias.setTexture(this).build(e, "f"));
            let o, l;
            this.project ? o = "texture2DProj" : o = s ? "tex2DBias" : "tex2D", s ? l = o + "( " + r + ", " + i + ", " + s + " )" : l = o + "( " + r + ", " + i + " )";
            let a = {
                    include: e.isShader("vertex"),
                    ignoreCache: !0
                },
                c = this.getType(e);
            return e.addContext(a), this.colorSpace = this.colorSpace ?? new St(new Ye("", c)), this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(l), l = this.colorSpace.build(e, c), e.removeContext(), e.format(l, c, t)
        }
        copy(e) {
            return super.copy(e), this.value.copy(e.value), this.uv.copy(e.uv), e.bias ? this.bias ? this.bias.copy(e.bias) : this.bias = e.bias.clone() : this.bias = void 0, e.colorSpace ? this.colorSpace ? this.colorSpace.copy(e.colorSpace) : this.colorSpace = e.colorSpace.clone() : this.colorSpace = void 0, this.project = e.project, this.value.updateMatrix(), this.value.needsUpdate = !0, this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), this.value && (t.value = this.value.toJSON(e).uuid), t.uv = this.uv.toJSON(e).uuid, t.project = this.project, this.bias && (t.bias = this.bias.toJSON(e).uuid)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), this.project = e.project, e.value && (this.value = t.getTexture(e.value), this.value.updateMatrix()), e.uv && (this.uv = t.getNode(e.uv)), e.bias && (this.bias = t.getNode(e.bias)), this
        }
    };
    var Nd = W(J());
    var ki = class extends At {
        constructor(e) {
            super("m3");
            this.nodeType = "Matrix3";
            this.value = e ?? new Nd.Matrix3
        }
        generateReadonly(e, t, r, i, s, o) {
            return e.format("mat3(" + this.value.elements.join(", ") + ")", i, t)
        }
        copy(e) {
            return super.copy(e), this.elements = e.elements, this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.elements = this.value.elements.concat()), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.elements && (this.elements = e.elements), this
        }
        get elements() {
            return this.value.elements
        }
        set elements(e) {
            this.value.fromArray(e)
        }
    };
    var ms;
    (function(i) {
        i[i.UV = 0] = "UV", i[i.PLANAR = 1] = "PLANAR", i[i.SPHERICAL = 2] = "SPHERICAL", i[i.CYLINDRICAL = 3] = "CYLINDRICAL"
    })(ms || (ms = {}));
    var So = class extends _e {
            constructor(e = new yr, t, r, i, s, o, l) {
                super("v3");
                this.nodeType = "CustomTexture";
                this.firstTime = !0, this.texture = e, this.textureSize = t, this.crop = r, this.projection = i, this.axis = s, this.mat = new ki(this.texture.value.matrix), this.alpha = o, this.mode = l, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
            }
            generate(e, t) {
                e.require("position"), e.require("uv"), e.requires.uv = [!0];
                let r;
                switch (this.projection.value) {
                    case 3:
                        r = e.include(So.Nodes.cylindrical);
                        break;
                    case 2:
                        r = e.include(So.Nodes.spherical);
                        break;
                    case 1:
                        let s = new xe(`
		vec3 g${this.uuid.toString().replace(/-/g,"")}_planarTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( g${this.uuid.toString().replace(/-/g,"")}_vCustomUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);
                        r = e.include(s);
                        break;
                    default:
                        r = e.include(So.Nodes.uv);
                        break
                }
                if (this.projection.value === 1 && this.firstTime) {
                    let s = `g${this.uuid.toString().replace(/-/g,"")}`;
                    e.addVertexParsCode(`varying vec2 ${s}_vCustomUv;`), e.addFragmentParsCode(`varying vec2 ${s}_vCustomUv;`), e.addVertexFinalCode(`
                        vec3 ${s}_posN = normalize(transformed);
${this.axis.value===0?`
									   float ${s}_u = (1. + (${s}_posN.z)) / 2.;
									   float ${s}_v = (1. + (${s}_posN.y)) / 2.;
									   `:""}

${this.axis.value===1?`
									   float ${s}_u = (1. + (${s}_posN.x)) / 2.;
									   float ${s}_v = (1. - (${s}_posN.z)) / 2.;
									   `:""}

${this.axis.value===2?`
									   float ${s}_u = (1. + (${s}_posN.x)) / 2.;
									   float ${s}_v = (1. + (${s}_posN.y)) / 2.;
									   `:""}

                        ${s}_vCustomUv = vec2(${s}_u, ${s}_v);
                    `)
                }
                e.addFragmentVariable(this.calpha, "float");
                let i = [];
                return i.push(this.texture.getTexture(e, "t")), i.push(this.textureSize.build(e, "v2")), i.push(this.crop.build(e, "f")), i.push(this.mat.build(e, "mat3")), i.push(this.alpha.build(e, "f")), i.push(this.mode.build(e, "i")), i.push(this.calpha), this.firstTime = !this.firstTime, e.format(r + "(" + i.join(",") + ")", this.getType(e), t)
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.texture = this.texture.toJSON(e).uuid, t.textureSize = this.textureSize.toJSON(e).uuid, t.crop = this.crop.toJSON(e).uuid, t.projection = this.projection.toJSON(e).uuid, t.axis = this.axis.toJSON(e).uuid, t.alpha = this.alpha.toJSON(e).uuid, t.mode = this.mode.toJSON(e).uuid, t.calpha = this.calpha), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.texture && (this.texture = t.getNode(e.texture), this.texture.value.updateMatrix(), this.mat = new ki(this.texture.value.matrix)), e.textureSize && (this.textureSize = t.getNode(e.textureSize)), e.crop && (this.crop = t.getNode(e.crop)), e.projection && (this.projection = t.getNode(e.projection)), e.axis && (this.axis = t.getNode(e.axis)), e.alpha && (this.alpha = t.getNode(e.alpha)), e.mode && (this.mode = t.getNode(e.mode)), e.calpha && (this.calpha = e.calpha), this
            }
            copy(e) {
                return super.copy(e), this.texture.copy(e.texture), this.textureSize = e.textureSize.clone(), this.crop = e.crop.clone(), this.projection = e.projection.clone(), this.axis = e.axis.clone(), this.alpha = e.alpha.clone(), this.mode = e.mode.clone(), this
            }
        },
        ps = So;
    ps.Nodes = function() {
        let e = new xe(`
vec3 cylindricalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v =  (posN.y / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`),
            t = new xe(`
vec3 sphericalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`),
            r = new xe(`vec3 uvTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);
        return {
            cylindrical: e,
            spherical: t,
            uv: r
        }
    }();
    var Kc = class extends _e {
            constructor(e, t, r, i, s, o, l) {
                super("v3");
                this.nodeType = "Fresnel";
                this.color = e, this.bias = t, this.scale = r, this.intensity = i, this.factor = s, this.alpha = o, this.mode = l, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
            }
            generate(e, t) {
                if (e.require("vWorldViewDir"), e.require("vWorldNormal"), e.isShader("fragment")) {
                    e.addFragmentVariable(this.calpha, "float");
                    let r = e.include(Kc.Nodes.fresnel),
                        i = [];
                    return i.push(this.color.build(e, "c")), i.push(this.bias.build(e, "f")), i.push(this.scale.build(e, "f")), i.push(this.intensity.build(e, "f")), i.push(this.factor.build(e, "f")), i.push(this.alpha.build(e, "f")), i.push(this.mode.build(e, "i")), i.push(this.calpha), e.format(r + "(" + i.join(",") + ")", this.getType(e), t)
                } else return console.warn("FresnelNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t)
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.color = this.color.toJSON(e).uuid, t.bias = this.bias.toJSON(e).uuid, t.scale = this.scale.toJSON(e).uuid, t.intensity = this.intensity.toJSON(e).uuid, t.factor = this.factor.toJSON(e).uuid, t.alpha = this.alpha.toJSON(e).uuid, t.mode = this.mode.toJSON(e).uuid, t.calpha = this.calpha), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.color && (this.color = t.getNode(e.color)), e.bias && (this.bias = t.getNode(e.bias)), e.scale && (this.scale = t.getNode(e.scale)), e.intensity && (this.intensity = t.getNode(e.intensity)), e.factor && (this.factor = t.getNode(e.factor)), e.alpha && (this.alpha = t.getNode(e.alpha)), e.mode && (this.mode = t.getNode(e.mode)), e.calpha && (this.calpha = e.calpha), this
            }
            copy(e) {
                return super.copy(e), this.color = e.color.clone(), this.bias = e.bias.clone(), this.scale = e.scale.clone(), this.intensity = e.intensity.clone(), this.factor = e.factor.clone(), this.alpha = e.alpha.clone(), this.mode = e.mode.clone(), this.calpha = e.calpha, this
            }
        },
        gs = Kc;
    gs.Nodes = function() {
        return {
            fresnel: new xe(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, float alpha, int mode, out float calpha) {
				float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWorldNormal ) ) ), intensity );

				float lalpha = clamp( fresnel, 0.0, 1.0 ) * alpha;
				calpha = lalpha / clamp(lalpha + accumAlpha, 0.001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;
				return color;
			}`)
        }
    }();
    var vs;
    (function(s) {
        s.SIMPLEX = "simplex3d", s.SIMPLEX_FRACTAL = "simplex3dFractal", s.ASHIMA = "simplexAshima", s.FBM = "fbm", s.PERLIN = "perlin"
    })(vs || (vs = {}));
    var xr = function() {
        let n = 5,
            e = new xe(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`),
            t = new xe(`float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`, [e]);
        t.keywords.F3 = new Ve("float F3 0.3333333"), t.keywords.G3 = new Ve("float G3 0.1666667");
        let r = new xe(`float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`, [t]),
            i = new xe("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"),
            s = new xe("vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"),
            o = new xe(`float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`, [i, s]),
            l = new xe("vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"),
            a = new xe("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}", [l]),
            c = new xe(`float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`, [a]),
            f = new xe(`float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`, [c]);
        f.keywords.NUM_OCTAVES = new Ve(`int NUM_OCTAVES ${n}`);
        let h = new xe("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"),
            m = new xe(`float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`, [i, s, h]);
        return {
            simplex: t,
            simplexFractal: r,
            simplexAshima: o,
            fbm: f,
            perlin: m
        }
    }();
    var Xc = class extends _e {
            constructor(e, t, r, i, s, o, l) {
                super("v3");
                this.nodeType = "Rainbow";
                this.filmThickness = e, this.movement = t, this.wavelengths = r, this.noiseStrength = i, this.noiseScale = s, this.offset = o, this.alpha = l, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
            }
            generate(e, t) {
                if (e.isShader("fragment")) {
                    e.require("normal"), e.require("uv"), e.requires.uv = [!0], e.addFragmentVariable(this.calpha, "float");
                    let r = e.include(Xc.Nodes.rainbow),
                        i = [];
                    return i.push(this.filmThickness.build(e, "f")), i.push(this.movement.build(e, "f")), i.push(this.wavelengths.build(e, "v3")), i.push(this.noiseStrength.build(e, "f")), i.push(this.noiseScale.build(e, "f")), i.push(this.offset.build(e, "v3")), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(r + "(" + i.join(",") + ")", this.getType(e), t)
                } else return console.warn("RainbowNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t)
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.filmThickness = this.filmThickness.toJSON(e).uuid, t.movement = this.movement.toJSON(e).uuid, t.wavelengths = this.wavelengths.toJSON(e).uuid, t.noiseStrength = this.noiseStrength.toJSON(e).uuid, t.noiseScale = this.noiseScale.toJSON(e).uuid, t.offset = this.offset.toJSON(e).uuid, t.alpha = this.alpha.toJSON(e).uuid, t.calpha = this.calpha), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.filmThickness && (this.filmThickness = t.getNode(e.filmThickness)), e.movement && (this.movement = t.getNode(e.movement)), e.wavelengths && (this.wavelengths = t.getNode(e.wavelengths)), e.noiseStrength && (this.noiseStrength = t.getNode(e.noiseStrength)), e.noiseScale && (this.noiseScale = t.getNode(e.noiseScale)), e.offset && (this.offset = t.getNode(e.offset)), e.alpha && (this.alpha = t.getNode(e.alpha)), e.calpha && (this.calpha = e.calpha), this
            }
            copy(e) {
                return super.copy(e), this.filmThickness = e.filmThickness.clone(), this.movement = e.movement.clone(), this.wavelengths = e.wavelengths.clone(), this.noiseStrength = e.noiseStrength.clone(), this.noiseScale = e.noiseScale.clone(), this.offset = e.offset.clone(), this.alpha = e.alpha.clone(), this.calpha = e.calpha, this
            }
        },
        ys = Xc;
    ys.Nodes = function() {
        let e = new xe(`vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 viewDir = normalize(-(cameraPosition + offset));
                 vec3 st = normalize(position) * noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vObjectNormal), viewDir)) + movement);
             }`, [xr.simplex]);
        return {
            rainbow: new xe(`vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, float alpha, out float calpha) {
                 vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

                 float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);
                 float lalpha = alpha * rainbowContribution;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

                 return res;
             }`, [e])
        }
    }();
    var qc = class extends _e {
            constructor(e, t) {
                super("v3");
                this.nodeType = "CustomNormal";
                this.cnormal = e, this.alpha = t
            }
            generate(e, t) {
                if (e.isShader("fragment")) {
                    let r = e.include(qc.Nodes.customNormal),
                        i = [];
                    return i.push(this.cnormal.build(e, "v3")), i.push("normal"), i.push(this.alpha.build(e, "f")), e.format(r + "(" + i.join(",") + ")", this.getType(e), t)
                } else return console.warn("CustomNormalNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t)
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.cnormal = this.cnormal.toJSON(e).uuid, t.alpha = this.alpha.toJSON(e).uuid), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.cnormal && (this.cnormal = t.getNode(e.cnormal)), e.alpha && (this.alpha = t.getNode(e.alpha)), this
            }
            copy(e) {
                return super.copy(e), this.cnormal.copy(e.cnormal), this.alpha.copy(e.alpha), this
            }
        },
        xs = qc;
    xs.Nodes = function() {
        return {
            customNormal: new xe(`vec3 customNormal(vec3 cnormal, vec3 norm, float alpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return normal;
			}`)
        }
    }();
    var Zc = class extends _e {
            constructor(e, t, r, i, s, o, l, a, c) {
                super("v3");
                this.nodeType = "Gradient";
                this.glType = e, this.num = t, this.smooth = r, this.colors = i, this.steps = s, this.offset = o, this.morph = l, this.angle = a, this.alpha = c, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
            }
            generate(e, t) {
                if (e.isShader("fragment")) {
                    e.define("GRAD_MAX", 10), e.require("uv"), e.requires.uv = [!0], e.addFragmentVariable(this.calpha, "float");
                    let r = e.include(Zc.Nodes.gradient),
                        i = [];
                    return i.push(this.glType.build(e, "i")), i.push(this.num.build(e, "i")), i.push(this.smooth.build(e, "b")), i.push(this.colors.build(e, "v4[]")), i.push(this.steps.build(e, "f[]")), i.push(this.offset.build(e, "v2")), i.push(this.morph.build(e, "v2")), i.push(this.angle.build(e, "f")), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(r + "(" + i.join(",") + ")", this.getType(e), t)
                } else return console.warn("GradientNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t)
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.glType = this.glType.toJSON(e).uuid, t.num = this.num.toJSON(e).uuid, t.smooth = this.smooth.toJSON(e).uuid, t.colors = this.colors.toJSON(e).uuid, t.steps = this.steps.toJSON(e).uuid, t.offset = this.offset.toJSON(e).uuid, t.morph = this.morph.toJSON(e).uuid, t.angle = this.angle.toJSON(e).uuid, t.alpha = this.alpha.toJSON(e).uuid, t.calpha = this.calpha), t.nodeType = this.nodeType, t
            }
            copy(e) {
                return super.copy(e), this.glType = e.glType.clone(), this.num = e.num.clone(), this.smooth = e.smooth.clone(), this.colors = e.colors.clone(), this.steps = e.steps.clone(), this.offset = e.offset.clone(), this.morph = e.morph.clone(), this.angle = e.angle.clone(), this.alpha = e.alpha.clone(), this.calpha = e.calpha, this
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.calpha && (this.calpha = e.calpha), e.glType && (this.glType = t.getNode(e.glType)), e.num && (this.num = t.getNode(e.num)), e.smooth && (this.smooth = t.getNode(e.smooth)), e.colors && (this.colors = t.getNode(e.colors)), e.steps && (this.steps = t.getNode(e.steps)), e.offset && (this.offset = t.getNode(e.offset)), e.morph && (this.morph = t.getNode(e.morph)), e.angle && (this.angle = t.getNode(e.angle)), e.alpha && (this.alpha = t.getNode(e.alpha)), this
            }
        },
        As = Zc;
    As.Nodes = function() {
        return {
            gradient: new xe(`vec3 gradient(int glType, int num, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( glType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( glType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}
				float p;
				for ( int i = 1; i < num; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix( color, colors[i],
									( smoothed ) ? smoothstep( 0.0, 1.0, p ) : p
								   );
				}
				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return color.xyz;
			}`)
        }
    }();
    var Mn;
    (function(t) {
        t.NOISE = "noise", t.MAP = "map"
    })(Mn || (Mn = {}));
    var $c = class extends _e {
            constructor(e = new Qe(0), t, r, i, s, o) {
                super("v3");
                this.nodeType = "VertexDisplacement";
                this.displacementTypeIndex = e, this.intensity = t, this.movementOrTexture = r, Object.values(Mn)[this.displacementTypeIndex.value] === Mn.MAP && (this.mat = new ki(this.movementOrTexture.value.matrix)), this.cropOrOffset = i, this.scale = s, this.noiseFunctionIndex = o
            }
            generate(e, t) {
                if (e.isShader("vertex")) {
                    e.define("USE_LAYER_DISPLACE");
                    let r, i = [];
                    switch (i.push("displaced_position"), i.push("displaced_normal"), Object.values(Mn)[this.displacementTypeIndex.value]) {
                        case Mn.MAP: {
                            r = e.include($c.Nodes.map), i.push(this.movementOrTexture.getTexture(e, "t")), i.push("uv"), i.push(this.cropOrOffset.build(e, "f")), this.mat && i.push(this.mat.build(e, "mat3"));
                            break
                        }
                        case Mn.NOISE: {
                            let o = Object.values(vs)[this.noiseFunctionIndex.value],
                                l = new xe(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`),
                                a = new xe(`vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement) {
							return p + n * ${o}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
						}`, [xr.simplex, xr.simplexFractal, xr.simplexAshima, xr.fbm, xr.perlin]),
                                c = new xe(`vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`, [a, l]);
                            r = e.include(c), i.push(this.scale.build(e, "f")), i.push(this.cropOrOffset.build(e, "v3")), i.push(this.movementOrTexture.build(e, "f"));
                            break
                        }
                    }
                    return i.push(this.intensity.build(e, "f")), i.push("displaced_normal"), e.format(r + "(" + i.join(",") + ")", this.getType(e), t)
                } else return console.warn("VertexDisplacementNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t)
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.intensity = this.intensity.toJSON(e).uuid, t.scale = this.scale?.toJSON(e).uuid, t.movementOrTexture = this.movementOrTexture.toJSON(e).uuid, t.cropOrOffset = this.cropOrOffset.toJSON(e).uuid), t.displacementTypeIndex = this.displacementTypeIndex, t.noiseFunctionIndex = this.noiseFunctionIndex, t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), this.displacementTypeIndex = e.displacementTypeIndex, this.noiseFunctionIndex = e.noiseFunctionIndex, e.cropOrOffset && (this.cropOrOffset = t.getNode(e.cropOrOffset)), e.intensity && (this.intensity = t.getNode(e.intensity)), e.movementOrTexture && (this.displacementTypeIndex.value === 1 ? (this.movementOrTexture = t.getNode(e.movementOrTexture), this.movementOrTexture.value.updateMatrix(), this.mat = new ki(this.movementOrTexture.value.matrix)) : this.displacementTypeIndex.value === 0 && (this.movementOrTexture = t.getNode(e.movementOrTexture))), e.scale && (this.scale = t.getNode(e.scale)), this
            }
            copy(e) {
                return super.copy(e), this.noiseFunctionIndex = e.noiseFunctionIndex?.clone(), this.scale = e.scale?.clone(), this.cropOrOffset = e.cropOrOffset.clone(), this.intensity = e.intensity.clone(), this.movementOrTexture = e.movementOrTexture.clone(), this
            }
        },
        _n = $c;
    _n.Nodes = function() {
        let e = new xe(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`),
            t = new xe(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`);
        return {
            map: new xe(`vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`, [e, t])
        }
    }();
    var bs = class extends _e {
        constructor(e = new we, t = new we, r = new we, i = new we, s = new we, o = new we, l = new we, a = new we, c = new we, f = new we, h = new we, m = new we, v = new we, g = new we, y = new we) {
            super("v3");
            this.nodeType = "Noise";
            this.scale = e, this.move = t, this.fA = r, this.fB = i, this.distortion = s, this.colorA = o, this.colorB = l, this.colorC = a, this.colorD = c, this.intA = f, this.intB = h, this.intC = m, this.intD = v, this.alpha = g, this.noiseFunctionIndex = y
        }
        generate(e, t, r, i, s) {
            e.require("uv"), e.requires.uv = [!0];
            let o = Object.values(vs)[this.noiseFunctionIndex.value],
                l = new xe(`vec3 ${o}customNoise(float scale, float move, vec2 fA, vec2 fB, vec2 distortion, vec3 colorA, vec3 colorB, vec3 colorC, vec3 colorD, float intA, float intB, float intC, float intD, float alpha) {
				vec3 st = normalize(position) * scale;
				vec3 q = vec3(${o}(st),
							  ${o}(st + vec3(1.0)),
							  ${o}(st + vec3(1.0)));
				vec3 r = vec3(${o}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
							  ${o}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
							  ${o}(st * q));
				float f = ${o}(st + r);
				vec3 color;
				color = mix(colorA * intA, colorB * intB, clamp((f * f) * 4.0, 0.0, 1.0));
				color = mix(color, colorC * intC, clamp(length(q), 0.0, 1.0));
				color = mix(color, colorD * intD, clamp(length(r.x), 0.0, 1.0));
				accumAlpha += (1.0 - accumAlpha) * alpha;
				return clamp(color, 0.0, 1.0);
			}`, [xr.simplex, xr.simplexFractal, xr.simplexAshima, xr.fbm, xr.perlin]),
                a = e.include(l),
                c = [];
            return c.push(this.scale.build(e, "f")), c.push(this.move.build(e, "f")), c.push(this.fA.build(e, "v2")), c.push(this.fB.build(e, "v2")), c.push(this.distortion.build(e, "v2")), c.push(this.colorA.build(e, "c")), c.push(this.colorB.build(e, "c")), c.push(this.colorC.build(e, "c")), c.push(this.colorD.build(e, "c")), c.push(this.intA.build(e, "f")), c.push(this.intB.build(e, "f")), c.push(this.intC.build(e, "f")), c.push(this.intD.build(e, "f")), c.push(this.alpha.build(e, "f")), e.format(a + "(" + c.join(",") + ")", this.getType(e), t)
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.scale = this.scale.toJSON(e).uuid, t.move = this.move.toJSON(e).uuid, t.fA = this.fA.toJSON(e).uuid, t.fB = this.fB.toJSON(e).uuid, t.distortion = this.distortion.toJSON(e).uuid, t.colorA = this.colorA.toJSON(e).uuid, t.colorB = this.colorB.toJSON(e).uuid, t.colorC = this.colorC.toJSON(e).uuid, t.colorD = this.colorD.toJSON(e).uuid, t.intA = this.intA.toJSON(e).uuid, t.intB = this.intB.toJSON(e).uuid, t.intC = this.intC.toJSON(e).uuid, t.intD = this.intD.toJSON(e).uuid, t.alpha = this.alpha.toJSON(e).uuid), t.noiseFunction = this.noiseFunctionIndex, t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.scale && (this.scale = t.getNode(e.scale)), e.move && (this.move = t.getNode(e.move)), e.fA && (this.fA = t.getNode(e.fA)), e.fB && (this.fB = t.getNode(e.fB)), e.distortion && (this.distortion = t.getNode(e.distortion)), e.colorA && (this.colorA = t.getNode(e.colorA)), e.colorB && (this.colorB = t.getNode(e.colorB)), e.colorC && (this.colorC = t.getNode(e.colorC)), e.colorD && (this.colorD = t.getNode(e.colorD)), e.intA && (this.intA = t.getNode(e.intA)), e.intB && (this.intB = t.getNode(e.intB)), e.intC && (this.intC = t.getNode(e.intC)), e.intD && (this.intD = t.getNode(e.intD)), e.alpha && (this.alpha = t.getNode(e.alpha)), e.noiseFunctionIndex && (this.noiseFunctionIndex = t.getNode(e.noiseFunctionIndex)), this
        }
        copy(e) {
            return super.copy(e), this.scale.copy(e.scale), this.move.copy(e.move), this.fA.copy(e.fA), this.fB.copy(e.fB), this.distortion.copy(e.distortion), this.colorA.copy(e.colorA), this.colorB.copy(e.colorB), this.colorC.copy(e.colorC), this.colorD.copy(e.colorD), this.intA.copy(e.intA), this.intB.copy(e.intB), this.intC.copy(e.intC), this.intD.copy(e.intD), this.alpha.copy(e.alpha), this.noiseFunctionIndex.copy(e.noiseFunctionIndex), this
        }
    };
    bs.numOctaves = 5;
    var ws;
    (function(i) {
        i.ADD = "+", i.SUB = "-", i.MUL = "*", i.DIV = "/"
    })(ws || (ws = {}));
    var eu = class extends _e {
            constructor(e = new we, t = new we, r = eu.ADD) {
                super();
                this.nodeType = "Operator";
                this.a = e, this.b = t, this.op = r
            }
            getType(e) {
                let t = this.a.getType(e),
                    r = this.b.getType(e);
                return e.isTypeMatrix(t) ? "v4" : e.getTypeLength(r) > e.getTypeLength(t) ? r : t
            }
            generate(e, t) {
                let r = this.getType(e);
                this.type = r;
                let i = this.a.build(e, r),
                    s = this.b.build(e, r);
                return e.format("( " + i + " " + this.op + " " + s + " )", r, t)
            }
            copy(e) {
                return super.copy(e), this.a.copy(e.a), this.b.copy(e.b), this.op = e.op, this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.a = this.a.toJSON(e).uuid, t.b = this.b.toJSON(e).uuid, t.op = this.op), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.a && (this.a = t.getNode(e.a)), e.b && (this.b = t.getNode(e.b)), e.op && (this.op = e.op), this
            }
        },
        or = eu;
    or.ADD = ws.ADD, or.SUB = ws.SUB, or.MUL = ws.MUL, or.DIV = ws.DIV;
    var Ss = class extends _e {
        constructor(e = new we, t = new we, r = new we, i = new we) {
            super("v3");
            this.nodeType = "Blend";
            this.a = e, this.b = t, this.alpha = r, this.mode = i
        }
        generate(e, t) {
            if (e.isShader("fragment")) {
                let r = [];
                return r.push(this.a.build(e, "c")), r.push(this.b.build(e, "c")), r.push(this.alpha.build(e, "f")), r.push(this.mode.build(e, "i")), e.format("spe_blend(" + r.join(",") + ")", this.getType(e), t)
            } else return console.warn("BlendNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t)
        }
        copy(e) {
            return super.copy(e), this.a.copy(e.a), this.b.copy(e.b), this.alpha.copy(e.alpha), this.mode.copy(e.mode), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.a = this.a.toJSON(e).uuid, t.b = this.b.toJSON(e).uuid, t.alpha = this.alpha.toJSON(e).uuid, t.mode = this.mode.toJSON(e).uuid), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.a && (this.a = t.getNode(e.a)), e.b && (this.b = t.getNode(e.b)), e.alpha && (this.alpha = t.getNode(e.alpha)), e.mode && (this.mode = t.getNode(e.mode)), this
        }
    };
    var tu = class extends _e {
            constructor(e, t, r, i, s, o, l) {
                super("v3");
                this.nodeType = "Depth";
                this.near = e, this.far = t, this.isVector = r, this.origin = i, this.colorA = s, this.colorB = o, this.alpha = l
            }
            generate(e, t) {
                if (e.isShader("fragment")) {
                    e.require("worldPosition");
                    let r = e.include(tu.Nodes.sdepth),
                        i = [];
                    return i.push(this.near.build(e, "f")), i.push(this.far.build(e, "f")), i.push(this.isVector.build(e, "f")), i.push(this.origin.build(e, "v3")), i.push(this.colorA.build(e, "v3")), i.push(this.colorB.build(e, "v3")), i.push(this.alpha.build(e, "f")), e.format(r + "(" + i.join(",") + ")", this.getType(e), t)
                } else return console.warn("DepthNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t)
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.near = this.near.toJSON(e).uuid, t.far = this.far.toJSON(e).uuid, t.isVector = this.isVector.toJSON(e).uuid, t.origin = this.origin.toJSON(e).uuid, t.colorA = this.colorA.toJSON(e).uuid, t.colorB = this.colorB.toJSON(e).uuid, t.alpha = this.alpha.toJSON(e).uuid), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.near && (this.near = t.getNode(e.near)), e.far && (this.far = t.getNode(e.far)), e.isVector && (this.isVector = t.getNode(e.isVector)), e.origin && (this.origin = t.getNode(e.origin)), e.colorA && (this.colorA = t.getNode(e.colorA)), e.colorB && (this.colorB = t.getNode(e.colorB)), e.alpha && (this.alpha = t.getNode(e.alpha)), this
            }
            copy(e) {
                return super.copy(e), this.near = e.near.clone(), this.far = e.far.clone(), this.isVector = e.isVector.clone(), this.origin = e.origin.clone(), this.colorA = e.colorA.clone(), this.colorB = e.colorB.clone(), this.alpha = e.alpha.clone(), this
            }
        },
        Ns = tu;
    Ns.Nodes = function() {
        return {
            sdepth: new xe(`vec3 sdepth(float near, float far, float isVector, vec3 origin, vec3 colorA, vec3 colorB, float alpha) {
				vec3 base = ( isVector > 0.5 ) ?  origin : cameraPosition;
				float dist = length( vWPosition - base );
				float dep = ( dist - near ) / ( far - near );
				vec3 depth =  mix( colorB, colorA, 1.0 - clamp( dep, 0., 1. ) );

				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return depth;
			}`)
        }
    }();
    var ru = class extends _e {
            constructor(e, t, r, i) {
                super("v3");
                this.nodeType = "Matcap";
                this.color = e, this.texture = t, this.alpha = r, this.mode = i, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
            }
            generate(e, t) {
                if (e.isShader("fragment")) {
                    e.addFragmentVariable(this.calpha, "float");
                    let r = e.include(ru.Nodes.matcap);
                    e.require("normal"), e.requires.normal = !0;
                    let i = [];
                    return i.push(this.color.build(e, "v3")), i.push(this.texture.getTexture(e, "t")), i.push("normal"), i.push(this.alpha.build(e, "f")), i.push(this.mode.build(e, "i")), i.push(this.calpha), e.format(r + "(" + i.join(",") + ")", this.getType(e), t)
                } else return console.warn("MatcapNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t)
            }
            copy(e) {
                return super.copy(e), this.texture = e.texture.clone(), this.color = e.color.clone(), this.alpha = e.alpha.clone(), this.mode = e.mode.clone(), this.calpha = e.calpha, this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.texture = this.texture.toJSON(e).uuid, t.color = this.color.toJSON(e).uuid, t.alpha = this.alpha.toJSON(e).uuid, t.mode = this.mode.toJSON(e).uuid, t.calpha = this.calpha), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.calpha && (this.calpha = e.calpha), e.alpha && (this.alpha = t.getNode(e.alpha)), e.texture && (this.texture = t.getNode(e.texture)), e.color && (this.color = t.getNode(e.color)), e.mode && (this.mode = t.getNode(e.mode)), this
            }
        },
        Cs = ru;
    Cs.Nodes = function() {
        return {
            matcap: new xe(`vec3 matcap(vec3 color, sampler2D matcapTex, vec3 normal, float alpha, int mode, out float calpha) {
                vec3 viewDir = normalize( vViewPosition );
                vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
                vec3 y = cross( viewDir, x );
                vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
                vec4 matcapColor = texture2D( matcapTex, uv );
                // matcapColor = matcapTexelToLinear( matcapColor );
                matcapColor.rgb *= color;
                
                calpha =  alpha / clamp( alpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;
                
                return matcapColor.rgb;
            }
            `)
        }
    }();
    var ar = class {
        constructor(e) {
            this.id = 2, this.layerCount = 2, this.uuid = at.MathUtils.generateUUID(), this.needsUpdate = !1, this._material = e, this._layerNodes = [];
            let t = this._createLayer({
                id: 0,
                type: pt.COLOR
            });
            this._material.color = t.color, this._material.alpha === void 0 && (this._material.alpha = new ve(1));
            let r = new ve(1),
                i = new Qe(0);
            "shadingAlpha" in this._material && "shadingBlend" in this._material && (this._material.shadingAlpha = r, this._material.shadingBlend = i), this._layerNodes.push({
                id: 0,
                type: Ct.COLOR,
                color: t.color,
                alpha: t.alpha,
                mode: t.mode
            }), this._layerNodes.push({
                id: 1,
                type: Ct.LIGHTING,
                alpha: r,
                mode: i
            }), this.head = t.layer, this.head.next = new _t(1, {
                type: pt.LIGHTING,
                alpha: r,
                mode: i
            }), this.attachLightNodes()
        }
        get material() {
            return this._material
        }
        set material(e) {
            this._material = e;
            let t, r, i = this.head;
            for (; i !== void 0;) {
                if (i.type === pt.LIGHTING) {
                    t = i.uniforms[`f${i.id}_alpha`], r = i.uniforms[`f${i.id}_mode`];
                    break
                }
                i = i.next
            }
            "shadingAlpha" in this._material && "shadingBlend" in this._material && (this._material.shadingAlpha = t, this._material.shadingBlend = r), this.attachLightNodes(), this.blendColors(), this.blendAfterColors(), this.blendPositions()
        }
        addLayer(e) {
            if (e.id = e.id ?? ++this.id, this.layerCount++, e.type === pt.LIGHTING) {
                let i = this.createLightLayer(e);
                return this.uuid = at.MathUtils.generateUUID(), this.blendColors(), this.blendAfterColors(), this.blendPositions(), i
            }
            let t = this._createLayer(e),
                r = t.layer;
            if (this.head === void 0) this.head = r;
            else {
                let i = this.head;
                for (; i.next != null;) i = i.next;
                i.next = r
            }
            return t.color && this._layerNodes.push({
                id: r.id,
                type: Ct.COLOR,
                color: t.color,
                alpha: t.alpha,
                mode: t.mode
            }), t.position && this._layerNodes.push({
                id: r.id,
                type: Ct.POSITION,
                position: t.position
            }), this.uuid = at.MathUtils.generateUUID(), this.blendColors(), this.blendAfterColors(), this.blendPositions(), r
        }
        addLayerBeforeAt(e, t) {
            let r = this.head;
            e.id = e.id ?? ++this.id, this.layerCount++;
            let i = this._createLayer(e),
                s = i.layer;
            s.next = t;
            let o = 0;
            if (r === t) this.head = s, i.color && this._layerNodes.splice(0, 0, {
                id: s.id,
                type: Ct.COLOR,
                color: i.color,
                alpha: i.alpha,
                mode: i.mode
            }), i.position && this._layerNodes.splice(0, 0, {
                id: s.id,
                type: Ct.POSITION,
                position: i.position
            });
            else {
                for (o = 1; r?.next !== t;) r = r?.next, o++;
                r.next = s, i.color && this._layerNodes.splice(o, 0, {
                    id: s.id,
                    type: Ct.COLOR,
                    color: i.color,
                    alpha: i.alpha,
                    mode: i.mode
                }), i.position && this._layerNodes.splice(o, 0, {
                    id: s.id,
                    type: Ct.POSITION,
                    position: i.position
                })
            }
            return this.uuid = at.MathUtils.generateUUID(), this.blendColors(), this.blendAfterColors(), this.blendPositions(), s
        }
        addLayerAt(e, t) {
            t.id = t.id ?? ++this.id, this.layerCount++;
            let r = this._createLayer(t),
                i = r.layer;
            if (r.color && this._layerNodes.splice(e, 0, {
                    id: i.id,
                    type: Ct.COLOR,
                    color: r.color,
                    alpha: r.alpha,
                    mode: r.mode
                }), r.position && this._layerNodes.splice(e, 0, {
                    id: i.id,
                    type: Ct.POSITION,
                    position: r.position
                }), e == 0) i.next = this.head, this.head = i;
            else {
                let s = this.head,
                    o = this.head.next;
                for (let l = 0; l < e - 1; l++) s = o, o = o.next;
                i.next = o, s.next = i
            }
            return this.uuid = at.MathUtils.generateUUID(), this.blendColors(), this.blendAfterColors(), this.blendPositions(), i
        }
        removeLayer(e) {
            let t = this.head,
                r, i = 0;
            if (t?.id == e) this.head = t.next;
            else
                for (i = 1, r = t, t = t?.next; t != null;) {
                    if (t.id == e) {
                        r.next = t.next;
                        break
                    }
                    i++, r = t, t = t.next
                }
            return this.cleanupChangedLayer(t), this.blendColors(), this.blendAfterColors(), this.blendPositions(), this.uuid = at.MathUtils.generateUUID(), this.layerCount--, i
        }
        changeLayer(e, t) {
            let r, i = this.head,
                s;
            if (i?.id == e) {
                let o = this._createLayer(Ne({
                    id: e
                }, t));
                s = o.layer, s.next = i.next, this.head = s, o.color && (this._layerNodes[0] = {
                    id: s.id,
                    type: Ct.COLOR,
                    color: o.color,
                    alpha: o.alpha,
                    mode: o.mode
                }), o.position && (this._layerNodes[0] = {
                    id: s.id,
                    type: Ct.POSITION,
                    position: o.position
                }), s.uniforms[`f${e}_mode`].value = i.uniforms[`f${e}_mode`].value, s.uniforms[`f${e}_alpha`].value = i.uniforms[`f${e}_alpha`].value
            } else {
                r = i, i = i.next;
                let o = 1;
                for (; i != null;) {
                    if (i.id == e) {
                        let l = this._createLayer(Ne({
                            id: e
                        }, t));
                        s = l.layer, r.next = s, s.next = i.next, l.color && (this._layerNodes[o] = {
                            id: s.id,
                            type: Ct.COLOR,
                            color: l.color,
                            alpha: l.alpha,
                            mode: l.mode
                        }), l.position && (this._layerNodes[o] = {
                            id: s.id,
                            type: Ct.POSITION,
                            position: l.position
                        }), s.uniforms[`f${e}_mode`].value = i.uniforms[`f${e}_mode`].value, s.uniforms[`f${e}_alpha`].value = i.uniforms[`f${e}_alpha`].value;
                        break
                    }
                    r = i, i = i.next, o++
                }
            }
            return this.uuid = at.MathUtils.generateUUID(), this.blendColors(), this.blendAfterColors(), this.blendPositions(), s
        }
        getLayer(e) {
            let t = this.head;
            for (; t != null && t.id != e;) t = t.next;
            return t
        }
        getLayers() {
            let e = [],
                t = this.head;
            for (; t != null;) e.push(t), t = t.next;
            return e
        }
        getLayerPosition(e) {
            let t = this.head,
                r = 0;
            for (; t !== void 0 && t.id != e;) r++, t = t.next;
            return r
        }
        getDefines() {}
        getBeforeProgram() {}
        getLightingProgram() {}
        getAfterProgram() {}
        getVarPrograms() {}
        getUniforms() {}
        moveLayer(e, t) {
            let r, i = this.head,
                s;
            if (e == 0) r = this.head, this.head = r.next;
            else {
                for (let l = 0; l < e; l++) s = i, i = i.next;
                s.next = i.next, r = i
            }
            if (i = this.head, s = void 0, t == 0) r.next = this.head, this.head = r;
            else {
                for (let l = 0; l < t - 1; l++) i = i.next;
                r.next = i?.next, i.next = r
            }
            let o = this._layerNodes.splice(e, 1)[0];
            this._layerNodes.splice(t, 0, o), this.uuid = at.MathUtils.generateUUID(), this.blendColors(), this.blendAfterColors()
        }
        updateLayerUniform() {
            this.uuid = at.MathUtils.generateUUID(), this.blendColors(), this.blendAfterColors()
        }
        copy(e) {
            this.needsUpdate = !1, this.layerCount = e.layerCount, this._layerNodes = [], this.layerCount = 0, this.head = void 0, this.rebuildLayerNodes(this.head, e.head);
            let t = e.head,
                r = this.head;
            for (; t.next != null;) this.rebuildLayerNodes(r, t.next), r = r.next, t = t.next;
            return this.id = e.id, this.uuid = e.uuid, this.blendColors(), this.blendAfterColors(), this.blendPositions(), this
        }
        createLightLayer(e) {
            let t = new ve(e.alpha),
                r = new Qe(e.mode);
            this._material.shadingAlpha = t, this._material.shadingBlend = r, this._layerNodes.push({
                id: e.id,
                type: Ct.LIGHTING,
                alpha: t,
                mode: r
            });
            let i = new _t(e.id, {
                type: pt.LIGHTING,
                alpha: t,
                mode: r
            });
            if (this.head === void 0) this.head = i;
            else {
                let s = this.head;
                for (; s.next != null;) s = s.next;
                s.next = i
            }
            return this.attachLightNodes(), i
        }
        rebuildLayerNodes(e, t, r = !1) {
            if (t.type === pt.LIGHTING) {
                let i = r ? t.uniforms[`f${t.id}_alpha`] : new ve(t.uniforms[`f${t.id}_alpha`].value),
                    s = r ? t.uniforms[`f${t.id}_mode`] : new Qe(t.uniforms[`f${t.id}_mode`].value);
                this._material.shadingAlpha = i, this._material.shadingBlend = s, this._layerNodes.push({
                    id: t.id,
                    type: Ct.LIGHTING,
                    alpha: i,
                    mode: s
                }), this.head === void 0 ? this.head = new _t(t.id, {
                    type: pt.LIGHTING,
                    alpha: i,
                    mode: s
                }) : e && (e.next = new _t(t.id, {
                    type: pt.LIGHTING,
                    alpha: i,
                    mode: s
                })), this.attachLightNodes(t)
            } else {
                let i = {
                    type: t.type,
                    id: t.id
                };
                for (let s in t.uniforms) {
                    let o = t.getName(s);
                    if (!o) continue;
                    let l = `f${t.id}_${o}`;
                    if (Array.isArray(t.uniforms[l].value)) i[o] = t.uniforms[l].value.map(a => a.clone && !r ? a.clone() : a);
                    else {
                        let a = t.uniforms[l].value;
                        a != null && (i[o] = a.clone && !r ? a.clone() : a)
                    }
                }
                this.addLayer(i)
            }
        }
        attachLightNodes(e) {
            let t = {},
                r = this.getLightLayer();
            switch (this._material.userData.category) {
                case "Lambert":
                    t.emissive = new qe(e?.getValue("emissive")?.clone() ?? 0);
                    break;
                case "Phong":
                    t.shininess = new ve(e?.getValue("shininess") ?? 30), t.specular = new qe(e?.getValue("specular")?.clone() ?? 1118481);
                    break;
                case "Toon":
                    t.shininess = new ve(e?.getValue("shininess") ?? 30), t.specular = new qe(e?.getValue("specular")?.clone() ?? 1118481);
                    break;
                case "Physical":
                    t.roughness = new ve(e?.getValue("roughness") ?? .3), t.metalness = new ve(e?.getValue("metalness") ?? 0), t.reflectivity = new ve(e?.getValue("reflectivity") ?? .5);
                    break;
                default:
                    break
            }
            Object.keys(t).forEach(i => {
                this._material[i] = t[i], r.uniforms[`f${r.id}_${i}`] = t[i]
            })
        }
        clone(e) {
            return new ar(e).copy(this)
        }
        toJSON(e) {
            return {
                id: this.id,
                uuid: this.uuid,
                head: this.head.toJSON(e)
            }
        }
        fromJSON(e, t, r) {
            let i = new _t(e.head.id, {
                    type: e.head.type
                }).fromJSON(e.head, t),
                s = e.head.next,
                o = i;
            for (; s != null;) o.next = new _t(s.id, {
                type: s.type
            }).fromJSON(s, t), s = s.next, o = o.next;
            this._layerNodes = [], this.head = void 0, this.rebuildLayerNodes(this.head, i, !0);
            let l = i;
            for (o = this.head; l.next != null;) this.rebuildLayerNodes(o, l.next, !0), o = o.next, l = l.next;
            return this._material = r, this.id = e.id, this.uuid = e.uuid, this.blendColors(), this.blendAfterColors(), this.blendPositions(), this
        }
        getLightLayer() {
            let e = this.head;
            for (; e !== void 0 && e.type !== "light";) e = e.next ?? e;
            return e
        }
        dispose() {
            let e = this.head;
            for (this._layerNodes = [], this.layerCount = 0; e !== void 0;) e.hasOwnProperty("dispose") === !0 && e.dispose(), e = e.next;
            this.head = void 0
        }
        _createLayer(e) {
            let t = e.type;
            switch (t) {
                case pt.COLOR: {
                    let r = new qe(e.color ?? 5855577),
                        i = new ve(e.alpha ?? 1),
                        s = new Ye("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
                    s.keywords.alpha = i;
                    let o = new Qe(e.mode ?? 0);
                    return r.alpha = i, {
                        layer: new _t(e.id, {
                            type: t,
                            color: r,
                            alpha: i,
                            calpha: s,
                            mode: o
                        }),
                        color: r,
                        alpha: s,
                        mode: o
                    }
                }
                case pt.TEXTURE: {
                    let r = e.texture ?? new zi,
                        i = r.matrix;
                    e.mat && i.copy(e.mat), r.needsUpdate = !0;
                    let s = new ve(e.crop ?? 0),
                        o = new Qe(e.projection ?? 0),
                        l = new Qe(e.axis ?? 0),
                        a = new ve(e.alpha ?? 1),
                        c = new Qe(e.mode ?? 0),
                        f = new yr(r),
                        h = new gr(e.textureSize ?? new at.Vector3(r.image ? r.image.width : 0, r.image ? r.image.height : 0)),
                        m = new ps(f, h, s, o, l, a, c),
                        v = new Ye(m.calpha, "f");
                    return {
                        layer: new _t(e.id, {
                            type: t,
                            texture: f,
                            textureSize: h,
                            crop: s,
                            projection: o,
                            axis: l,
                            mat: m.mat,
                            alpha: a,
                            calpha: v,
                            mode: c
                        }),
                        color: m,
                        alpha: v,
                        mode: c
                    }
                }
                case pt.MATCAP: {
                    let r = new qe(e.color ?? 16777215),
                        i = e.texture ?? new zi;
                    i.needsUpdate = !0;
                    let s = new ve(e.alpha ?? 1),
                        o = new yr(i),
                        l = new Qe(e.mode ?? 0),
                        a = new Cs(r, o, s, l),
                        c = new Ye(a.calpha, "f");
                    return {
                        layer: new _t(e.id, {
                            type: t,
                            texture: o,
                            color: r,
                            alpha: s,
                            calpha: c,
                            mode: l
                        }),
                        color: a,
                        alpha: c,
                        mode: l
                    }
                }
                case pt.FRESNEL: {
                    let r = new qe(e.color ?? 16777215),
                        i = new ve(e.bias ?? .1),
                        s = new ve(e.scale ?? 1),
                        o = new ve(e.intensity ?? 2),
                        l = new ve(e.factor ?? 1),
                        a = new ve(e.alpha ?? 1),
                        c = new Qe(e.mode ?? 0),
                        f = new gs(r, i, s, o, l, a, c),
                        h = new Ye(f.calpha, "f");
                    return {
                        layer: new _t(e.id, {
                            type: t,
                            color: r,
                            bias: i,
                            scale: s,
                            intensity: o,
                            factor: l,
                            alpha: a,
                            calpha: h,
                            mode: c
                        }),
                        color: f,
                        alpha: h,
                        mode: c
                    }
                }
                case pt.RAINBOW: {
                    let r = new ve(e.filmThickness ?? 30),
                        i = new ve(e.movement ?? 0),
                        s = new gr(e.wavelengths ?? new at.Vector3(0, 0, 0)),
                        o = new ve(e.noiseStrength ?? 0),
                        l = new ve(e.noiseScale ?? 1),
                        a = new gr(e.offset ?? new at.Vector3(0, 0, 0)),
                        c = new ve(e.alpha ?? 1),
                        f = new ys(r, i, s, o, l, a, c),
                        h = new Ye(f.calpha, "f"),
                        m = new Qe(e.mode ?? 0);
                    return {
                        layer: new _t(e.id, {
                            type: t,
                            filmThickness: r,
                            movement: i,
                            wavelengths: s,
                            noiseStrength: o,
                            noiseScale: l,
                            offset: a,
                            alpha: c,
                            calpha: h,
                            mode: m
                        }),
                        color: f,
                        alpha: h,
                        mode: m
                    }
                }
                case pt.DEPTH: {
                    let r = new ve(e.near ?? 700),
                        i = new ve(e.far ?? 1e3),
                        s = new ve(e.isVector ?? 0),
                        o = new gr(e.origin ?? new at.Vector3),
                        l = new qe(e.colorA ?? new at.Color),
                        a = new qe(e.colorB ?? new at.Color(0, 0, 0)),
                        c = new ve(e.alpha ?? 1),
                        f = new Qe(e.mode ?? 0),
                        h = new Ye("alpha / clamp(alpha + accumAlpha, 0.001, 1.0 )", "f");
                    h.keywords.alpha = c;
                    let m = new Ns(r, i, s, o, l, a, c);
                    return {
                        layer: new _t(e.id, {
                            type: t,
                            near: r,
                            far: i,
                            isVector: s,
                            origin: o,
                            colorA: l,
                            colorB: a,
                            alpha: c,
                            calpha: h,
                            mode: f
                        }),
                        color: m,
                        alpha: h,
                        mode: f
                    }
                }
                case pt.NOISE: {
                    let r = new ve(e.scale ?? 2),
                        i = new ve(e.move ?? 1),
                        s = new ei(e.fA ?? new at.Vector2(1.7, 9.2)),
                        o = new ei(e.fB ?? new at.Vector2(8.3, 2.8)),
                        l = new ei(e.distortion ?? new at.Vector2(1, 1)),
                        a = new qe(e.colorA ?? new at.Color(.4, .4, .4)),
                        c = new qe(e.colorB ?? new at.Color(.4, .4, .4)),
                        f = new qe(e.colorC ?? new at.Color(1, 1, 1)),
                        h = new qe(e.colorD ?? new at.Color(1, 1, 1)),
                        m = new ve(e.intA ?? 1),
                        v = new ve(e.intB ?? 1),
                        g = new ve(e.intC ?? 1),
                        y = new ve(e.intD ?? 1),
                        A = new ve(e.alpha ?? 1),
                        w = new Qe(e.mode ?? 0),
                        C = new Qe(e.noiseType ?? 0),
                        S = new Ye("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
                    S.keywords.alpha = A;
                    let E = new bs(r, i, s, o, l, a, c, f, h, m, v, g, y, A, C);
                    return {
                        layer: new _t(e.id, {
                            type: t,
                            scale: r,
                            move: i,
                            fA: s,
                            fB: o,
                            distortion: l,
                            colorA: a,
                            colorB: c,
                            colorC: f,
                            colorD: h,
                            intA: m,
                            intB: v,
                            intC: g,
                            intD: y,
                            alpha: A,
                            calpha: S,
                            mode: w,
                            noiseType: C
                        }),
                        color: E,
                        alpha: S,
                        mode: w
                    }
                }
                case pt.NORMAL: {
                    let r = new gr(e.cnormal ?? new at.Vector3(1, 1, 1)),
                        i = new ve(e.alpha ?? 1),
                        s = new Qe(e.mode ?? 0),
                        o = new xs(r, i),
                        l = new Ye("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
                    return l.keywords.alpha = i, {
                        layer: new _t(e.id, {
                            type: t,
                            cnormal: r,
                            alpha: i,
                            calpha: l,
                            mode: s
                        }),
                        color: o,
                        alpha: l,
                        mode: s
                    }
                }
                case pt.GRADIENT: {
                    let r = new Qe(e.gl_type ?? 0),
                        i = new Qe(e.num ?? 2),
                        s = new wo(e.smooth ?? !1),
                        o;
                    e.colors ? o = new fs(e.colors.length, e.colors) : (o = new fs(10, new at.Vector4(0, 0, 0, 1)), o.value[1] = new at.Vector4(1, 1, 1, 1));
                    let l;
                    e.steps ? l = new ds(e.steps.length, e.steps) : (l = new ds(10, 1), l.value[0] = 0);
                    let a = new ei(e.offset ?? new at.Vector2(0, 0)),
                        c = new ei(e.morph ?? new at.Vector2(0, 0)),
                        f = new ve(e.angle ?? 0),
                        h = new ve(e.alpha ?? 1),
                        m = new Qe(e.mode ?? 0),
                        v = new As(r, i, s, o, l, a, c, f, h),
                        g = new Ye(v.calpha, "f");
                    return {
                        layer: new _t(e.id, {
                            type: t,
                            gl_type: r,
                            num: i,
                            smooth: s,
                            colors: o,
                            steps: l,
                            offset: a,
                            morph: c,
                            angle: f,
                            alpha: h,
                            calpha: g,
                            mode: m
                        }),
                        color: v,
                        alpha: g,
                        mode: m
                    }
                }
                case pt.DISPLACE: {
                    let r = new Qe(e.displacementType ?? 0);
                    if (r.value === 0) {
                        let i = new gr(e.offset ?? new at.Vector3(0, 0, 0)),
                            s = new ve(e.scale ?? 10),
                            o = new ve(e.intensity ?? 8),
                            l = new ve(e.movement ?? 1),
                            a = new ve(e.alpha ?? 1),
                            c = new Qe(e.mode ?? 0),
                            f = new Qe(e.noiseType ?? 0),
                            h = new _n(r, o, l, i, s, f);
                        return {
                            layer: new _t(e.id, {
                                displacementType: r,
                                type: t,
                                offset: i,
                                scale: s,
                                intensity: o,
                                movement: l,
                                alpha: a,
                                mode: c,
                                noiseType: f
                            }),
                            position: h
                        }
                    } else if (r.value === 1) {
                        let i = e.texture ?? new zi,
                            s = i.matrix;
                        e.mat && s.copy(e.mat), i.needsUpdate = !0;
                        let o = new ve(e.intensity ?? 8),
                            l = new yr(i),
                            a = new ve(e.crop ?? 0),
                            c = new ve(e.alpha ?? 1),
                            f = new Qe(e.mode ?? 0),
                            h = new _n(r, o, l, a);
                        return {
                            layer: new _t(e.id, {
                                displacementType: r,
                                type: t,
                                intensity: o,
                                texture: l,
                                crop: a,
                                mat: h.mat,
                                alpha: c,
                                mode: f
                            }),
                            position: h
                        }
                    }
                    return {}
                }
            }
            return {}
        }
        blendColors() {
            let e = this._layerNodes.findIndex(r => r.type === Ct.COLOR),
                t = this._layerNodes.findIndex(r => r.type === Ct.LIGHTING);
            if (e !== -1 && e < t) {
                let r = this._layerNodes[e].color;
                for (let i = e + 1; i < t; ++i) {
                    let s = this._layerNodes[i];
                    s.type === Ct.COLOR && (r = new Ss(r, s.color, s.alpha, s.mode))
                }
                this._material.color = r
            } else this._material.color = void 0
        }
        blendAfterColors() {
            let e = new Ye("outgoingLight", "f"),
                t = this._layerNodes.findIndex(r => r.type === Ct.LIGHTING);
            if (this._layerNodes.length > t + 1) {
                for (let r = t + 1; r < this._layerNodes.length; ++r) {
                    let i = this._layerNodes[r];
                    i.type === Ct.COLOR && (e = new Ss(e, i.color, i.alpha, i.mode))
                }
                "afterColor" in this._material && (this._material.afterColor = e)
            } else "afterColor" in this._material && (this._material.afterColor = void 0)
        }
        blendPositions() {
            let e = this._layerNodes.filter(t => t.type === Ct.POSITION);
            if (e.length > 0) {
                let t = e[0].position;
                for (let r = 1; r < e.length; ++r) e[r] && (t = new or(t, e[r].position, or.ADD), t = new or(t, new ve(.5).setReadonly(!0), or.MUL));
                this._material.position = t
            } else this._material.position = void 0
        }
        cleanupChangedLayer(e) {
            switch (this._layerNodes = this._layerNodes.filter(t => t.id !== e.id), e.type) {
                case pt.DISPLACE: {
                    this.blendPositions();
                    break
                }
                default: {
                    this.blendColors(), this.blendAfterColors();
                    break
                }
            }
        }
    };
    var Ms = W(J());
    var Dr = W(J());
    var ol = class {
        constructor(e) {
            e = e ?? {}, this.name = e.name, this.type = e.type, this.node = e.node, this.size = e.size, this.needsUpdate = e.needsUpdate
        }
        get value() {
            return this.node.value
        }
        set value(e) {
            this.node.value = e
        }
    };
    var iu = W(J());
    var No = class extends At {
        constructor(e = 0, t, r, i) {
            super("v4");
            this.nodeType = "Vector4";
            this.value = e instanceof iu.Vector4 ? e : new iu.Vector4(e, t, r, i)
        }
        get x() {
            return this.value.x
        }
        set x(e) {
            this.value.x = e
        }
        get y() {
            return this.value.y
        }
        set y(e) {
            this.value.y = e
        }
        get z() {
            return this.value.z
        }
        set z(e) {
            this.value.z = e
        }
        get w() {
            return this.value.w
        }
        set w(e) {
            this.value.w = e
        }
        generateReadonly(e, t, r, i, s, o) {
            return e.format("vec4(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ", " + this.value.w + ")", i, t)
        }
        copy(e) {
            return super.copy(e), this.value.copy(e.value), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.x = this.value.x, t.y = this.value.y, t.z = this.value.z, t.w = this.value.w, this.getReadonly() === !0 && (t.readonly = !0)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.x && (this.value.x = e.x), e.y && (this.value.y = e.y), e.z && (this.value.z = e.z), e.w && (this.value.w = e.w), e.readonly !== void 0 && (this.readonly = e.readonly), this
        }
    };
    var jx = new RegExp(`^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`, "gim"),
        Vx = new RegExp("s*(w*?)s*(w*?)(=|;)", "gim"),
        In = class extends _e {
            constructor(e = "") {
                super();
                this.inputs = [];
                this.src = "";
                this.nodeType = "Struct";
                this.parse(e)
            }
            getType(e) {
                return e.getTypeByFormat(this.name)
            }
            getInputByName(e) {
                let t = this.inputs.length;
                for (; t--;)
                    if (this.inputs[t].name === e) return this.inputs[t]
            }
            generate(e, t, r, i, s) {
                return t === "source" ? this.src + ";" : e.format("( " + this.src + " )", this.getType(e), t)
            }
            parse(e = "") {
                this.src = e, this.inputs = [];
                let t = jx.exec(e);
                if (t) {
                    let r = t[2],
                        i;
                    for (; i = Vx.exec(r);) this.inputs.push({
                        type: i[1],
                        name: i[2]
                    });
                    this.name = t[1]
                } else this.name = "";
                this.type = this.name
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.src = this.src), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.src && (this.src = e.src, this.parse(this.src)), this
            }
        };
    var al = class extends _e {
        constructor(e, t) {
            super();
            this.inputs = [];
            this.nodeType = "FunctionCall";
            this.value = e, this.inputs = t ?? []
        }
        getFunction() {
            return this.value
        }
        getType(e) {
            return this.value.getType(e)
        }
        generate(e, t, r, i, s) {
            i = this.getType(e);
            let o = this.value,
                l = o.build(e, t) + "( ",
                a = [];
            if (o.inputs) {
                for (let c = 0; c < o.inputs.length; c++) {
                    let f = o.inputs[c],
                        h = this.inputs[c] || this.inputs[f.name];
                    a.push(h.build(e, e.getTypeByFormat(f.type)))
                }
                l += a.join(", ") + " )"
            }
            return e.format(l, i, t)
        }
        copy(e) {
            return super.copy(e), this.value.copy(e.value), this.inputs = e.inputs.map(t => t.clone()), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            if (!t) {
                let r = this.value;
                if (t = this.createJSONNode(e), t.value = this.value.toJSON(e).uuid, r.inputs?.length) {
                    t.inputs = {};
                    for (let i = 0; i < r.inputs.length; i++) {
                        let s = r.inputs[i],
                            o = this.inputs[i];
                        t.inputs[s.name] = o.toJSON(e).uuid
                    }
                }
            }
            return t
        }
    };
    var He;
    (function(F) {
        F.RAD = "radians", F.DEG = "degrees", F.EXP = "exp", F.EXP2 = "exp2", F.LOG = "log", F.LOG2 = "log2", F.SQRT = "sqrt", F.INV_SQRT = "inversesqrt", F.FLOOR = "floor", F.CEIL = "ceil", F.NORMALIZE = "normalize", F.FRACT = "fract", F.SATURATE = "saturate", F.SIN = "sin", F.COS = "cos", F.TAN = "tan", F.ASIN = "asin", F.ACOS = "acos", F.ARCTAN = "atan", F.ABS = "abs", F.SIGN = "sign", F.LENGTH = "length", F.NEGATE = "negate", F.INVERT = "invert", F.MIN = "min", F.MAX = "max", F.MOD = "mod", F.STEP = "step", F.REFLECT = "reflect", F.DISTANCE = "distance", F.DOT = "dot", F.CROSS = "cross", F.POW = "pow", F.MIX = "mix", F.CLAMP = "clamp", F.REFRACT = "refract", F.SMOOTHSTEP = "smoothstep", F.FACEFORWARD = "faceforward"
    })(He || (He = {}));
    var ht = class extends _e {
            constructor(e = new we, t = ht.ABS, r, i) {
                super();
                this.nodeType = "Math";
                this.a = e, typeof t != "string" ? this.b = t : i = t, typeof r != "string" ? this.c = r : i = r, this.method = i, this.hashProperties = ["method"]
            }
            getNumInputs(e) {
                switch (this.method) {
                    case ht.MIX:
                    case ht.CLAMP:
                    case ht.REFRACT:
                    case ht.SMOOTHSTEP:
                    case ht.FACEFORWARD:
                        return 3;
                    case ht.MIN:
                    case ht.MAX:
                    case ht.MOD:
                    case ht.STEP:
                    case ht.REFLECT:
                    case ht.DISTANCE:
                    case ht.DOT:
                    case ht.CROSS:
                    case ht.POW:
                        return 2;
                    default:
                        return 1
                }
            }
            getInputType(e) {
                let t = e.getTypeLength(this.a.getType(e)),
                    r = this.b ? e.getTypeLength(this.b.getType(e)) : 0,
                    i = this.c ? e.getTypeLength(this.c.getType(e)) : 0;
                return t > r && t > i ? this.a.getType(e) : r > i ? this.b.getType(e) : this.c.getType(e)
            }
            getType(e) {
                switch (this.method) {
                    case ht.LENGTH:
                    case ht.DISTANCE:
                    case ht.DOT:
                        return "f";
                    case ht.CROSS:
                        return "v3"
                }
                return this.getInputType(e)
            }
            generate(e, t) {
                let r, i, s, o = this.a ? e.getTypeLength(this.a.getType(e)) : 0,
                    l = this.b ? e.getTypeLength(this.b.getType(e)) : 0,
                    a = this.c ? e.getTypeLength(this.c.getType(e)) : 0,
                    c = this.getInputType(e),
                    f = this.getType(e);
                switch (this.type = f, this.method) {
                    case ht.NEGATE:
                        return e.format("( -" + this.a.build(e, c) + " )", c, t);
                    case ht.INVERT:
                        return e.format("( 1.0 - " + this.a.build(e, c) + " )", c, t);
                    case ht.CROSS:
                        r = this.a.build(e, "v3"), i = this.b.build(e, "v3");
                        break;
                    case ht.STEP:
                        r = this.a.build(e, o === 1 ? "f" : c), i = this.b.build(e, c);
                        break;
                    case ht.MIN:
                    case ht.MAX:
                    case ht.MOD:
                        r = this.a.build(e, c), i = this.b.build(e, l === 1 ? "f" : c);
                        break;
                    case ht.REFRACT:
                        r = this.a.build(e, c), i = this.b.build(e, c), s = this.c.build(e, "f");
                        break;
                    case ht.MIX:
                        r = this.a.build(e, c), i = this.b.build(e, c), s = this.c.build(e, a === 1 ? "f" : c);
                        break;
                    default:
                        r = this.a.build(e, c), this.b && (i = this.b.build(e, c)), this.c && (s = this.c.build(e, c));
                        break
                }
                let h = [];
                h.push(r), i && h.push(i), s && h.push(s);
                let m = this.getNumInputs(e);
                if (h.length !== m) throw Error(`Arguments not match used in "${this.method}". Require ${m}, currently ${h.length}.`);
                return e.format(this.method + "( " + h.join(", ") + " )", f, t)
            }
            copy(e) {
                return super.copy(e), this.a.copy(e.a), this.b = e.b instanceof we ? e.b.clone() : e.b, this.c = e.c instanceof we ? e.c.clone() : e.c, this.method = e.method, this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.a = this.a.toJSON(e).uuid, this.b && (t.b = this.b.toJSON(e).uuid), this.c && (t.c = this.c.toJSON(e).uuid), t.method = this.method), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.a && (this.a = t.getNode(e.a)), e.b && (this.b = t.getNode(e.b)), e.c && (this.c = t.getNode(e.c)), e.method && (this.method = e.method), this
            }
        },
        Pe = ht;
    Pe.RAD = He.RAD, Pe.DEG = He.DEG, Pe.EXP = He.EXP, Pe.EXP2 = He.EXP2, Pe.LOG = He.LOG, Pe.LOG2 = He.LOG2, Pe.SQRT = He.SQRT, Pe.INV_SQRT = He.INV_SQRT, Pe.FLOOR = He.FLOOR, Pe.CEIL = He.CEIL, Pe.NORMALIZE = He.NORMALIZE, Pe.FRACT = He.FRACT, Pe.SATURATE = He.SATURATE, Pe.SIN = He.SIN, Pe.COS = He.COS, Pe.TAN = He.TAN, Pe.ASIN = He.ASIN, Pe.ACOS = He.ACOS, Pe.ARCTAN = He.ARCTAN, Pe.ABS = He.ABS, Pe.SIGN = He.SIGN, Pe.LENGTH = He.LENGTH, Pe.NEGATE = He.NEGATE, Pe.INVERT = He.INVERT, Pe.MIN = He.MIN, Pe.MAX = He.MAX, Pe.MOD = He.MOD, Pe.STEP = He.STEP, Pe.REFLECT = He.REFLECT, Pe.DISTANCE = He.DISTANCE, Pe.DOT = He.DOT, Pe.CROSS = He.CROSS, Pe.POW = He.POW, Pe.MIX = He.MIX, Pe.CLAMP = He.CLAMP, Pe.REFRACT = He.REFRACT, Pe.SMOOTHSTEP = He.SMOOTHSTEP, Pe.FACEFORWARD = He.FACEFORWARD;
    var Ts = class extends _e {
            constructor(e = new we, t = new we, r = new we) {
                super("v4");
                this.nodeType = "TextureCubeUV";
                this.value = e, this.uv = t, this.bias = r
            }
            bilinearCubeUV(e, t, r, i) {
                let s = new al(Ts.Nodes.bilinearCubeUV, [t, r, i]);
                this.colorSpaceTL = this.colorSpaceTL ?? new St(new Ye("", "v4")), this.colorSpaceTL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTL.input.parse(s.build(e) + ".tl"), this.colorSpaceTR = this.colorSpaceTR ?? new St(new Ye("", "v4")), this.colorSpaceTR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTR.input.parse(s.build(e) + ".tr"), this.colorSpaceBL = this.colorSpaceBL ?? new St(new Ye("", "v4")), this.colorSpaceBL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBL.input.parse(s.build(e) + ".bl"), this.colorSpaceBR = this.colorSpaceBR ?? new St(new Ye("", "v4")), this.colorSpaceBR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBR.input.parse(s.build(e) + ".br");
                let o = {
                    include: e.isShader("vertex"),
                    ignoreCache: !0
                };
                e.addContext(o), this.colorSpaceTLExp = new Ye(this.colorSpaceTL.build(e, "v4"), "v4"), this.colorSpaceTRExp = new Ye(this.colorSpaceTR.build(e, "v4"), "v4"), this.colorSpaceBLExp = new Ye(this.colorSpaceBL.build(e, "v4"), "v4"), this.colorSpaceBRExp = new Ye(this.colorSpaceBR.build(e, "v4"), "v4"), e.removeContext();
                let l = new Ye("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )", "v4");
                return l.keywords.cubeUV_TL = this.colorSpaceTLExp, l.keywords.cubeUV_TR = this.colorSpaceTRExp, l.keywords.cubeUV_BL = this.colorSpaceBLExp, l.keywords.cubeUV_BR = this.colorSpaceBRExp, l.keywords.cubeUV = s, l
            }
            generate(e, t) {
                if (e.isShader("fragment")) {
                    let r = this.uv,
                        i = this.bias || e.context.roughness,
                        s = new al(Ts.Nodes.roughnessToMip, [i]),
                        o = new Pe(s, Ts.Nodes.m0, Ts.Nodes.cubeUV_maxMipLevel, Pe.CLAMP),
                        l = new Pe(o, Pe.FLOOR),
                        a = new Pe(o, Pe.FRACT),
                        c = this.bilinearCubeUV(e, this.value, r, l),
                        f = this.bilinearCubeUV(e, this.value, r, new or(l, new ve(1).setReadonly(!0), or.ADD)),
                        h = new Pe(c, f, a, Pe.MIX);
                    return e.format(h.build(e), "v4", t)
                } else return console.warn("TextureCubeUVNode is not compatible with " + e.shader + " shader."), e.format("vec4( 0.0 )", this.getType(e), t)
            }
            copy(e) {
                return super.copy(e), this.uv.copy(e.uv), this.bias.copy(e.bias), this.value.copy(e.value), e.colorSpaceTL ? this.colorSpaceTL ? this.colorSpaceTL.copy(e.colorSpaceTL) : this.colorSpaceTL = e.colorSpaceTL.clone() : this.colorSpaceTL = void 0, e.colorSpaceTR ? this.colorSpaceTR ? this.colorSpaceTR.copy(e.colorSpaceTR) : this.colorSpaceTR = e.colorSpaceTR.clone() : this.colorSpaceTR = void 0, e.colorSpaceBL ? this.colorSpaceBL ? this.colorSpaceBL.copy(e.colorSpaceBL) : this.colorSpaceBL = e.colorSpaceBL.clone() : this.colorSpaceBL = void 0, e.colorSpaceBR ? this.colorSpaceBR ? this.colorSpaceBR.copy(e.colorSpaceBR) : this.colorSpaceBR = e.colorSpaceBR.clone() : this.colorSpaceBR = void 0, e.colorSpaceTLExp ? this.colorSpaceTLExp ? this.colorSpaceTLExp.copy(e.colorSpaceTLExp) : this.colorSpaceTLExp = e.colorSpaceTLExp.clone() : this.colorSpaceTLExp = void 0, e.colorSpaceTRExp ? this.colorSpaceTRExp ? this.colorSpaceTRExp.copy(e.colorSpaceTRExp) : this.colorSpaceTRExp = e.colorSpaceTRExp.clone() : this.colorSpaceTRExp = void 0, e.colorSpaceBLExp ? this.colorSpaceBLExp ? this.colorSpaceBLExp.copy(e.colorSpaceBLExp) : this.colorSpaceBLExp = e.colorSpaceBLExp.clone() : this.colorSpaceBLExp = void 0, e.colorSpaceBRExp ? this.colorSpaceBRExp ? this.colorSpaceBRExp.copy(e.colorSpaceBRExp) : this.colorSpaceBRExp = e.colorSpaceBRExp.clone() : this.colorSpaceBRExp = void 0, this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.value = this.value.toJSON(e).uuid, t.uv = this.uv.toJSON(e).uuid, t.bias = this.bias.toJSON(e).uuid, this.colorSpaceTL && this.colorSpaceTL.toJSON(e).uuid, this.colorSpaceTR && this.colorSpaceTR.toJSON(e).uuid, this.colorSpaceBL && this.colorSpaceBL.toJSON(e).uuid, this.colorSpaceBR && this.colorSpaceBR.toJSON(e).uuid, this.colorSpaceTLExp && this.colorSpaceTLExp.toJSON(e).uuid, this.colorSpaceTRExp && this.colorSpaceTRExp.toJSON(e).uuid, this.colorSpaceBLExp && this.colorSpaceBLExp.toJSON(e).uuid, this.colorSpaceBRExp && this.colorSpaceBRExp.toJSON(e).uuid), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.value && (this.value = t.getNode(e.value)), e.uv && (this.uv = t.getNode(e.uv)), e.bias && (this.bias = t.getNode(e.bias)), e.colorSpaceTL && (this.colorSpaceTL = t.getNode(e.colorSpaceTL)), e.colorSpaceTR && (this.colorSpaceTR = t.getNode(e.colorSpaceTR)), e.colorSpaceBL && (this.colorSpaceBL = t.getNode(e.colorSpaceBL)), e.colorSpaceBR && (this.colorSpaceBR = t.getNode(e.colorSpaceBR)), e.colorSpaceTLExp && (this.colorSpaceTLExp = t.getNode(e.colorSpaceTLExp)), e.colorSpaceTRExp && (this.colorSpaceTRExp = t.getNode(e.colorSpaceTRExp)), e.colorSpaceBLExp && (this.colorSpaceBLExp = t.getNode(e.colorSpaceBLExp)), e.colorSpaceBRExp && (this.colorSpaceBRExp = t.getNode(e.colorSpaceBRExp)), this
            }
        },
        Ln = Ts;
    Ln.Nodes = function() {
        let e = new In(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`),
            t = new Ve("float cubeUV_maxMipLevel 8.0", !0),
            r = new Ve("float cubeUV_minMipLevel 4.0", !0),
            i = new Ve("float cubeUV_maxTileSize 256.0", !0),
            s = new Ve("float cubeUV_minTileSize 16.0", !0),
            o = new xe(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`);
        o.useKeywords = !1;
        let l = new xe(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`);
        l.useKeywords = !1;
        let a = new xe(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`, [e, o, l, t, r, i, s]);
        a.useKeywords = !1;
        let c = new Ve("float r0 1.0", !0),
            f = new Ve("float v0 0.339", !0),
            h = new Ve("float m0 -2.0", !0),
            m = new Ve("float r1 0.8", !0),
            v = new Ve("float v1 0.276", !0),
            g = new Ve("float m1 -1.0", !0),
            y = new Ve("float r4 0.4", !0),
            A = new Ve("float v4 0.046", !0),
            w = new Ve("float m4 2.0", !0),
            C = new Ve("float r5 0.305", !0),
            S = new Ve("float v5 0.016", !0),
            E = new Ve("float m5 3.0", !0),
            M = new Ve("float r6 0.21", !0),
            L = new Ve("float v6 0.0038", !0),
            I = new Ve("float m6 4.0", !0),
            z = [c, f, h, m, v, g, y, A, w, C, S, E, M, L, I],
            O = new xe(`float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`, z);
        return {
            bilinearCubeUV: a,
            roughnessToMip: O,
            m0: h,
            cubeUV_maxMipLevel: t
        }
    }();
    var Dn = class extends _e {
            constructor(e) {
                super("v3");
                this.nodeType = "Normal";
                this.scope = e ?? Dn.VIEW
            }
            getShared() {
                return this.scope === Dn.WORLD
            }
            build(e, t, r, i) {
                let s = e.context[this.scope + "Normal"];
                return s ? s.build(e, t, r, i) : super.build(e, t, r)
            }
            generate(e, t, r, i, s) {
                let o;
                switch (this.scope) {
                    case Dn.VIEW:
                        e.isShader("vertex") ? o = "transformedNormal" : o = "geometryNormal";
                        break;
                    case Dn.LOCAL:
                        e.isShader("vertex") ? o = "objectNormal" : (e.requires.normal = !0, o = "vObjectNormal");
                        break;
                    case Dn.WORLD:
                        e.isShader("vertex") ? o = "inverseTransformDirection( transformedNormal, viewMatrix ).xyz" : (e.requires.worldNormal = !0, o = "vWNormal");
                        break
                }
                return e.format(o, this.getType(e), t)
            }
            copy(e) {
                return super.copy(e), this.scope = e.scope, this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.scope = this.scope), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.scope && (this.scope = e.scope), this
            }
        },
        jt = Dn;
    jt.LOCAL = "local", jt.WORLD = "world", jt.VIEW = "view", jt.NORMAL = "normal";
    Ut.addKeyword("viewNormal", function() {
        return new jt(jt.VIEW)
    });
    Ut.addKeyword("localNormal", function() {
        return new jt(jt.NORMAL)
    });
    Ut.addKeyword("worldNormal", function() {
        return new jt(jt.WORLD)
    });
    var Ai = class extends _e {
            constructor(e) {
                super("v3");
                this.nodeType = "Position";
                this.scope = e ?? Ai.LOCAL
            }
            getType() {
                switch (this.scope) {
                    case Ai.PROJECTION:
                        return "v4"
                }
                return this.type
            }
            getShader() {
                switch (this.scope) {
                    case Ai.LOCAL:
                    case Ai.WORLD:
                        return !1
                }
                return !0
            }
            generate(e, t, r, i, s) {
                let o;
                switch (this.scope) {
                    case Ai.LOCAL:
                        e.isShader("vertex") ? o = "transformed" : (e.requires.position = !0, o = "vPosition");
                        break;
                    case Ai.WORLD:
                        if (e.isShader("vertex")) return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz";
                        e.requires.worldPosition = !0, o = "vWPosition";
                        break;
                    case Ai.VIEW:
                        o = e.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition";
                        break;
                    case Ai.PROJECTION:
                        o = e.isShader("vertex") ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )" : "vec4( 0.0 )";
                        break
                }
                return e.format(o, this.getType(), t)
            }
            copy(e) {
                return super.copy(e), this.scope = e.scope, this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.scope = this.scope), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.scope && (this.scope = e.scope), this
            }
        },
        Qt = Ai;
    Qt.LOCAL = "local", Qt.WORLD = "world", Qt.VIEW = "view", Qt.PROJECTION = "projection";
    Ut.addKeyword("position", function() {
        return new Qt
    });
    Ut.addKeyword("worldPosition", function() {
        return new Qt(Qt.WORLD)
    });
    Ut.addKeyword("viewPosition", function() {
        return new Qt(Qt.VIEW)
    });
    var ri = class extends _e {
            constructor(e) {
                super("v3");
                this.nodeType = "Reflect";
                this.scope = e ?? ri.CUBE
            }
            getUnique(e) {
                return !e.context.viewNormal
            }
            getType() {
                switch (this.scope) {
                    case ri.SPHERE:
                        return "v2"
                }
                return this.type
            }
            generate(e, t) {
                let r = this.getUnique(e);
                if (e.isShader("fragment")) {
                    let i;
                    switch (this.scope) {
                        case ri.VECTOR: {
                            let s = new jt(jt.VIEW),
                                o = e.context.roughness,
                                l = s.build(e, "v3"),
                                a = new Qt(Qt.VIEW).build(e, "v3"),
                                c = o ? o.build(e, "f") : void 0,
                                f = `reflect( -normalize( ${a} ), ${l} )`;
                            c && (f = `normalize( mix( ${f}, ${l}, ${c} * ${c} ) )`);
                            let h = `inverseTransformDirection( ${f}, viewMatrix )`;
                            r ? (e.addNodeCode(`vec3 reflectVec = ${h};`), i = "reflectVec") : i = h;
                            break
                        }
                        case ri.CUBE: {
                            let s = new ri(ri.VECTOR).build(e, "v3"),
                                o = "vec3( -" + s + ".x, " + s + ".yz )";
                            r ? (e.addNodeCode(`vec3 reflectCubeVec = ${o};`), i = "reflectCubeVec") : i = o;
                            break
                        }
                        case ri.SPHERE: {
                            let s = new ri(ri.VECTOR).build(e, "v3"),
                                o = "normalize( ( viewMatrix * vec4( " + s + ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";
                            r ? (e.addNodeCode(`vec2 reflectSphereVec = ${o};`), i = "reflectSphereVec") : i = o;
                            break
                        }
                    }
                    return e.format(i, this.getType(), t)
                } else return console.warn("ReflectNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.type, t)
            }
            copy(e) {
                return super.copy(e), this.scope = e.scope, this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.scope = this.scope), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.scope && (this.scope = e.scope), this
            }
        },
        ti = ri;
    ti.CUBE = "cube", ti.SPHERE = "sphere", ti.VECTOR = "vector";
    var Co = class extends _e {
        constructor(e = new yr, t, r) {
            super("v4");
            this.nodeType = "TextureCube";
            this.value = e, this.radianceNode = new Ln(this.value, t ?? new ti(ti.VECTOR), r), this.irradianceNode = new Ln(this.value, new jt(jt.WORLD), new ve(1).setReadonly(!0))
        }
        generate(e, t) {
            return e.isShader("fragment") ? (e.require("irradiance"), e.context.bias && e.context.bias.setTexture(this.value), (e.slot === "irradiance" ? this.irradianceNode : this.radianceNode).build(e, t)) : (console.warn("TextureCubeNode is not compatible with " + e.shader + " shader."), e.format("vec4( 0.0 )", this.getType(e), t))
        }
        copy(e) {
            return super.copy(e), this.value.copy(e.value), this.radianceNode.copy(e.radianceNode), this.irradianceNode.copy(e.irradianceNode), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.value = this.value.toJSON(e).uuid, this.radianceNode && (t.radianceNode = this.radianceNode.toJSON(e).uuid), this.irradianceNode && (t.irradianceNode = this.irradianceNode.toJSON(e).uuid)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.value && (this.value = t.getNode(e.value)), e.radianceNode && (this.radianceNode = t.getNode(e.radianceNode)), e.irradianceNode && (this.irradianceNode = t.getNode(e.irradianceNode)), this
        }
    };
    var Cd = W(J());
    var To = class extends At {
        constructor(e = new Cd.CubeTexture, t, r) {
            super("v4", {
                shared: !0
            });
            this.nodeType = "CubeTexture";
            this.value = e, this.uv = t ?? new ti, this.bias = r
        }
        getTexture(e, t) {
            return super.generate(e, t, this.value.uuid, "tc")
        }
        generate(e, t) {
            if (t === "samplerCube") return this.getTexture(e, t);
            let r = this.getTexture(e, t),
                i = this.uv?.build(e, "v3"),
                s = this.bias ? this.bias.build(e, "f") : void 0;
            s === void 0 && e.context.bias && (s = e.context.bias.setTexture(this).build(e, "f"));
            let o;
            s ? o = "texCubeBias( " + r + ", " + i + ", " + s + " )" : o = "texCube( " + r + ", " + i + " )";
            let l = {
                    include: e.isShader("vertex"),
                    ignoreCache: !0
                },
                a = this.getType(e);
            return e.addContext(l), this.colorSpace = this.colorSpace ?? new St(new Ye("", a)), this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(o), o = this.colorSpace.build(e, a), e.removeContext(), e.format(o, a, t)
        }
        copy(e) {
            return super.copy(e), this.value.copy(e.value), e.uv ? this.uv ? this.uv.copy(e.uv) : this.uv = e.uv.clone() : this.uv = void 0, e.bias ? this.bias ? this.bias.copy(e.bias) : this.bias = e.bias.clone() : this.bias = void 0, this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), this.value && (t.value = this.value.uuid), t.uv = this.uv?.toJSON(e).uuid, this.bias && (t.bias = this.bias.toJSON(e).uuid)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.value && (this.value = t.getTexture(e.value)), e.uv && (this.uv = t.getNode(e.uv)), e.bias && (this.bias = t.getNode(e.bias)), this
        }
    };
    var Td = ["x", "y", "z", "w"],
        Hx = ["float", "vec2", "vec3", "vec4"],
        Wx = {
            float: "f",
            vec2: "v2",
            vec3: "v3",
            vec4: "v4",
            mat4: "v4",
            int: "i",
            bool: "b",
            "float[]": "f[]",
            "vec4[]": "v4[]"
        },
        Jx = {
            t: "sampler2D",
            tc: "samplerCube",
            b: "bool",
            i: "int",
            f: "float",
            c: "vec3",
            v2: "vec2",
            v3: "vec3",
            v4: "vec4",
            m3: "mat3",
            m4: "mat4",
            "f[]": "float[]",
            "v4[]": "vec4[]"
        },
        nu = class {
            constructor() {
                this.includes = {
                    consts: {},
                    functions: {},
                    structs: {}
                };
                this.cache = "";
                this.slot = "";
                this.shader = "";
                this.context = {};
                this.getIncludesCode = function() {
                    function e(t, r) {
                        return t.deps.length - r.deps.length
                    }
                    return function(r, i) {
                        let s = this.getIncludes(r, i);
                        if (!s) return "";
                        let o = "";
                        s = s.sort(e);
                        for (let l = 0; l < s.length; l++) s[l].src && (o += s[l].src + `
`);
                        return o
                    }
                }();
                this.slots = [], this.caches = [], this.contexts = [], this.keywords = {}, this.nodeData = {}, this.fragmentVariables = {}, this.requires = {
                    uv: [],
                    color: [],
                    lights: !1,
                    fog: !1,
                    transparent: !1,
                    irradiance: !1,
                    position: !1,
                    worldPosition: !1,
                    normal: !1,
                    worldNormal: !1,
                    vWorldViewDir: !1,
                    vWorldNormal: !1
                }, this.includes = {
                    consts: [],
                    functions: [],
                    structs: []
                }, this.attributes = {}, this.prefixCode = ["#ifdef TEXTURE_LOD_EXT", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)", "#else", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCube(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2D(a, b, c)", "#endif", `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`, "#include <packing>", "#include <common>"].join(`
`), this.parsCode = {
                    vertex: ["float neighbor_offset = 0.0001;", ""].join(`
`),
                    fragment: ["float accumAlpha = 0.0;", `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`, ""].join(`
`)
                }, this.code = {
                    vertex: "",
                    fragment: ""
                }, this.nodeCode = {
                    vertex: "",
                    fragment: ""
                }, this.resultCode = {
                    vertex: "",
                    fragment: ""
                }, this.finalCode = {
                    vertex: "",
                    fragment: ""
                }, this.inputs = {
                    uniforms: {
                        list: [],
                        vertex: [],
                        fragment: []
                    },
                    arrayUniforms: {
                        list: [],
                        vertex: [],
                        fragment: []
                    },
                    vars: {
                        varying: [],
                        vertex: [],
                        fragment: []
                    }
                }, this.defines = {}, this.uniforms = {}, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.updaters = [], this.nodes = [], this.analyzing = !1
            }
            build(e, t) {
                this.buildShader("vertex", e), this.buildShader("fragment", t);
                for (let r = 0; r < this.requires.uv.length; r++)
                    if (this.requires.uv[r]) {
                        let i = r > 0 ? r + 1 : "";
                        this.addVaryCode("varying vec2 vUv" + i + ";"), r > 0 && this.addVertexParsCode("attribute vec2 uv" + i + ";"), this.addVertexFinalCode("vUv" + i + " = uv" + i + ";")
                    } return this.requires.color[0] && (this.addVaryCode("varying vec4 vColor;"), this.addVertexParsCode("attribute vec4 color;"), this.addVertexFinalCode("vColor = color;")), this.requires.color[1] && (this.addVaryCode("varying vec4 vColor2;"), this.addVertexParsCode("attribute vec4 color2;"), this.addVertexFinalCode("vColor2 = color2;")), this.requires.position && (this.addVaryCode("varying vec3 vPosition;"), this.addVertexFinalCode("vPosition = transformed;")), this.requires.worldPosition && (this.addVaryCode("varying vec3 vWPosition;"), this.addVertexFinalCode("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;")), this.requires.normal && (this.addVaryCode("varying vec3 vObjectNormal;"), this.addVertexFinalCode("vObjectNormal = normal;")), this.requires.worldNormal && (this.addVaryCode("varying vec3 vWNormal;"), this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")), this.requires.vWorldViewDir && (this.addVaryCode("varying vec3 vWorldViewDir;"), this.addVertexFinalCode("vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );")), this.requires.vWorldNormal && (this.addVaryCode("varying vec3 vWorldNormal;"), this.addVertexFinalCode("vWorldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );")), this
            }
            buildShader(e, t) {
                this.resultCode[e] = t.build(this.setShader(e), "v4")
            }
            setMaterial(e, t) {
                return this.material = e, this.renderer = t, this.requires.lights = e.lights, this.requires.fog = e.fog, this.mergeDefines(e.defines), this
            }
            addFlow(e, t, r) {
                return this.addSlot(e).addCache(t).addContext(r)
            }
            removeFlow() {
                return this.removeSlot().removeCache().removeContext()
            }
            addCache(e) {
                return this.cache = e ?? "", this.caches.push(this.cache), this
            }
            removeCache() {
                return this.caches.pop(), this.cache = this.caches[this.caches.length - 1] || "", this
            }
            addContext(e) {
                return this.context = Object.assign({}, this.context, e), this.context.extra = this.context.extra || {}, this.contexts.push(this.context), this
            }
            removeContext() {
                return this.contexts.pop(), this.context = this.contexts[this.contexts.length - 1] || {}, this
            }
            addSlot(e) {
                return this.slot = e || "", this.slots.push(this.slot), this
            }
            removeSlot() {
                return this.slots.pop(), this.slot = this.slots[this.slots.length - 1] || "", this
            }
            addFragmentVariable(e, t) {
                this.fragmentVariables[e] === void 0 && (this.addFragmentCode(`${t} ${e};`), this.fragmentVariables[e] = "")
            }
            addVertexCode(e) {
                this.addCode(e, "vertex")
            }
            addFragmentCode(e) {
                this.addCode(e, "fragment")
            }
            addCode(e, t) {
                this.code[t ?? this.shader] += e + `
`
            }
            addVertexNodeCode(e) {
                this.addNodeCode(e, "vertex")
            }
            addFragmentNodeCode(e) {
                this.addNodeCode(e, "fragment")
            }
            addNodeCode(e, t) {
                this.nodeCode[t ?? this.shader] += e + `
`
            }
            clearNodeCode(e) {
                e = e ?? this.shader;
                let t = this.nodeCode[e];
                return this.nodeCode[e] = "", t
            }
            clearVertexNodeCode() {
                return this.clearNodeCode("vertex")
            }
            clearFragmentNodeCode() {
                return this.clearNodeCode("fragment")
            }
            addVertexFinalCode(e) {
                this.addFinalCode(e, "vertex")
            }
            addFragmentFinalCode(e) {
                this.addFinalCode(e, "fragment")
            }
            addFinalCode(e, t) {
                this.finalCode[t ?? this.shader] += e + `
`
            }
            addVertexParsCode(e) {
                this.addParsCode(e, "vertex")
            }
            addFragmentParsCode(e) {
                this.addParsCode(e, "fragment")
            }
            addParsCode(e, t) {
                this.parsCode[t ?? this.shader] += e + `
`
            }
            addVaryCode(e) {
                this.addVertexParsCode(e), this.addFragmentParsCode(e)
            }
            isCache(e) {
                return this.caches.indexOf(e) !== -1
            }
            isSlot(e) {
                return this.slots.indexOf(e) !== -1
            }
            define(e, t) {
                this.defines[e] = t === void 0 ? 1 : t
            }
            require(e) {
                this.requires[e] = !0
            }
            isDefined(e) {
                return this.defines[e] !== void 0
            }
            getVar(e, t, r, i = "varying", s = "V", o = "") {
                let l = this.getVars(i),
                    a = l[e];
                if (!a) {
                    let c = l.length;
                    a = {
                        name: r || "node" + s + c + (o ? "_" + o : ""),
                        type: t
                    }, l.push(a), l[e] = a
                }
                return a
            }
            getTempVar(e, t, r, i) {
                return this.getVar(e, t, r, this.shader, "T", i)
            }
            getAttribute(e, t) {
                if (!this.attributes[e]) {
                    let r = this.getVar(e, t);
                    this.addVertexParsCode("attribute " + t + " " + e + ";"), this.addVertexFinalCode(r.name + " = " + e + ";"), this.attributes[e] = {
                        varying: r,
                        name: e,
                        type: t
                    }
                }
                return this.attributes[e]
            }
            getCode(e) {
                return [this.prefixCode, this.parsCode[e], this.getVarListCode(this.getVars("varying"), "varying"), this.getVarListCode(this.inputs.uniforms[e], "uniform"), this.getVarListCode(this.inputs.arrayUniforms[e], "uniform"), this.getIncludesCode("consts", e), this.getIncludesCode("structs", e), this.getIncludesCode("functions", e), "void main() {", this.getVarListCode(this.getVars(e)), this.code[e], this.resultCode[e], this.finalCode[e], "}"].join(`
`)
            }
            getVarListCode(e, t) {
                t = t ?? "";
                let r = "";
                for (let i = 0, s = e.length; i < s; ++i) {
                    let o = e[i],
                        l = o.type,
                        a = o.name,
                        c = o.size,
                        f = this.getFormatByType(l);
                    if (f === void 0) throw new Error("Node pars " + f + " not found.");
                    f.includes("[]") ? r += t + " " + f.substring(0, f.length - 2) + " " + a + `[${c}];
` : r += t + " " + f + " " + a + `;
`
                }
                return r
            }
            getVars(e) {
                return this.inputs.vars[e ?? this.shader]
            }
            getNodeData(e) {
                let t = e instanceof we ? e.uuid : e;
                return this.nodeData[t] = this.nodeData[t] || {}
            }
            createUniform(e, t, r, i, s, o) {
                if (t.includes("[]")) {
                    let l = this.inputs.arrayUniforms,
                        a = l.list.length,
                        c = new ol({
                            type: t,
                            size: r.size,
                            name: i || "nodeUA" + a + (o ? "_" + o : ""),
                            node: r,
                            needsUpdate: s
                        });
                    return l.list.push(c), l[e].push(c), l[e][c.name] = c, this.uniforms[c.name] = c, c
                } else {
                    let l = this.inputs.uniforms,
                        a = l.list.length,
                        c = new ol({
                            type: t,
                            name: i || "nodeU" + a + (o ? "_" + o : ""),
                            node: r,
                            needsUpdate: s
                        });
                    return l.list.push(c), l[e].push(c), l[e][c.name] = c, this.uniforms[c.name] = c, c
                }
            }
            createVertexUniform(e, t, r, i, s) {
                return this.createUniform("vertex", e, t, r, i, s)
            }
            createFragmentUniform(e, t, r, i, s) {
                return this.createUniform("fragment", e, t, r, i, s)
            }
            include(e, t, r) {
                let i;
                if (e = typeof e == "string" ? Ut.get(e) : e, this.context.include === !1) return e.name;
                e instanceof xe ? i = this.includes.functions : e instanceof Ve ? i = this.includes.consts : e instanceof In && (i = this.includes.structs);
                let s = i[this.shader] = i[this.shader] || [];
                if (e) {
                    let o = s[e.name];
                    if (o || (o = s[e.name] = {
                            node: e,
                            deps: []
                        }, s.push(o), o.src = e.build(this, "source")), e instanceof xe && t && s[t.name] && s[t.name].deps.indexOf(e) == -1 && (s[t.name].deps.push(e), e.includes?.length)) {
                        let l = 0;
                        do this.include(e.includes[l++], t); while (l < e.includes.length)
                    }
                    return r && (o.src = r), e.name
                } else throw new Error("Include not found.")
            }
            colorToVectorProperties(e) {
                return e.replace("r", "x").replace("g", "y").replace("b", "z").replace("a", "w")
            }
            colorToVector(e) {
                return e.replace(/c/g, "v3")
            }
            getIncludes(e, t) {
                return this.includes[e][t || this.shader]
            }
            getConstructorFromLength(e) {
                return Hx[e - 1]
            }
            isTypeMatrix(e) {
                return /^m/.test(e)
            }
            getTypeLength(e) {
                return e === "f" ? 1 : parseInt(this.colorToVector(e).substr(1))
            }
            getTypeFromLength(e) {
                return e === 1 ? "f" : "v" + e
            }
            findNode(...e) {
                for (let t = 0; t < arguments.length; t++) {
                    let r = e[t];
                    if (r?.isNode) return r
                }
            }
            resolve(...e) {
                for (let t = 0; t < arguments.length; t++) {
                    let r = e[t];
                    if (r !== void 0) {
                        if (r.isNode) return r;
                        if (r.isTexture) switch (r.mapping) {
                            case Dr.CubeReflectionMapping:
                            case Dr.CubeRefractionMapping:
                                return new To(r);
                            case Dr.CubeUVReflectionMapping:
                            case Dr.CubeUVRefractionMapping:
                                return new Co(new yr(r));
                            default:
                                return new yr(r)
                        } else {
                            if (r.isVector2) return new ei(r);
                            if (r.isVector3) return new gr(r);
                            if (r.isVector4) return new No(r)
                        }
                    }
                }
            }
            format(e, t, r) {
                switch (this.colorToVector(r + " <- " + t)) {
                    case "f <- v2":
                        return e + ".x";
                    case "f <- v3":
                        return e + ".x";
                    case "f <- v4":
                        return e + ".x";
                    case "f <- i":
                    case "f <- b":
                        return "float( " + e + " )";
                    case "v2 <- f":
                        return "vec2( " + e + " )";
                    case "v2 <- v3":
                        return e + ".xy";
                    case "v2 <- v4":
                        return e + ".xy";
                    case "v2 <- i":
                    case "v2 <- b":
                        return "vec2( float( " + e + " ) )";
                    case "v3 <- f":
                        return "vec3( " + e + " )";
                    case "v3 <- v2":
                        return "vec3( " + e + ", 0.0 )";
                    case "v3 <- v4":
                        return e + ".xyz";
                    case "v3 <- i":
                    case "v3 <- b":
                        return "vec2( float( " + e + " ) )";
                    case "v4 <- f":
                        return "vec4( " + e + " )";
                    case "v4 <- v2":
                        return "vec4( " + e + ", 0.0, 1.0 )";
                    case "v4 <- v3":
                        return "vec4( " + e + ", 1.0 )";
                    case "v4 <- i":
                    case "v4 <- b":
                        return "vec4( float( " + e + " ) )";
                    case "i <- f":
                    case "i <- b":
                        return "int( " + e + " )";
                    case "i <- v2":
                        return "int( " + e + ".x )";
                    case "i <- v3":
                        return "int( " + e + ".x )";
                    case "i <- v4":
                        return "int( " + e + ".x )";
                    case "b <- f":
                        return "( " + e + " != 0.0 )";
                    case "b <- v2":
                        return "( " + e + " != vec2( 0.0 ) )";
                    case "b <- v3":
                        return "( " + e + " != vec3( 0.0 ) )";
                    case "b <- v4":
                        return "( " + e + " != vec4( 0.0 ) )";
                    case "b <- i":
                        return "( " + e + " != 0 )"
                }
                return e
            }
            getTypeByFormat(e) {
                return Wx[e] || e
            }
            getFormatByType(e) {
                return Jx[e] || e
            }
            getUUID(e, t) {
                return t = t !== void 0 ? t : !0, t && this.cache && (e = this.cache + "-" + e), e
            }
            getElementByIndex(e) {
                return Td[e]
            }
            getIndexByElement(e) {
                return Td.indexOf(e)
            }
            isShader(e) {
                return this.shader === e
            }
            setShader(e) {
                return this.shader = e, this
            }
            mergeDefines(e) {
                for (let t in e) this.defines[t] = e[t];
                return this.defines
            }
            mergeUniform(e) {
                for (let t in e) this.uniforms[t] = e[t];
                return this.uniforms
            }
            getTextureEncodingFromMap(e) {
                let t;
                return e ? e.isTexture && (t = e.encoding) : t = Dr.LinearEncoding, t === Dr.LinearEncoding && this.context.gamma && (t = Dr.GammaEncoding), t
            }
        };
    var Es = class extends we {
        constructor(e = new we) {
            super("v4");
            this.nodeType = "Raw";
            this.value = e
        }
        generate(e) {
            let t = this.value.analyzeAndFlow(e, this.type),
                r = t.code + `
`;
            return e.isShader("vertex") ? r += "gl_Position = " + t.result + ";" : r += "gl_FragColor = " + t.result + ";", r
        }
        copy(e) {
            return super.copy(e), this.value.copy(e.value), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.value = this.value.toJSON(e).uuid), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.value && (this.value = t.getNode(e.value)), this
        }
    };
    var Gr = class extends Ms.ShaderMaterial {
        constructor(e, t, r) {
            super(r);
            this.isNodeMaterial = !0;
            this.type = "NodeMaterial";
            this.wireframeLinecap = "";
            this.wireframeLinejoin = "";
            this.userData = {
                type: "",
                category: "",
                nodeType: ""
            };
            this.fog = !0, this.vertex = e ?? new Es(new Qt(Qt.PROJECTION)), this.fragment = t ?? new Es(new qe(5855577)), this.updaters = [], this.isDetached = !0, this.dithering = !0, this.onBeforeCompile = this._onBeforeCompile
        }
        getDefines() {
            return this.defines
        }
        getUniforms() {
            return this.uniforms
        }
        getVertexShader() {
            return this.vertexShader
        }
        getFragmentShader() {
            return this.fragmentShader
        }
        _onBeforeCompile(e, t) {
            this.build({
                renderer: t
            }), e.defines = this.defines, e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.extensionDerivatives = this.extensions.derivatives === !0, e.extensionFragDepth = this.extensions.fragDepth === !0, e.extensionDrawBuffers = this.extensions.drawBuffers === !0, e.extensionShaderTextureLOD = this.extensions.shaderTextureLOD === !0
        }
        _getLayerStack(e) {
            let t = new ar(this);
            return e && (async () => {
                for (; e.image === void 0;) await new Promise(r => requestAnimationFrame(r));
                t.addLayerAt(1, {
                    type: pt.TEXTURE,
                    texture: e
                }), this.dispose()
            })(), t
        }
        clampUniformsForPreview() {
            let e = (t, r, i) => Math.min(Math.max(t, r), i);
            if (this.userData.layers)
                for (let t of this.userData.layers.getLayers()) t.type == pt.DISPLACE && (t.uniforms[`${t.id}_intensity`].value = e(t.uniforms[`${t.id}_intensity`].value, -150, 150))
        }
        customProgramCacheKey() {
            return this.getHash()
        }
        updateFrame(e) {
            for (let t = 0; t < this.updaters.length; ++t) e.updateNode(this.updaters[t])
        }
        build(e) {
            e = e ?? {};
            let t = e.builder ?? new nu;
            return t.setMaterial(this, e.renderer), t.build(this.vertex, this.fragment), this.vertexShader = t.getCode("vertex"), this.fragmentShader = t.getCode("fragment"), this.defines = t.defines, this.uniforms = t.uniforms, this.extensions = t.extensions, this.updaters = t.updaters, this.fog = t.requires.fog, this.lights = t.requires.lights, this.transparent = t.requires.transparent || this.blending > Ms.NormalBlending, this
        }
        getHash() {
            let e = "{";
            return e += '"vertex":' + this.vertex.getHash() + ",", e += '"fragment":' + this.fragment.getHash(), e += "}", e
        }
        copy(e) {
            let t = this.uuid;
            for (let r in e) this[r] = e[r];
            return this.uuid = t, e.userData !== void 0 && (this.userData = JSON.parse(JSON.stringify(e.userData))), this
        }
        toJSON(e) {
            let t = this.userData.layers;
            this.userData.layers = void 0;
            let r = super.toJSON(e);
            return r.type = "ShaderMaterial", r.userData = {
                type: this.userData.type,
                category: this.userData.category,
                nodeType: this.type,
                layers: t.toJSON(e)
            }, r.vertex = this.vertex.toJSON(e).uuid, r.fragment = this.fragment.toJSON(e).uuid, delete r.vertexShader, delete r.fragmentShader, delete r.color, delete r.shininess, delete r.specular, delete r.roughness, delete r.metalness, delete r.uniforms, e && !e.materials[this.uuid] && (e.materials[this.uuid] = r), this.userData.layers = t, r
        }
        fromJSON(e, t) {
            this.defines = e.defines ?? {}, this.depthFunc = e.depthFunc, this.depthWrite = e.depthWrite, this.side = e.side !== void 0 ? e.side : Ms.FrontSide, this.transparent = e.transparent, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.wireframe = e.wireframe, this.userData.layers.fromJSON(e.userData.layers, t, this)
        }
    };
    Object.defineProperties(Gr.prototype, {
        properties: {
            get: function() {
                return this.fragment.properties
            }
        },
        needsUpdate: {
            set: function(n) {
                n === !0 && this.version++, this.needsCompile = n
            },
            get: function() {
                return this.needsCompile
            }
        }
    });
    var ll = W(J()),
        Eo = class extends we {
            constructor() {
                super("basic");
                this.nodeType = "Basic";
                this.color = new qe(5855577)
            }
            generate(e) {
                let t;
                if (e.isShader("vertex")) {
                    let r = this.position ? this.position.analyzeAndFlow(e, "v3", {
                        cache: "position"
                    }) : void 0;
                    e.mergeUniform(ll.UniformsUtils.merge([ll.UniformsLib.fog])), e.addParsCode(["varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", " varying vec3 vNormal;", "#endif", "#include <fog_pars_vertex>"].join(`
`));
                    let i = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#ifndef FLAT_SHADED", " vNormal = normalize( transformedNormal );", "#endif", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];
                    r && i.push(r.code, r.result ? "displaced_position = " + r.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "	vNormal = transformedNormal;", "#endif"), i.push("#include <morphtarget_vertex>", "#include <skinning_vertex>", "#include <project_vertex>", "#include <fog_vertex>", "#include <logdepthbuf_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>"), t = i.join(`
`)
                } else {
                    this.color === void 0 && (this.color = new qe(5855577)), this.color.analyze(e, {
                        slot: "color"
                    }), this.alpha && this.alpha.analyze(e), this.mask && this.mask.analyze(e), this.afterColor && this.afterColor.analyze(e, {
                        slot: "afterColor"
                    });
                    let r = this.color.flow(e, "c", {
                            slot: "color"
                        }),
                        i = this.alpha ? this.alpha.flow(e, "f") : void 0,
                        s = this.mask ? this.mask.flow(e, "b") : void 0,
                        o = this.afterColor ? this.afterColor.flow(e, "c", {
                            slot: "afterColor"
                        }) : void 0;
                    e.requires.transparent = i !== void 0, e.addParsCode(["#include <fog_pars_fragment>", "#include <dithering_pars_fragment>", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", " varying vec3 vNormal;", "#endif"].join(`
`));
                    let l = ["#include <normal_fragment_begin>", r.code];
                    s && l.push(s.code, "if ( ! " + s.result + " ) discard;"), i && l.push(i.code, "#ifdef ALPHATEST", " if ( " + i.result + " <= ALPHATEST ) discard;", "#endif"), o ? l.push(o.code, `vec3 outgoingLight = ${r.result};`, `vec3 finalColor = spe_blend(outgoingLight, ${o.result}, 1.0, SPE_BLENDING_NORMAL);`) : l.push(`vec3 finalColor = ${r.result};`), i ? l.push(`gl_FragColor = vec4( finalColor, accumAlpha * ${i.result} );`) : l.push("gl_FragColor = vec4(" + r.result + ", 1.0 );"), l.push("#include <fog_fragment>", "#include <dithering_fragment>"), t = l.join(`
`)
                }
                return t
            }
            copy(e) {
                return super.copy(e), e.color && (this.color = e.color.clone()), e.position && (this.position = e.position.clone()), e.alpha && (this.alpha = e.alpha.clone()), e.mask && (this.mask = e.mask.clone()), e.afterColor && (this.afterColor = e.afterColor.clone()), e.shadingAlpha && (this.shadingAlpha = e.shadingAlpha.clone()), e.shadingBlend && (this.shadingBlend = e.shadingBlend.clone()), this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), this.color && (t.color = this.color.toJSON(e).uuid), this.position && (t.position = this.position.toJSON(e).uuid), this.alpha && (t.alpha = this.alpha.toJSON(e).uuid), this.mask && (t.mask = this.mask.toJSON(e).uuid), this.afterColor && (t.afterColor = this.afterColor.toJSON(e).uuid), this.shadingAlpha && (t.shadingAlpha = this.shadingAlpha.toJSON(e).uuid), this.shadingBlend && (t.shadingBlend = this.shadingBlend.toJSON(e).uuid)), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.position && (this.position = t.getNode(e.position)), e.color && (this.color = t.getNode(e.color)), e.mask && (this.mask = t.getNode(e.mask)), e.alpha && (this.alpha = t.getNode(e.alpha)), e.afterColor && (this.afterColor = t.getNode(e.afterColor)), e.shadingAlpha && (this.shadingAlpha = t.getNode(e.shadingAlpha)), e.shadingBlend && (this.shadingBlend = t.getNode(e.shadingBlend)), this
            }
        };
    var su = class extends Gr {
        get color() {
            return this.fragment.color
        }
        set color(e) {
            this.fragment.color = e
        }
        get afterColor() {
            return this.fragment.afterColor
        }
        set afterColor(e) {
            this.fragment.afterColor = e
        }
        get alpha() {
            return this.fragment.alpha
        }
        set alpha(e) {
            this.fragment.alpha = e
        }
        get shadingAlpha() {
            return this.fragment.shadingAlpha
        }
        set shadingAlpha(e) {
            this.fragment.shadingAlpha = e
        }
        get shadingBlend() {
            return this.fragment.shadingBlend
        }
        set shadingBlend(e) {
            this.fragment.shadingBlend = e
        }
        get mask() {
            return this.fragment.mask
        }
        set mask(e) {
            this.fragment.mask = e
        }
        get position() {
            return this.fragment.position
        }
        set position(e) {
            this.fragment.position = e
        }
        constructor(e = new Eo, t) {
            super(e, e, t);
            this.type = "BasicNodeMaterial", this.fragment = e
        }
    };
    var Pr = class extends su {
        constructor(e, t, r) {
            super(t, e);
            this.userData.type = "BasicMaterial", this.userData.category = "Basic", this.userData.layers = r ?? this._getLayerStack(e?.map)
        }
        get layersList() {
            return this.userData.layers
        }
        set layersList(e) {
            this.userData.layers = e
        }
        equals(e) {
            return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid
        }
        copy(e) {
            if (e.userData.layers !== void 0 && e.userData.layers instanceof ar) {
                let t = e.userData.layers,
                    r = e.fragment;
                super.copy(e);
                let i = r.clone();
                this.fragment = i, this.vertex = i;
                let s = t.clone(this);
                this.userData.layers = s
            } else super.copy(e);
            return this
        }
        static fromJSON(e, t, r) {
            let i = r.getNode(t.vertex),
                s = new Pr(void 0, i);
            return s.fromJSON(t, r), s
        }
        static fromMaterial(e) {
            let t = new Pr(e.map ? {
                    map: e.map
                } : {}),
                r = t.fragment;
            return r.color.value.copy(e.color), r.alpha.value = e.opacity, t
        }
        dispose() {
            super.dispose()
        }
    };
    var Mo = W(J());
    var _o = class extends we {
        constructor() {
            super("phong");
            this.nodeType = "Phong";
            this.color = new qe(5855577), this.specular = new qe(1118481), this.shininess = new ve(30), this.shadingAlpha = new ve(1), this.shadingBlend = new Qe(0)
        }
        build(e) {
            let t;
            if (e.define("PHONG"), e.requires.lights = !0, e.isShader("vertex")) {
                let r = this.position ? this.position.analyzeAndFlow(e, "v3", {
                    cache: "position"
                }) : void 0;
                e.mergeUniform(Mo.UniformsUtils.merge([Mo.UniformsLib.fog, Mo.UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", "#include <fog_pars_vertex>", "#include <morphtarget_pars_vertex>", "#include <skinning_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
                let i = ["#include <beginnormal_vertex>", "#include <morphnormal_vertex>", "#include <skinbase_vertex>", "#include <skinnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
                r && i.push(r.code, r.result ? "displaced_position = " + r.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("	#include <morphtarget_vertex>", "	#include <skinning_vertex>", "	#include <project_vertex>", "	#include <logdepthbuf_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), t = i.join(`
`)
            } else {
                this.mask && this.mask.analyze(e), this.color === void 0 && (this.color = new qe(5855577)), this.color.analyze(e, {
                    slot: "color"
                }), this.specular.analyze(e), this.shininess.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, {
                    slot: "afterColor"
                }), this.alpha && this.alpha.analyze(e), this.normal && this.normal.analyze(e), this.light && this.light.analyze(e, {
                    cache: "light"
                }), this.ao && this.ao.analyze(e), this.ambient && this.ambient.analyze(e), this.shadow && this.shadow.analyze(e), this.emissive && this.emissive.analyze(e, {
                    slot: "emissive"
                }), this.environment && this.environment.analyze(e, {
                    slot: "environment"
                }), this.environmentAlpha && this.environment && this.environmentAlpha.analyze(e);
                let r = this.mask ? this.mask.flow(e, "b") : void 0,
                    i = this.color.flow(e, "c", {
                        slot: "color"
                    }),
                    s = this.specular.flow(e, "c"),
                    o = this.shininess.flow(e, "f"),
                    l = this.shadingAlpha.flow(e, "f"),
                    a = this.shadingBlend.flow(e, "i"),
                    c = this.afterColor ? this.afterColor.flow(e, "c", {
                        slot: "afterColor"
                    }) : void 0,
                    f = this.alpha ? this.alpha.flow(e, "f") : void 0,
                    h = this.normal ? this.normal.flow(e, "v3") : void 0,
                    m = this.light ? this.light.flow(e, "v3", {
                        cache: "light"
                    }) : void 0,
                    v = this.ao ? this.ao.flow(e, "f") : void 0,
                    g = this.ambient ? this.ambient.flow(e, "c") : void 0,
                    y = this.shadow ? this.shadow.flow(e, "c") : void 0,
                    A = this.emissive ? this.emissive.flow(e, "c", {
                        slot: "emissive"
                    }) : void 0,
                    w = this.environment ? this.environment.flow(e, "c", {
                        slot: "environment"
                    }) : void 0,
                    C = this.environmentAlpha && this.environment ? this.environmentAlpha.flow(e, "f") : void 0;
                e.requires.transparent = f !== void 0, e.addParsCode(["#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_phong_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <logdepthbuf_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`));
                let S = ["#include <normal_fragment_begin>", "	BlinnPhongMaterial material;"];
                r && S.push(r.code, "if ( ! " + r.result + " ) discard;"), S.push(i.code, "	vec3 diffuseColor = " + i.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "#include <logdepthbuf_fragment>", s.code, "	vec3 specular = " + s.result + ";", o.code, "	float shininess = max( 0.0001, " + o.result + " );", "	float specularStrength = 1.0;"), f && S.push(f.code, "#ifdef ALPHATEST", "if ( " + f.result + " <= ALPHATEST ) discard;", "#endif"), h && S.push(h.code, "normal = " + h.result + ";"), S.push("material.diffuseColor = " + (m ? "vec3( 1.0 )" : "diffuseColor") + ";"), S.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), m && (S.push(m.code, "reflectedLight.directDiffuse = " + m.result + ";"), S.push("reflectedLight.directDiffuse *= diffuseColor;", "reflectedLight.indirectDiffuse *= diffuseColor;")), v && S.push(v.code, "reflectedLight.indirectDiffuse *= " + v.result + ";"), g && S.push(g.code, "reflectedLight.indirectDiffuse += " + g.result + ";"), y && S.push(y.code, "reflectedLight.directDiffuse *= " + y.result + ";", "reflectedLight.directSpecular += " + y.result + ";"), A && S.push(A.code, "reflectedLight.directDiffuse += " + A.result + ";"), S.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;"), w && (S.push(w.code), C ? S.push(C.code, "outgoingLight = mix( outgoingLight, " + w.result + ", " + C.result + " );") : S.push("outgoingLight = " + w.result + ";")), S.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result}, ${a.result} );
				}
				`), c && S.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), f ? S.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${f.result} );`) : S.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), S.push("#include <tonemapping_fragment>", "#include <encodings_fragment>", "#include <fog_fragment>", "#include <premultiplied_alpha_fragment>", "#include <dithering_fragment>"), t = S.join(`
`)
            }
            return t
        }
        copy(e) {
            return super.copy(e), e.color && (this.color = e.color.clone()), this.specular = e.specular.clone(), this.shininess = e.shininess.clone(), e.position && (this.position = e.position.clone()), e.afterColor && (this.afterColor = e.afterColor.clone()), e.mask && (this.mask = e.mask.clone()), e.alpha && (this.alpha = e.alpha.clone()), e.normal && (this.normal = e.normal.clone()), e.light && (this.light = e.light.clone()), e.shadow && (this.shadow = e.shadow.clone()), e.ao && (this.ao = e.ao.clone()), e.emissive && (this.emissive = e.emissive.clone()), e.ambient && (this.ambient = e.ambient.clone()), e.environment && (this.environment = e.environment.clone()), e.environmentAlpha && (this.environmentAlpha = e.environmentAlpha.clone()), e.shadingAlpha && (this.shadingAlpha = e.shadingAlpha.clone()), e.shadingBlend && (this.shadingBlend = e.shadingBlend.clone()), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), this.position && (t.position = this.position.toJSON(e).uuid), this.color && (t.color = this.color.toJSON(e).uuid), t.specular = this.specular.toJSON(e).uuid, t.shininess = this.shininess.toJSON(e).uuid, t.shadingAlpha = this.shadingAlpha.toJSON(e).uuid, t.shadingBlend = this.shadingBlend.toJSON(e).uuid, this.afterColor && (t.afterColor = this.afterColor.toJSON(e).uuid), this.mask && (t.mask = this.mask.toJSON(e).uuid), this.alpha && (t.alpha = this.alpha.toJSON(e).uuid), this.normal && (t.normal = this.normal.toJSON(e).uuid), this.light && (t.light = this.light.toJSON(e).uuid), this.ao && (t.ao = this.ao.toJSON(e).uuid), this.ambient && (t.ambient = this.ambient.toJSON(e).uuid), this.shadow && (t.shadow = this.shadow.toJSON(e).uuid), this.emissive && (t.emissive = this.emissive.toJSON(e).uuid), this.environment && (t.environment = this.environment.toJSON(e).uuid), this.environmentAlpha && (t.environmentAlpha = this.environmentAlpha.toJSON(e).uuid)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.position && (this.position = t.getNode(e.position)), e.color && (this.color = t.getNode(e.color)), e.specular && (this.specular = t.getNode(e.specular)), e.shininess && (this.shininess = t.getNode(e.shininess)), e.mask && (this.mask = t.getNode(e.mask)), e.alpha && (this.alpha = t.getNode(e.alpha)), e.normal && (this.normal = t.getNode(e.normal)), e.light && (this.light = t.getNode(e.light)), e.ao && (this.ao = t.getNode(e.ao)), e.ambient && (this.ambient = t.getNode(e.ambient)), e.shadow && (this.shadow = t.getNode(e.shadow)), e.emissive && (this.emissive = t.getNode(e.emissive)), e.environment && (this.environment = t.getNode(e.environment)), e.environmentAlpha && (this.environmentAlpha = t.getNode(e.environmentAlpha)), e.shadingAlpha && (this.shadingAlpha = t.getNode(e.shadingAlpha)), e.shadingBlend && (this.shadingBlend = t.getNode(e.shadingBlend)), e.afterColor && (this.afterColor = t.getNode(e.afterColor)), this
        }
    };
    var ou = class extends Gr {
        get color() {
            return this.fragment.color
        }
        set color(e) {
            this.fragment.color = e
        }
        get afterColor() {
            return this.fragment.afterColor
        }
        set afterColor(e) {
            this.fragment.afterColor = e
        }
        get alpha() {
            return this.fragment.alpha
        }
        set alpha(e) {
            this.fragment.alpha = e
        }
        get shadingAlpha() {
            return this.fragment.shadingAlpha
        }
        set shadingAlpha(e) {
            this.fragment.shadingAlpha = e
        }
        get shadingBlend() {
            return this.fragment.shadingBlend
        }
        set shadingBlend(e) {
            this.fragment.shadingBlend = e
        }
        get mask() {
            return this.fragment.mask
        }
        set mask(e) {
            this.fragment.mask = e
        }
        get position() {
            return this.fragment.position
        }
        set position(e) {
            this.fragment.position = e
        }
        get specular() {
            return this.fragment.specular
        }
        set specular(e) {
            this.fragment.specular = e
        }
        get shininess() {
            return this.fragment.shininess
        }
        set shininess(e) {
            this.fragment.shininess = e
        }
        get normal() {
            return this.fragment.normal
        }
        set normal(e) {
            this.fragment.normal = e
        }
        get emissive() {
            return this.fragment.emissive
        }
        set emissive(e) {
            this.fragment.emissive = e
        }
        get ambient() {
            return this.fragment.ambient
        }
        set ambient(e) {
            this.fragment.ambient = e
        }
        get light() {
            return this.fragment.light
        }
        set light(e) {
            this.fragment.light = e
        }
        get shadow() {
            return this.fragment.shadow
        }
        set shadow(e) {
            this.fragment.shadow = e
        }
        get ao() {
            return this.fragment.ao
        }
        set ao(e) {
            this.fragment.ao = e
        }
        get environment() {
            return this.fragment.environment
        }
        set environment(e) {
            this.fragment.environment = e
        }
        get environmentAlpha() {
            return this.fragment.environmentAlpha
        }
        set environmentAlpha(e) {
            this.fragment.environmentAlpha = e
        }
        constructor(e = new _o, t) {
            super(e, e, t);
            this.type = "PhongNodeMaterial", this.fragment = e
        }
    };
    var zr = class extends ou {
        constructor(e, t, r) {
            super(t, e);
            this.userData.type = "PhongMaterial", this.userData.category = "Phong", this.userData.layers = r ?? this._getLayerStack(e?.map)
        }
        get layersList() {
            return this.userData.layers
        }
        set layersList(e) {
            this.userData.layers = e
        }
        equals(e) {
            return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid
        }
        copy(e) {
            if (e.userData.layers !== void 0 && e.userData.layers instanceof ar) {
                let t = e.userData.layers,
                    r = e.fragment;
                super.copy(e);
                let i = r.clone();
                this.fragment = i, this.vertex = i;
                let s = t.clone(this);
                this.userData.layers = s, i.shadingAlpha.value = r.shadingAlpha.value, i.shadingBlend.value = r.shadingBlend.value
            } else super.copy(e);
            return this
        }
        static fromJSON(e, t, r) {
            let i = r.getNode(t.vertex),
                s = new zr(void 0, i);
            return s.fromJSON(t, r), s
        }
        static fromMaterial(e) {
            let t = new zr(e.map ? {
                    map: e.map
                } : {}),
                r = t.fragment;
            return r.color.value.copy(e.color), r.alpha.value = e.opacity, t
        }
        dispose() {
            super.dispose()
        }
    };
    var Io = W(J());
    var Lo = class extends we {
        constructor() {
            super("lambert");
            this.nodeType = "Lambert";
            this.color = new qe(5855577), this.emissive = new qe(0), this.emissiveIntensity = new ve(1), this.shadingAlpha = new ve(1), this.shadingBlend = new Qe(0)
        }
        build(e) {
            let t;
            if (e.define("LAMBERT"), e.requires.lights = !0, e.isShader("vertex")) {
                let r = this.position ? this.position.analyzeAndFlow(e, "v3", {
                    cache: "position"
                }) : void 0;
                e.mergeUniform(Io.UniformsUtils.merge([Io.UniformsLib.fog, Io.UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <color_pars_vertex>", "#include <fog_pars_vertex>", "#include <morphtarget_pars_vertex>", "#include <skinning_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
                let i = ["#include <beginnormal_vertex>", "#include <morphnormal_vertex>", "#include <skinbase_vertex>", "#include <skinnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
                r && i.push(r.code, r.result ? "displaced_position = " + r.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("	#include <morphtarget_vertex>", "	#include <skinning_vertex>", "	#include <project_vertex>", "	#include <logdepthbuf_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = PI * directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = PI * directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = PI * directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`, "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), t = i.join(`
`)
            } else {
                this.mask && this.mask.analyze(e), this.color === void 0 && (this.color = new qe(5855577)), this.color.analyze(e, {
                    slot: "color"
                }), this.emissive.analyze(e, {
                    slot: "emissive"
                }), this.emissiveIntensity.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, {
                    slot: "afterColor"
                }), this.alpha && this.alpha.analyze(e), this.normal && this.normal.analyze(e), this.light && this.light.analyze(e, {
                    cache: "light"
                }), this.ao && this.ao.analyze(e), this.ambient && this.ambient.analyze(e), this.shadow && this.shadow.analyze(e), this.environment && this.environment.analyze(e, {
                    slot: "environment"
                }), this.environmentAlpha && this.environment && this.environmentAlpha.analyze(e);
                let r = this.mask ? this.mask.flow(e, "b") : void 0,
                    i = this.color.flow(e, "c", {
                        slot: "color"
                    }),
                    s = this.emissive.flow(e, "c", {
                        slot: "emissive"
                    }),
                    o = this.emissiveIntensity.flow(e, "f", {
                        slot: "emissive"
                    }),
                    l = this.shadingAlpha.flow(e, "f"),
                    a = this.shadingBlend.flow(e, "i"),
                    c = this.afterColor ? this.afterColor.flow(e, "c", {
                        slot: "afterColor"
                    }) : void 0,
                    f = this.alpha ? this.alpha.flow(e, "f") : void 0,
                    h = this.normal ? this.normal.flow(e, "v3") : void 0,
                    m = this.environment ? this.environment.flow(e, "c", {
                        slot: "environment"
                    }) : void 0,
                    v = this.environmentAlpha && this.environment ? this.environmentAlpha.flow(e, "f") : void 0;
                e.requires.transparent = f !== void 0, e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <fog_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <shadowmask_pars_fragment>", "#include <logdepthbuf_pars_fragment>", "#include <clipping_planes_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`));
                let g = ["#include <normal_fragment_begin>", "#include <clipping_planes_fragment>"];
                r && g.push(r.code, "if ( ! " + r.result + " ) discard;"), g.push(i.code, "vec3 diffuseColor = " + i.result + ";", "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "#include <logdepthbuf_fragment>"), f && g.push(f.code, "#ifdef ALPHATEST", "if ( " + f.result + " <= ALPHATEST ) discard;", "#endif"), h && g.push(h.code, "normal = " + h.result + ";"), g.push("#ifdef DOUBLE_SIDED", "	reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;", "#else", "	reflectedLight.indirectDiffuse += vIndirectFront;", "#endif", "#include <lightmap_fragment>", "reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor );", "#ifdef DOUBLE_SIDED", "	reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;", "#else", "	reflectedLight.directDiffuse = vLightFront;", "#endif", "reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor ) * getShadowMask();"), s && g.push(s.code, "reflectedLight.directDiffuse += " + s.result + " * " + o.result + ";"), g.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;"), g.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result}, ${a.result} );
				}
				`), c && g.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), f ? g.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${f.result} );`) : g.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), g.push("#include <tonemapping_fragment>", "#include <encodings_fragment>", "#include <fog_fragment>", "#include <premultiplied_alpha_fragment>", "#include <dithering_fragment>"), t = g.join(`
`)
            }
            return t
        }
        copy(e) {
            return super.copy(e), e.color && (this.color = e.color.clone()), this.emissiveIntensity = e.emissiveIntensity.clone(), e.position && (this.position = e.position.clone()), e.afterColor && (this.afterColor = e.afterColor.clone()), e.mask && (this.mask = e.mask.clone()), e.alpha && (this.alpha = e.alpha.clone()), e.normal && (this.normal = e.normal.clone()), e.light && (this.light = e.light.clone()), e.shadow && (this.shadow = e.shadow.clone()), e.ao && (this.ao = e.ao.clone()), e.emissive && (this.emissive = e.emissive.clone()), e.ambient && (this.ambient = e.ambient.clone()), e.environment && (this.environment = e.environment.clone()), e.environmentAlpha && (this.environmentAlpha = e.environmentAlpha.clone()), e.shadingAlpha && (this.shadingAlpha = e.shadingAlpha.clone()), e.shadingBlend && (this.shadingBlend = e.shadingBlend.clone()), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), this.position && (t.position = this.position.toJSON(e).uuid), this.color && (t.color = this.color.toJSON(e).uuid), t.emissiveIntensity = this.emissiveIntensity.toJSON(e).uuid, t.shadingAlpha = this.shadingAlpha.toJSON(e).uuid, t.shadingBlend = this.shadingBlend.toJSON(e).uuid, this.afterColor && (t.afterColor = this.afterColor.toJSON(e).uuid), this.mask && (t.mask = this.mask.toJSON(e).uuid), this.alpha && (t.alpha = this.alpha.toJSON(e).uuid), this.normal && (t.normal = this.normal.toJSON(e).uuid), this.light && (t.light = this.light.toJSON(e).uuid), this.ao && (t.ao = this.ao.toJSON(e).uuid), this.ambient && (t.ambient = this.ambient.toJSON(e).uuid), this.shadow && (t.shadow = this.shadow.toJSON(e).uuid), this.emissive && (t.emissive = this.emissive.toJSON(e).uuid), this.environment && (t.environment = this.environment.toJSON(e).uuid), this.environmentAlpha && (t.environmentAlpha = this.environmentAlpha.toJSON(e).uuid)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.position && (this.position = t.getNode(e.position)), e.color && (this.color = t.getNode(e.color)), e.shadingAlpha && (this.shadingAlpha = t.getNode(e.shadingAlpha)), e.shadingBlend && (this.shadingBlend = t.getNode(e.shadingBlend)), e.afterColor && (this.afterColor = t.getNode(e.afterColor)), e.emissiveIntensity && (this.emissiveIntensity = t.getNode(e.emissiveIntensity)), e.mask && (this.mask = t.getNode(e.mask)), e.alpha && (this.alpha = t.getNode(e.alpha)), e.normal && (this.normal = t.getNode(e.normal)), e.light && (this.light = t.getNode(e.light)), e.ao && (this.ao = t.getNode(e.ao)), e.ambient && (this.ambient = t.getNode(e.ambient)), e.shadow && (this.shadow = t.getNode(e.shadow)), e.emissive && (this.emissive = t.getNode(e.emissive)), e.environment && (this.environment = t.getNode(e.environment)), e.environmentAlpha && (this.environmentAlpha = t.getNode(e.environmentAlpha)), this
        }
    };
    var au = class extends Gr {
        get color() {
            return this.fragment.color
        }
        set color(e) {
            this.fragment.color = e
        }
        get afterColor() {
            return this.fragment.afterColor
        }
        set afterColor(e) {
            this.fragment.afterColor = e
        }
        get alpha() {
            return this.fragment.alpha
        }
        set alpha(e) {
            this.fragment.alpha = e
        }
        get shadingAlpha() {
            return this.fragment.shadingAlpha
        }
        set shadingAlpha(e) {
            this.fragment.shadingAlpha = e
        }
        get shadingBlend() {
            return this.fragment.shadingBlend
        }
        set shadingBlend(e) {
            this.fragment.shadingBlend = e
        }
        get mask() {
            return this.fragment.mask
        }
        set mask(e) {
            this.fragment.mask = e
        }
        get position() {
            return this.fragment.position
        }
        set position(e) {
            this.fragment.position = e
        }
        get normal() {
            return this.fragment.normal
        }
        set normal(e) {
            this.fragment.normal = e
        }
        get emissive() {
            return this.fragment.emissive
        }
        set emissive(e) {
            this.fragment.emissive = e
        }
        get emissiveIntensity() {
            return this.fragment.emissiveIntensity
        }
        set emissiveIntensity(e) {
            this.fragment.emissiveIntensity = e
        }
        get ambient() {
            return this.fragment.ambient
        }
        set ambient(e) {
            this.fragment.ambient = e
        }
        get light() {
            return this.fragment.light
        }
        set light(e) {
            this.fragment.light = e
        }
        get shadow() {
            return this.fragment.shadow
        }
        set shadow(e) {
            this.fragment.shadow = e
        }
        get ao() {
            return this.fragment.ao
        }
        set ao(e) {
            this.fragment.ao = e
        }
        get environment() {
            return this.fragment.environment
        }
        set environment(e) {
            this.fragment.environment = e
        }
        get environmentAlpha() {
            return this.fragment.environmentAlpha
        }
        set environmentAlpha(e) {
            this.fragment.environmentAlpha = e
        }
        constructor(e = new Lo, t) {
            super(e, e, t);
            this.type = "LambertNodeMaterial", this.fragment = e
        }
    };
    var Do = class extends au {
        constructor(e, t, r) {
            super(t, e);
            this.userData.type = "LambertMaterial", this.userData.category = "Lambert", this.userData.layers = r ?? this._getLayerStack(e?.map)
        }
        get layersList() {
            return this.userData.layers
        }
        set layersList(e) {
            this.userData.layers = e
        }
        equals(e) {
            return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid
        }
        copy(e) {
            if (e.userData.layers !== void 0 && e.userData.layers instanceof ar) {
                let t = e.userData.layers,
                    r = e.fragment;
                super.copy(e);
                let i = r.clone();
                this.fragment = i, this.vertex = i;
                let s = t.clone(this);
                this.userData.layers = s, i.shadingAlpha.value = r.shadingAlpha.value, i.shadingBlend.value = r.shadingBlend.value
            } else super.copy(e);
            return this
        }
        static fromJSON(e, t, r) {
            let i = r.getNode(t.vertex),
                s = new Do(void 0, i);
            return s.fromJSON(t, r), s
        }
        dispose() {
            super.dispose()
        }
    };
    var Po = W(J());
    var Bo = class extends we {
        constructor() {
            super("toon");
            this.nodeType = "Toon";
            this.color = new qe(5855577), this.specular = new qe(1118481), this.shininess = new ve(30), this.shadingAlpha = new ve(1), this.shadingBlend = new Qe(0)
        }
        build(e) {
            let t;
            if (e.define("TOON"), e.requires.lights = !0, e.isShader("vertex")) {
                let r = this.position ? this.position.analyzeAndFlow(e, "v3", {
                    cache: "position"
                }) : void 0;
                e.mergeUniform(Po.UniformsUtils.merge([Po.UniformsLib.fog, Po.UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", "#include <fog_pars_vertex>", "#include <morphtarget_pars_vertex>", "#include <skinning_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
                let i = ["#include <beginnormal_vertex>", "#include <morphnormal_vertex>", "#include <skinbase_vertex>", "#include <skinnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
                r && i.push(r.code, r.result ? "displaced_position = " + r.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("	#include <morphtarget_vertex>", "	#include <skinning_vertex>", "	#include <project_vertex>", "	#include <fog_vertex>", "	#include <logdepthbuf_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), t = i.join(`
`)
            } else {
                this.mask && this.mask.analyze(e), this.color === void 0 && (this.color = new qe(5855577)), this.color.analyze(e, {
                    slot: "color"
                }), this.specular.analyze(e), this.shininess.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, {
                    slot: "afterColor"
                }), this.alpha && this.alpha.analyze(e), this.normal && this.normal.analyze(e), this.light && this.light.analyze(e, {
                    cache: "light"
                }), this.ao && this.ao.analyze(e), this.ambient && this.ambient.analyze(e), this.shadow && this.shadow.analyze(e), this.emissive && this.emissive.analyze(e, {
                    slot: "emissive"
                }), this.environment && this.environment.analyze(e, {
                    slot: "environment"
                }), this.environmentAlpha && this.environment && this.environmentAlpha.analyze(e);
                let r = this.mask ? this.mask.flow(e, "b") : void 0,
                    i = this.color.flow(e, "c", {
                        slot: "color"
                    }),
                    s = this.specular.flow(e, "c"),
                    o = this.shininess.flow(e, "f"),
                    l = this.shadingAlpha.flow(e, "f"),
                    a = this.shadingBlend.flow(e, "i"),
                    c = this.afterColor ? this.afterColor.flow(e, "c", {
                        slot: "afterColor"
                    }) : void 0,
                    f = this.alpha ? this.alpha.flow(e, "f") : void 0,
                    h = this.normal ? this.normal.flow(e, "v3") : void 0,
                    m = this.light ? this.light.flow(e, "v3", {
                        cache: "light"
                    }) : void 0,
                    v = this.ao ? this.ao.flow(e, "f") : void 0,
                    g = this.ambient ? this.ambient.flow(e, "c") : void 0,
                    y = this.shadow ? this.shadow.flow(e, "c") : void 0,
                    A = this.emissive ? this.emissive.flow(e, "c", {
                        slot: "emissive"
                    }) : void 0,
                    w = this.environment ? this.environment.flow(e, "c", {
                        slot: "environment"
                    }) : void 0,
                    C = this.environmentAlpha && this.environment ? this.environmentAlpha.flow(e, "f") : void 0;
                e.requires.transparent = f !== void 0, e.addParsCode(["#include <gradientmap_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <dithering_pars_fragment>", `
					varying vec3 vViewPosition;
					#ifndef FLAT_SHADED
						varying vec3 vNormal;
					#endif
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
						#ifndef PHYSICALLY_CORRECT_LIGHTS
							irradiance *= PI;
						#endif
						reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`, "#include <shadowmap_pars_fragment>", "#include <bumpmap_pars_fragment>", "#include <normalmap_pars_fragment>", "#include <logdepthbuf_pars_fragment>"].join(`
`));
                let S = ["#include <normal_fragment_begin>", "	ToonMaterial material;"];
                r && S.push(r.code, "if ( ! " + r.result + " ) discard;"), S.push(i.code, "	vec3 diffuseColor = " + i.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "#include <logdepthbuf_fragment>", s.code, "	vec3 specular = " + s.result + ";", o.code, "	float shininess = max( 0.0001, " + o.result + " );", "	float specularStrength = 1.0;"), f && S.push(f.code, "#ifdef ALPHATEST", "if ( " + f.result + " <= ALPHATEST ) discard;", "#endif"), h && S.push(h.code, "normal = " + h.result + ";"), S.push("material.diffuseColor = " + (m ? "vec3( 1.0 )" : "diffuseColor") + ";"), S.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), m && (S.push(m.code, "reflectedLight.directDiffuse = " + m.result + ";"), S.push("reflectedLight.directDiffuse *= diffuseColor;", "reflectedLight.indirectDiffuse *= diffuseColor;")), v && S.push(v.code, "reflectedLight.indirectDiffuse *= " + v.result + ";"), g && S.push(g.code, "reflectedLight.indirectDiffuse += " + g.result + ";"), y && S.push(y.code, "reflectedLight.directDiffuse *= " + y.result + ";", "reflectedLight.directSpecular += " + y.result + ";"), A && S.push(A.code, "reflectedLight.directDiffuse += " + A.result + ";"), S.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;"), w && (S.push(w.code), C ? S.push(C.code, "outgoingLight = mix( outgoingLight, " + w.result + ", " + C.result + " );") : S.push("outgoingLight = " + w.result + ";")), S.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result}, ${a.result} );
				}
				`), c && S.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), f ? S.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${f.result} );`) : S.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), S.push("#include <tonemapping_fragment>", "#include <encodings_fragment>", "#include <fog_fragment>", "#include <premultiplied_alpha_fragment>", "#include <dithering_fragment>"), t = S.join(`
`)
            }
            return t
        }
        copy(e) {
            return super.copy(e), e.color && (this.color = e.color.clone()), this.specular = e.specular.clone(), this.shininess = e.shininess.clone(), e.position && (this.position = e.position.clone()), e.afterColor && (this.afterColor = e.afterColor.clone()), e.mask && (this.mask = e.mask.clone()), e.alpha && (this.alpha = e.alpha.clone()), e.normal && (this.normal = e.normal.clone()), e.light && (this.light = e.light.clone()), e.shadow && (this.shadow = e.shadow.clone()), e.ao && (this.ao = e.ao.clone()), e.emissive && (this.emissive = e.emissive.clone()), e.ambient && (this.ambient = e.ambient.clone()), e.environment && (this.environment = e.environment.clone()), e.environmentAlpha && (this.environmentAlpha = e.environmentAlpha.clone()), e.shadingAlpha && (this.shadingAlpha = e.shadingAlpha.clone()), e.shadingBlend && (this.shadingBlend = e.shadingBlend.clone()), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), this.position && (t.position = this.position.toJSON(e).uuid), this.color && (t.color = this.color.toJSON(e).uuid), t.specular = this.specular.toJSON(e).uuid, t.shininess = this.shininess.toJSON(e).uuid, this.mask && (t.mask = this.mask.toJSON(e).uuid), this.alpha && (t.alpha = this.alpha.toJSON(e).uuid), this.normal && (t.normal = this.normal.toJSON(e).uuid), this.light && (t.light = this.light.toJSON(e).uuid), this.ao && (t.ao = this.ao.toJSON(e).uuid), this.ambient && (t.ambient = this.ambient.toJSON(e).uuid), this.shadow && (t.shadow = this.shadow.toJSON(e).uuid), this.emissive && (t.emissive = this.emissive.toJSON(e).uuid), this.environment && (t.environment = this.environment.toJSON(e).uuid), this.environmentAlpha && (t.environmentAlpha = this.environmentAlpha.toJSON(e).uuid), this.shadingAlpha && (t.shadingAlpha = this.shadingAlpha.toJSON(e).uuid), this.shadingBlend && (t.shadingBlend = this.shadingBlend.toJSON(e).uuid), this.afterColor && (t.afterColor = this.afterColor.toJSON(e).uuid)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.position && (this.position = t.getNode(e.position)), e.color && (this.color = t.getNode(e.color)), e.specular && (this.specular = t.getNode(e.specular)), e.shininess && (this.shininess = t.getNode(e.shininess)), e.mask && (this.mask = t.getNode(e.mask)), e.alpha && (this.alpha = t.getNode(e.alpha)), e.normal && (this.normal = t.getNode(e.normal)), e.light && (this.light = t.getNode(e.light)), e.ao && (this.ao = t.getNode(e.ao)), e.ambient && (this.ambient = t.getNode(e.ambient)), e.shadow && (this.shadow = t.getNode(e.shadow)), e.emissive && (this.emissive = t.getNode(e.emissive)), e.environment && (this.environment = t.getNode(e.environment)), e.environmentAlpha && (this.environmentAlpha = t.getNode(e.environmentAlpha)), e.shadingAlpha && (this.shadingAlpha = t.getNode(e.shadingAlpha)), e.shadingBlend && (this.shadingBlend = t.getNode(e.shadingBlend)), e.afterColor && (this.afterColor = t.getNode(e.afterColor)), this
        }
    };
    var lu = class extends Gr {
        get color() {
            return this.fragment.color
        }
        set color(e) {
            this.fragment.color = e
        }
        get afterColor() {
            return this.fragment.afterColor
        }
        set afterColor(e) {
            this.fragment.afterColor = e
        }
        get alpha() {
            return this.fragment.alpha
        }
        set alpha(e) {
            this.fragment.alpha = e
        }
        get shadingAlpha() {
            return this.fragment.shadingAlpha
        }
        set shadingAlpha(e) {
            this.fragment.shadingAlpha = e
        }
        get shadingBlend() {
            return this.fragment.shadingBlend
        }
        set shadingBlend(e) {
            this.fragment.shadingBlend = e
        }
        get mask() {
            return this.fragment.mask
        }
        set mask(e) {
            this.fragment.mask = e
        }
        get position() {
            return this.fragment.position
        }
        set position(e) {
            this.fragment.position = e
        }
        get specular() {
            return this.fragment.specular
        }
        set specular(e) {
            this.fragment.specular = e
        }
        get shininess() {
            return this.fragment.shininess
        }
        set shininess(e) {
            this.fragment.shininess = e
        }
        get normal() {
            return this.fragment.normal
        }
        set normal(e) {
            this.fragment.normal = e
        }
        get emissive() {
            return this.fragment.emissive
        }
        set emissive(e) {
            this.fragment.emissive = e
        }
        get ambient() {
            return this.fragment.ambient
        }
        set ambient(e) {
            this.fragment.ambient = e
        }
        get light() {
            return this.fragment.light
        }
        set light(e) {
            this.fragment.light = e
        }
        get shadow() {
            return this.fragment.shadow
        }
        set shadow(e) {
            this.fragment.shadow = e
        }
        get ao() {
            return this.fragment.ao
        }
        set ao(e) {
            this.fragment.ao = e
        }
        get environment() {
            return this.fragment.environment
        }
        set environment(e) {
            this.fragment.environment = e
        }
        get environmentAlpha() {
            return this.fragment.environmentAlpha
        }
        set environmentAlpha(e) {
            this.fragment.environmentAlpha = e
        }
        constructor(e = new Bo, t) {
            super(e, e, t);
            this.type = "ToonNodeMaterial", this.fragment = e
        }
    };
    var Oo = class extends lu {
        constructor(e, t, r) {
            super(t, e);
            this.userData.type = "ToonMaterial", this.userData.category = "Toon", this.userData.layers = r ?? this._getLayerStack(e?.map)
        }
        get layersList() {
            return this.userData.layers
        }
        set layersList(e) {
            this.userData.layers = e
        }
        equals(e) {
            return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid
        }
        copy(e) {
            if (e.userData.layers !== void 0 && e.userData.layers instanceof ar) {
                let t = e.userData.layers,
                    r = e.fragment;
                super.copy(e);
                let i = r.clone();
                this.fragment = i, this.vertex = i;
                let s = t.clone(this);
                this.userData.layers = s, i.shadingAlpha.value = r.shadingAlpha.value, i.shadingBlend.value = r.shadingBlend.value
            } else super.copy(e);
            return this
        }
        static fromJSON(e, t, r) {
            let i = r.getNode(t.vertex),
                s = new Oo(void 0, i);
            return s.fromJSON(t, r), s
        }
        dispose() {
            super.dispose()
        }
    };
    var Is = W(J());
    var _s = class extends ve {
        constructor(e) {
            super();
            this.nodeType = "MaxMIPLevel";
            this.texture = e, this.maxMIPLevel = 0
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), this.texture && (t.texture = this.texture.toJSON(e).uuid), t.maxMIPLevel = this.maxMIPLevel), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.texture && (this.texture = t.getNode(e.texture)), e.maxMIPLevel !== void 0 && (this.maxMIPLevel = e.maxMIPLevel), this
        }
    };
    Object.defineProperties(_s.prototype, {
        value: {
            get: function() {
                if (this.maxMIPLevel === 0) {
                    let n = this.texture.value.image;
                    Array.isArray(n) && (n = n[0]), this.maxMIPLevel = n !== void 0 ? Math.log(Math.max(n.width, n.height)) * Math.LOG2E : 0
                }
                return this.maxMIPLevel
            },
            set: function() {}
        }
    });
    var cu = class extends _e {
            constructor(e = new we, t) {
                super("f");
                this.nodeType = "SpecularMIPLevel";
                this.roughness = e, this.texture = t
            }
            setTexture(e) {
                return this.texture = e, this
            }
            generate(e, t) {
                if (e.isShader("fragment")) {
                    this.maxMIPLevel = this.maxMIPLevel ?? new _s, this.maxMIPLevel.texture = this.texture;
                    let r = e.include(cu.Nodes.getSpecularMIPLevel);
                    return e.format(r + "( " + this.roughness.build(e, "f") + ", " + this.maxMIPLevel.build(e, "f") + " )", this.type, t)
                } else return console.warn("SpecularMIPLevelNode is not compatible with " + e.shader + " shader."), e.format("0.0", this.type, t)
            }
            copy(e) {
                return super.copy(e), this.roughness = e.roughness, e.texture ? this.texture ? this.texture.copy(e.texture) : this.texture = e.texture.clone() : this.texture = void 0, e.maxMIPLevel ? this.maxMIPLevel ? this.maxMIPLevel.copy(e.maxMIPLevel) : this.maxMIPLevel = e.maxMIPLevel.clone() : this.maxMIPLevel = void 0, this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), this.texture && (t.texture = this.texture.toJSON(e).uuid), this.roughness && (t.roughness = this.roughness.toJSON(e).uuid), this.maxMIPLevel && (t.maxMIPLevel = this.maxMIPLevel.toJSON(e).uuid)), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.roughness && (this.roughness = t.getNode(e.roughness)), e.texture && (this.texture = t.getNode(e.texture)), e.maxMIPLevel && (this.maxMIPLevel = t.getNode(e.maxMIPLevel)), this
            }
        },
        Pn = cu;
    Pn.Nodes = function() {
        return {
            getSpecularMIPLevel: new xe(["float getSpecularMIPLevel( const in float roughness, const in float maxMIPLevelScalar ) {", "	float sigma = PI * roughness * roughness / ( 1.0 + roughness );", "	float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );", "	return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );", "}"].join(`
`))
        }
    }();
    var Ro = class extends we {
        constructor() {
            super("standard");
            this.nodeType = "Standard";
            this.color = new qe(5855577), this.roughness = new ve(.3), this.metalness = new ve(0), this.reflectivity = new ve(.5), this.shadingAlpha = new ve(1), this.shadingBlend = new Qe(0)
        }
        build(e) {
            let t;
            e.define("STANDARD");
            let r = this.clearcoat ?? this.clearcoatRoughness ?? this.clearcoatNormal;
            if (r && e.define("CLEARCOAT"), e.requires.lights = !0, e.extensions.derivatives = !0, e.extensions.shaderTextureLOD = !0, e.isShader("vertex")) {
                let i = this.position ? this.position.analyzeAndFlow(e, "v3", {
                    cache: "position"
                }) : void 0;
                e.mergeUniform(Is.UniformsUtils.merge([Is.UniformsLib.fog, Is.UniformsLib.lights])), Is.UniformsLib.LTC_1 && (e.uniforms.ltc_1 = {
                    value: void 0
                }, e.uniforms.ltc_2 = {
                    value: void 0
                }), e.addParsCode(["varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", "#include <fog_pars_vertex>", "#include <morphtarget_pars_vertex>", "#include <skinning_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
                let s = ["#include <beginnormal_vertex>", "#include <morphnormal_vertex>", "#include <skinbase_vertex>", "#include <skinnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];
                i && s.push(i.code, i.result ? "displaced_position = " + i.result + ";" : ""), s.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), s.push("#include <morphtarget_vertex>", "#include <skinning_vertex>", "#include <project_vertex>", "#include <fog_vertex>", "#include <logdepthbuf_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>", "#include <shadowmap_vertex>"), t = s.join(`
`)
            } else {
                let i = new Ye("material.specularRoughness", "f"),
                    s = new Ye("material.clearcoatRoughness", "f"),
                    o = {
                        roughness: i,
                        bias: new Pn(i),
                        viewNormal: new Ye("normal", "v3"),
                        worldNormal: new Ye("inverseTransformDirection( geometry.normal, viewMatrix )", "v3"),
                        gamma: !0
                    },
                    l = {
                        gamma: !0
                    },
                    a = {
                        roughness: s,
                        bias: new Pn(s),
                        viewNormal: new Ye("clearcoatNormal", "v3"),
                        worldNormal: new Ye("inverseTransformDirection( geometry.clearcoatNormal, viewMatrix )", "v3"),
                        gamma: !0
                    };
                this.mask && this.mask.analyze(e), this.color === void 0 && (this.color = new qe(5855577)), this.color.analyze(e, {
                    slot: "color",
                    context: l
                }), this.roughness.analyze(e), this.metalness.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, {
                    slot: "afterColor"
                }), this.alpha && this.alpha.analyze(e), this.normal && this.normal.analyze(e), this.clearcoat && this.clearcoat.analyze(e), this.clearcoatRoughness && this.clearcoatRoughness.analyze(e), this.clearcoatNormal && this.clearcoatNormal.analyze(e), this.reflectivity && this.reflectivity.analyze(e), this.light && this.light.analyze(e, {
                    cache: "light"
                }), this.ao && this.ao.analyze(e), this.ambient && this.ambient.analyze(e), this.shadow && this.shadow.analyze(e), this.emissive && this.emissive.analyze(e, {
                    slot: "emissive"
                }), this.environment && (this.environment.analyze(e, {
                    cache: "radiance",
                    context: o,
                    slot: "radiance"
                }), e.requires.irradiance && this.environment.analyze(e, {
                    cache: "irradiance",
                    context: o,
                    slot: "irradiance"
                })), this.sheen && this.sheen.analyze(e);
                let c = this.mask ? this.mask.flow(e, "b") : void 0,
                    f = this.color.flow(e, "c", {
                        slot: "color",
                        context: l
                    }),
                    h = this.roughness.flow(e, "f"),
                    m = this.metalness.flow(e, "f"),
                    v = this.shadingAlpha.flow(e, "f"),
                    g = this.shadingBlend.flow(e, "i"),
                    y = this.afterColor ? this.afterColor.flow(e, "c", {
                        slot: "afterColor"
                    }) : void 0,
                    A = this.alpha ? this.alpha.flow(e, "f") : void 0,
                    w = this.normal ? this.normal.flow(e, "v3") : void 0,
                    C = this.clearcoat ? this.clearcoat.flow(e, "f") : void 0,
                    S = this.clearcoatRoughness ? this.clearcoatRoughness.flow(e, "f") : void 0,
                    E = this.clearcoatNormal ? this.clearcoatNormal.flow(e, "v3") : void 0,
                    M = this.reflectivity ? this.reflectivity.flow(e, "f") : void 0,
                    L = this.light ? this.light.flow(e, "v3", {
                        cache: "light"
                    }) : void 0,
                    I = this.ao ? this.ao.flow(e, "f") : void 0,
                    z = this.ambient ? this.ambient.flow(e, "c") : void 0,
                    O = this.shadow ? this.shadow.flow(e, "c") : void 0,
                    X = this.emissive ? this.emissive.flow(e, "c", {
                        slot: "emissive"
                    }) : void 0,
                    k;
                this.environment && (k = {
                    radiance: this.environment.flow(e, "c", {
                        cache: "radiance",
                        context: o,
                        slot: "radiance"
                    })
                }, e.requires.irradiance && (k.irradiance = this.environment.flow(e, "c", {
                    cache: "irradiance",
                    context: o,
                    slot: "irradiance"
                })));
                let Q = r && k ? this.environment?.flow(e, "c", {
                        cache: "clearcoat",
                        context: a,
                        slot: "environment"
                    }) : void 0,
                    te = this.sheen ? this.sheen.flow(e, "c") : void 0;
                e.requires.transparent = A !== void 0, e.addParsCode(["varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", "#include <dithering_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_physical_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <logdepthbuf_pars_fragment>"].join(`
`));
                let Z = ["#include <clipping_planes_fragment>", "	#include <normal_fragment_begin>", "	#include <clearcoat_normal_fragment_begin>", "	PhysicalMaterial material;", "	material.diffuseColor = vec3( 1.0 );"];
                c && Z.push(c.code, "if ( ! " + c.result + " ) discard;"), Z.push(f.code, "	vec3 diffuseColor = " + f.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "#include <logdepthbuf_fragment>", h.code, "	float roughnessFactor = " + h.result + ";", m.code, "	float metalnessFactor = " + m.result + ";"), A && Z.push(A.code, "#ifdef ALPHATEST", "	if ( " + A.result + " <= ALPHATEST ) discard;", "#endif"), w && Z.push(w.code, "normal = " + w.result + ";"), E && Z.push(E.code, "clearcoatNormal = " + E.result + ";"), Z.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"), Z.push("material.diffuseColor = " + (L ? "vec3( 1.0 )" : "diffuseColor * ( 1.0 - metalnessFactor )") + ";", "material.specularRoughness = max( roughnessFactor, 0.0525 );", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );"), C ? Z.push(C.code, "material.clearcoat = saturate( " + C.result + " );") : r && Z.push("material.clearcoat = 0.0;"), S ? Z.push(S.code, "material.clearcoatRoughness = max( " + S.result + ", 0.0525 );", "material.clearcoatRoughness += geometryRoughness;", "material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );") : r && Z.push("material.clearcoatRoughness = 0.0;"), te && Z.push("material.sheenColor = " + te.result + ";"), M ? Z.push(M.code, "material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( " + M.result + " ) ), diffuseColor, metalnessFactor );") : Z.push("material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor, metalnessFactor );"), Z.push("#include <lights_fragment_begin>"), L && (Z.push(L.code, "reflectedLight.directDiffuse = " + L.result + ";"), Z.push("diffuseColor *= 1.0 - metalnessFactor;", "reflectedLight.directDiffuse *= diffuseColor;", "reflectedLight.indirectDiffuse *= diffuseColor;")), I && Z.push(I.code, "reflectedLight.indirectDiffuse *= " + I.result + ";", "float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );", "reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, " + I.result + ", material.specularRoughness );"), z && Z.push(z.code, "reflectedLight.indirectDiffuse += " + z.result + ";"), O && Z.push(O.code, "reflectedLight.directDiffuse *= " + O.result + ";", "reflectedLight.directSpecular *= " + O.result + ";"), X && Z.push(X.code, "reflectedLight.directDiffuse += " + X.result + ";"), k && (Z.push(k.radiance?.code), e.requires.irradiance && Z.push(k.irradiance?.code), Q && Z.push(Q.code, "clearcoatRadiance += " + Q.result + ";"), Z.push("radiance += " + k.radiance?.result + ";"), e.requires.irradiance && Z.push("iblIrradiance += PI * " + k.irradiance?.result + ";")), Z.push("#include <lights_fragment_end>"), Z.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"), Z.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${v.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${v.result}, ${g.result} );
				}
				`), y && Z.push(y.code, `outgoingLight = spe_blend(outgoingLight, ${y.result}, 1.0, SPE_BLENDING_NORMAL);`), A ? Z.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${A.result} );`) : Z.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), Z.push("#include <tonemapping_fragment>", "#include <encodings_fragment>", "#include <fog_fragment>", "#include <premultiplied_alpha_fragment>", "#include <dithering_fragment>"), t = Z.join(`
`)
            }
            return t
        }
        copy(e) {
            return super.copy(e), e.color && (this.color = e.color.clone()), this.roughness = e.roughness.clone(), this.metalness = e.metalness.clone(), e.position && (this.position = e.position.clone()), e.afterColor && (this.afterColor = e.afterColor.clone()), e.mask && (this.mask = e.mask.clone()), e.alpha && (this.alpha = e.alpha.clone()), e.normal && (this.normal = e.normal.clone()), e.clearcoat && (this.clearcoat = e.clearcoat.clone()), e.clearcoatRoughness && (this.clearcoatRoughness = e.clearcoatRoughness.clone()), e.clearcoatNormal && (this.clearcoatNormal = e.clearcoatNormal.clone()), e.reflectivity && (this.reflectivity = e.reflectivity.clone()), e.light && (this.light = e.light.clone()), e.shadow && (this.shadow = e.shadow.clone()), e.ao && (this.ao = e.ao.clone()), e.emissive && (this.emissive = e.emissive.clone()), e.ambient && (this.ambient = e.ambient.clone()), e.environment && (this.environment = e.environment.clone()), e.sheen && (this.sheen = e.sheen.clone()), e.shadingAlpha && (this.shadingAlpha = e.shadingAlpha.clone()), e.shadingBlend && (this.shadingBlend = e.shadingBlend.clone()), this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), this.position && (t.position = this.position.toJSON(e).uuid), this.color && (t.color = this.color.toJSON(e).uuid), t.roughness = this.roughness.toJSON(e).uuid, t.metalness = this.metalness.toJSON(e).uuid, this.mask && (t.mask = this.mask.toJSON(e).uuid), this.alpha && (t.alpha = this.alpha.toJSON(e).uuid), this.normal && (t.normal = this.normal.toJSON(e).uuid), this.clearcoat && (t.clearcoat = this.clearcoat.toJSON(e).uuid), this.clearcoatRoughness && (t.clearcoatRoughness = this.clearcoatRoughness.toJSON(e).uuid), this.clearcoatNormal && (t.clearcoatNormal = this.clearcoatNormal.toJSON(e).uuid), this.reflectivity && (t.reflectivity = this.reflectivity.toJSON(e).uuid), this.light && (t.light = this.light.toJSON(e).uuid), this.ao && (t.ao = this.ao.toJSON(e).uuid), this.ambient && (t.ambient = this.ambient.toJSON(e).uuid), this.shadow && (t.shadow = this.shadow.toJSON(e).uuid), this.emissive && (t.emissive = this.emissive.toJSON(e).uuid), this.environment && (t.environment = this.environment.toJSON(e).uuid), this.sheen && (t.sheen = this.sheen.toJSON(e).uuid), this.shadingAlpha && (t.shadingAlpha = this.shadingAlpha.toJSON(e).uuid), this.shadingBlend && (t.shadingBlend = this.shadingBlend.toJSON(e).uuid), this.afterColor && (t.afterColor = this.afterColor.toJSON(e).uuid)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.position && (this.position = t.getNode(e.position)), e.color && (this.color = t.getNode(e.color)), e.roughness && (this.roughness = t.getNode(e.roughness)), e.metalness && (this.metalness = t.getNode(e.metalness)), e.mask && (this.mask = t.getNode(e.mask)), e.alpha && (this.alpha = t.getNode(e.alpha)), e.normal && (this.normal = t.getNode(e.normal)), e.clearcoat && (this.clearcoat = t.getNode(e.clearcoat)), e.clearcoatRoughness && (this.clearcoatRoughness = t.getNode(e.clearcoatRoughness)), e.clearcoatNormal && (this.clearcoatNormal = t.getNode(e.clearcoatNormal)), e.reflectivity && (this.reflectivity = t.getNode(e.reflectivity)), e.light && (this.light = t.getNode(e.light)), e.ao && (this.ao = t.getNode(e.ao)), e.ambient && (this.ambient = t.getNode(e.ambient)), e.shadow && (this.shadow = t.getNode(e.shadow)), e.emissive && (this.emissive = t.getNode(e.emissive)), e.environment && (this.environment = t.getNode(e.environment)), e.sheen && (this.sheen = t.getNode(e.sheen)), e.shadingAlpha && (this.shadingAlpha = t.getNode(e.shadingAlpha)), e.shadingBlend && (this.shadingBlend = t.getNode(e.shadingBlend)), e.afterColor && (this.afterColor = t.getNode(e.afterColor)), this
        }
    };
    var uu = class extends Gr {
        get color() {
            return this.fragment.color
        }
        set color(e) {
            this.fragment.color = e
        }
        get afterColor() {
            return this.fragment.afterColor
        }
        set afterColor(e) {
            this.fragment.afterColor = e
        }
        get alpha() {
            return this.fragment.alpha
        }
        set alpha(e) {
            this.fragment.alpha = e
        }
        get shadingAlpha() {
            return this.fragment.shadingAlpha
        }
        set shadingAlpha(e) {
            this.fragment.shadingAlpha = e
        }
        get shadingBlend() {
            return this.fragment.shadingBlend
        }
        set shadingBlend(e) {
            this.fragment.shadingBlend = e
        }
        get mask() {
            return this.fragment.mask
        }
        set mask(e) {
            this.fragment.mask = e
        }
        get position() {
            return this.fragment.position
        }
        set position(e) {
            this.fragment.position = e
        }
        get roughness() {
            return this.fragment.roughness
        }
        set roughness(e) {
            this.fragment.roughness = e
        }
        get metalness() {
            return this.fragment.metalness
        }
        set metalness(e) {
            this.fragment.metalness = e
        }
        get reflectivity() {
            return this.fragment.reflectivity
        }
        set reflectivity(e) {
            this.fragment.reflectivity = e
        }
        get clearcoat() {
            return this.fragment.clearcoat
        }
        set clearcoat(e) {
            this.fragment.clearcoat = e
        }
        get clearcoatRoughness() {
            return this.fragment.clearcoatRoughness
        }
        set clearcoatRoughness(e) {
            this.fragment.clearcoatRoughness = e
        }
        get clearcoatNormal() {
            return this.fragment.clearcoatNormal
        }
        set clearcoatNormal(e) {
            this.fragment.clearcoatNormal = e
        }
        get normal() {
            return this.fragment.normal
        }
        set normal(e) {
            this.fragment.normal = e
        }
        get emissive() {
            return this.fragment.emissive
        }
        set emissive(e) {
            this.fragment.emissive = e
        }
        get fresnel() {
            return this.fragment.fresnel
        }
        set fresnel(e) {
            this.fragment.fresnel = e
        }
        get ambient() {
            return this.fragment.ambient
        }
        set ambient(e) {
            this.fragment.ambient = e
        }
        get light() {
            return this.fragment.light
        }
        set light(e) {
            this.fragment.light = e
        }
        get shadow() {
            return this.fragment.shadow
        }
        set shadow(e) {
            this.fragment.shadow = e
        }
        get ao() {
            return this.fragment.ao
        }
        set ao(e) {
            this.fragment.ao = e
        }
        get environment() {
            return this.fragment.environment
        }
        set environment(e) {
            this.fragment.environment = e
        }
        get sheen() {
            return this.fragment.sheen
        }
        set sheen(e) {
            this.fragment.sheen = e
        }
        constructor(e = new Ro, t) {
            super(e, e, t);
            this.type = "StandardNodeMaterial", this.fragment = e
        }
    };
    var Fo = class extends uu {
        constructor(e, t, r) {
            super(t, e);
            this.userData.type = "PhysicalMaterial", this.userData.category = "Physical", this.userData.layers = r ?? this._getLayerStack(e?.map)
        }
        get layersList() {
            return this.userData.layers
        }
        set layersList(e) {
            this.userData.layers = e
        }
        equals(e) {
            return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid
        }
        copy(e) {
            if (e.userData.layers !== void 0 && e.userData.layers instanceof ar) {
                let t = e.userData.layers,
                    r = e.fragment;
                super.copy(e);
                let i = r.clone();
                this.fragment = i, this.vertex = i;
                let s = t.clone(this);
                this.userData.layers = s, i.shadingAlpha.value = r.shadingAlpha.value, i.shadingBlend.value = r.shadingBlend.value
            } else super.copy(e);
            return this
        }
        static fromJSON(e, t, r) {
            let i = r.getNode(t.vertex),
                s = new Fo(void 0, i);
            return s.fromJSON(t, r), s
        }
        dispose() {
            super.dispose()
        }
    };
    var Ed = {
        BasicMaterial: Pr,
        PhongMaterial: zr,
        LambertMaterial: Do,
        ToonMaterial: Oo,
        PhysicalMaterial: Fo
    };
    var am = W(J());
    var Ls = W(J());
    var Tt = W(J()),
        Md = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                        width: 100,
                        radialSegments: 64,
                        heightSegments: 1,
                        openEnded: !1,
                        thetaStart: 0,
                        thetaLength: 360,
                        cornerRadius: 0,
                        cornerSegments: 8,
                        hollow: 0
                    }, n.parameters),
                    r = t.width / 2,
                    i = t.radiusTop ?? r,
                    s = t.radiusBottom ?? r;
                return i === s ? (i = r, s = r) : i > s ? (i = r, s = s * r / i) : (i = i * r / s, s = r), {
                    parameters: Object.assign(t, {
                        width: Math.abs(t.width),
                        height: Math.abs(t.height ?? t.width),
                        depth: Math.abs(t.depth ?? t.width),
                        radiusTop: i,
                        radiusBottom: s
                    })
                }
            }
            static build(n) {
                let {
                    width: e,
                    depth: t,
                    height: r,
                    radialSegments: i,
                    heightSegments: s,
                    openEnded: o,
                    thetaStart: l,
                    thetaLength: a,
                    radiusTop: c,
                    radiusBottom: f,
                    cornerRadius: h,
                    cornerSegments: m,
                    hollow: v
                } = n.parameters, g;
                return h || v ? g = new cl(c, f, r, i, s, o, l, a * Math.PI / 180, h, h, m, v) : g = new Tt.CylinderBufferGeometry(c, f, r, i, s, o, l, a * Math.PI / 180), g.scale(1, 1, t / e), Object.assign(g, {
                    userData: je(Ne({}, n), {
                        type: "CylinderGeometry"
                    })
                })
            }
        };

    function sn(n, e, t) {
        t.x = n.x * e.x, t.y = n.y, t.z = n.x * e.y
    }

    function _d(n) {
        return new Tt.Vector2(n.y, -n.x)
    }
    var cl = class extends Tt.BufferGeometry {
        constructor(e, t, r, i, s, o, l, a, c, f, h, m, v = !1) {
            super();
            this.type = "RoundedCylinderBufferGeometry", e = e !== void 0 ? e : 1, t = t !== void 0 ? t : 1, r = r || 1, i = Math.floor(i) || 8, s = Math.floor(s) || 1, o = o !== void 0 ? o : !1, l = l !== void 0 ? l : 0, a = a !== void 0 ? a : Math.PI * 2, o && (c = 0, f = 0);
            let g = [],
                y = [],
                A = [],
                w = [],
                C = 0,
                S = r / 2,
                E = new Tt.Vector3,
                M = new Tt.Vector3;
            v && e == 0 && (e = c), v && t == 0 && (t = f);
            let L = new Tt.Vector2(e, S),
                I = new Tt.Vector2(t, -S),
                z = null,
                O = null,
                X = null,
                k = null,
                Q = L.clone().sub(I),
                te = 0,
                Z = 0,
                le = 0;
            m > 0 && (te = Math.min(e, t) * (1 - m), Z = e - te, le = t - te);
            let B = L.clone();
            B.x -= te;
            let U = Math.PI - Q.angle(),
                G = Q.angle(),
                V = Math.tan(G / 2),
                j = Math.tan(U / 2),
                ne = V + j,
                F = m ? ne : j,
                Y = m ? ne : V;
            if (c = Math.min(c, (e - Z) / F, Q.length() / ne), f = Math.min(f, (t - le) / Y, Q.length() / ne), c > 0) {
                let se = c / V;
                z = L.clone().sub(new Tt.Vector2(se, c)), m && (X = z.clone(), X.x -= te - ne * c), L.sub(Q.clone().setLength(se))
            }
            if (f > 0) {
                let se = f / j;
                O = I.clone().sub(new Tt.Vector2(se, -f)), I.add(Q.clone().setLength(se)), m && (k = O.clone(), k.x -= te - ne * f, B.sub(Q.clone().setLength(se)))
            }
            Q = L.clone().sub(I);
            let $ = Q.length() < .5,
                re = [];
            for (let se = 0; se <= i; se++) {
                let ie = [],
                    oe = se / i,
                    he = oe * a + l,
                    pe = new Tt.Vector2(Math.sin(he), Math.cos(he));
                k && O ? (fe(ie, oe, pe, U, f, k, -1, !0), fe(ie, oe, pe, G, f, O, -1, !1)) : O ? (ye(ie, pe, O.x, 0, -1), fe(ie, oe, pe, G, f, O, -1, !1)) : o || ye(ie, pe, t, le, -1);
                let q = _d(Q).normalize();
                if (sn(q, pe, E), !$)
                    for (let Ae = 0; Ae <= s; Ae++) {
                        let ke = Ae / s,
                            Ce = Q.clone().multiplyScalar(ke).add(I);
                        sn(Ce, pe, M), y.push(M.x, M.y, M.z), A.push(E.x, E.y, E.z), w.push(oe, .5 + M.y / r), ie.push(C++)
                    }
                if (X && z ? (fe(ie, oe, pe, U, c, z, 1, !1), fe(ie, oe, pe, G, c, X, 1, !0)) : z ? (fe(ie, oe, pe, U, c, z, 1, !1), ye(ie, pe, z.x, 0, 1)) : o || ye(ie, pe, e, Z, 1), m && !$) {
                    let Ae = _d(Q).multiplyScalar(-1).normalize();
                    sn(Ae, pe, E);
                    for (let ke = 0; ke <= s; ke++) {
                        let Ce = ke / s,
                            Te = Q.clone().multiplyScalar(-Ce).add(B);
                        sn(Te, pe, M), y.push(M.x, M.y, M.z), A.push(E.x, E.y, E.z), w.push(oe, .5 + M.y / r), ie.push(C++)
                    }
                }
                m && !o && ie.push(ie[0]), re.push(ie)
            }
            for (let se = 0; se < re.length - 1; se++)
                for (let ie = 0; ie < re[0].length - 1; ie++) {
                    if (o && m && ie == s) continue;
                    let oe = re[se][ie],
                        he = re[se + 1][ie],
                        pe = re[se + 1][ie + 1],
                        q = re[se][ie + 1],
                        Ae = y[pe * 3 + 0],
                        ke = y[pe * 3 + 2];
                    g.push(oe, he, q), (Ae != 0 || ke != 0) && g.push(he, pe, q)
                }
            a < Math.PI * 2 && (Se(-1, re[0], l), Se(1, re[re.length - 1], l + a)), this.setIndex(g), this.setAttribute("position", new Tt.Float32BufferAttribute(y, 3)), this.setAttribute("normal", new Tt.Float32BufferAttribute(A, 3)), this.setAttribute("uv", new Tt.Float32BufferAttribute(w, 2));

            function fe(se, ie, oe, he, pe, q, Ae, ke) {
                for (let Ce = 0; Ce < h + 1; Ce++) {
                    let Te = Ce / h,
                        Fe = Ae < 0 ? Te : 1 - Te;
                    ke && (Fe -= 1), Fe *= he;
                    let nt = new Tt.Vector2(Math.sin(Fe), Math.cos(Fe) * Ae),
                        De = nt.clone().multiplyScalar(pe).add(q);
                    sn(De, oe, M), y.push(M.x, M.y, M.z), sn(nt, oe, E), A.push(E.x, E.y, E.z), w.push(ie, .5 + M.y / r), se.push(C++)
                }
            }

            function ye(se, ie, oe, he, pe) {
                let q = new Tt.Vector3,
                    Ae = new Tt.Vector2,
                    ke = [oe, he];
                pe < 0 && ke.reverse();
                for (let Ce of ke) Ae.set(Ce, S * pe), sn(Ae, ie, q), y.push(q.x, q.y, q.z), A.push(0, pe, 0), w.push(.5, .5), se.push(C++)
            }

            function Se(se, ie, oe) {
                let he = new Tt.Vector2(Math.sin(oe), Math.cos(oe)),
                    pe = new Tt.Vector2(-Math.cos(oe), Math.sin(oe)),
                    q = new Tt.Vector3,
                    Ae = se < 0 ? (Te, Fe, nt) => g.push(Te, Fe, nt) : (Te, Fe, nt) => g.push(Te, nt, Fe),
                    ke = new Tt.Vector2((e + t + Z + le) / 4, 0);
                sn(ke, he, q), y.push(q.x, q.y, q.z), A.push(pe.x, 0, pe.y), w.push(.5, .5);
                let Ce = C++;
                for (let Te of ie) {
                    let Fe = y.slice(Te * 3, Te * 3 + 3);
                    y.push(...Fe), A.push(pe.x, 0, pe.y);
                    let nt = w.slice(Te * 2, Te * 2 + 2);
                    w.push(...nt), C++
                }
                for (let Te = Ce + 1; Te < C - 1; Te++) Ae(Ce, Te, Te + 1);
                Ae(Ce, C - 1, Ce + 1)
            }
        }
    };
    var Id = class {
        static create(n) {
            return this.build(this.normalizeInputs(n))
        }
        static normalizeInputs(n, e) {
            let t = Object.assign({}, e?.parameters ?? {
                width: 100,
                radialSegments: 32,
                heightSegments: 32,
                openEnded: !1,
                thetaStart: 0,
                thetaLength: 360,
                cornerRadiusTop: 0,
                cornerRadiusBottom: 0,
                cornerSegments: 8
            }, n.parameters);
            return {
                parameters: Object.assign(t, {
                    width: Math.abs(t.width),
                    height: Math.abs(t.height ?? t.width),
                    depth: Math.abs(t.depth ?? t.width)
                })
            }
        }
        static build(n) {
            let {
                width: e,
                depth: t,
                height: r,
                radialSegments: i,
                heightSegments: s,
                openEnded: o,
                thetaStart: l,
                thetaLength: a,
                cornerRadiusTop: c,
                cornerRadiusBottom: f,
                cornerSegments: h
            } = n.parameters, m;
            return c > 0 || f > 0 || a < 360 ? m = new cl(0, e / 2, r, i, s, o, l, a * Math.PI / 180, c, f, h, 0, !0) : m = new Ls.ConeBufferGeometry(e / 2, r, i, s, o), m.scale(1, 1, t / e), Object.assign(m, {
                userData: je(Ne({}, n), {
                    type: "ConeGeometry"
                })
            })
        }
    };
    var Ar = W(J()),
        Ld = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    widthSegments: 1,
                    heightSegments: 1,
                    depthSegments: 1,
                    cornerRadius: 0,
                    cornerSegments: 8
                }, n.parameters);
                return {
                    parameters: Object.assign(t, {
                        width: Math.abs(t.width),
                        height: Math.abs(t.height ?? t.width),
                        depth: Math.abs(t.depth ?? t.width)
                    })
                }
            }
            static build(n) {
                let {
                    width: e,
                    height: t,
                    depth: r,
                    widthSegments: i,
                    heightSegments: s,
                    depthSegments: o,
                    cornerRadius: l,
                    cornerSegments: a
                } = n.parameters, c;
                return l == 0 ? c = new Ar.BoxBufferGeometry(e, t, r, i, s, o) : c = new Dd(e, t, r, i, s, o, l, a), Object.assign(c, {
                    userData: je(Ne({}, n), {
                        type: "CubeGeometry"
                    })
                })
            }
        },
        fu = Math.PI / 2,
        Dd = class extends Ar.BufferGeometry {
            constructor(e = 1, t = 1, r = 1, i = 1, s = 1, o = 1, l = 0, a = 4) {
                super();
                this.type = "BoxBufferGeometry";
                let c = this;
                i = Math.floor(i), s = Math.floor(s), o = Math.floor(o), a = Math.floor(a), l = Math.min(l, e / 2, t / 2, r / 2);
                let f = [],
                    h = [],
                    m = [],
                    v = [],
                    g = 0,
                    y = 0;
                A("z", "y", "x", -1, -1, r, t, e, o, s, 0), A("z", "y", "x", 1, -1, r, t, -e, o, s, 1), A("x", "z", "y", 1, 1, e, r, t, i, o, 2), A("x", "z", "y", 1, -1, e, r, -t, i, o, 3), A("x", "y", "z", 1, -1, e, t, r, i, s, 4), A("x", "y", "z", -1, -1, e, t, -r, i, s, 5), l > 0 && (w("z", "y", "x", -1, -1, 1, r, t, e, o, 0), w("z", "y", "x", 1, -1, -1, r, t, e, o, 1), w("z", "y", "x", -1, 1, -1, r, t, e, o, 1), w("z", "y", "x", 1, 1, 1, r, t, e, o, 0), w("x", "y", "z", -1, -1, -1, e, t, r, i, 0), w("x", "y", "z", 1, -1, 1, e, t, r, i, 1), w("x", "y", "z", -1, 1, 1, e, t, r, i, 0), w("x", "y", "z", 1, 1, -1, e, t, r, i, 1), w("y", "x", "z", -1, -1, 1, t, e, r, s, 0), w("y", "x", "z", 1, -1, -1, t, e, r, s, 1), w("y", "x", "z", 1, 1, 1, t, e, r, s, 1), w("y", "x", "z", -1, 1, -1, t, e, r, s, 0), C(1, 1, 1), C(-1, 1, 1), C(1, -1, 1), C(-1, -1, 1), C(1, 1, -1), C(-1, 1, -1), C(1, -1, -1), C(-1, -1, -1)), this.setIndex(f), this.setAttribute("position", new Ar.Float32BufferAttribute(h, 3)), this.setAttribute("normal", new Ar.Float32BufferAttribute(m, 3)), this.setAttribute("uv", new Ar.Float32BufferAttribute(v, 2));

                function A(S, E, M, L, I, z, O, X, k, Q, te) {
                    let Z = (z - 2 * l) / k,
                        le = (O - 2 * l) / Q,
                        B = z / 2 - l,
                        U = O / 2 - l,
                        G = X / 2,
                        V = k + 1,
                        j = Q + 1,
                        ne = 0,
                        F = 0,
                        Y = new Ar.Vector3;
                    for (let $ = 0; $ < j; $++) {
                        let re = $ * le - U;
                        for (let fe = 0; fe < V; fe++) {
                            let ye = fe * Z - B;
                            Y[S] = ye * L, Y[E] = re * I, Y[M] = G, h.push(Y.x, Y.y, Y.z), Y[S] = 0, Y[E] = 0, Y[M] = X > 0 ? 1 : -1, m.push(Y.x, Y.y, Y.z), v.push(fe / k), v.push(1 - $ / Q), ne += 1
                        }
                    }
                    for (let $ = 0; $ < Q; $++)
                        for (let re = 0; re < k; re++) {
                            let fe = g + re + V * $,
                                ye = g + re + V * ($ + 1),
                                Se = g + (re + 1) + V * ($ + 1),
                                se = g + (re + 1) + V * $;
                            f.push(fe, ye, se), f.push(ye, Se, se), F += 6
                        }
                    c.addGroup(y, F, te), y += F, g += ne
                }

                function w(S, E, M, L, I, z, O, X, k, Q, te) {
                    let Z = (O - 2 * l) / Q,
                        le = O / 2 - l,
                        B = X / 2 - l,
                        U = k / 2,
                        G = Q + 1,
                        V = 0,
                        j = 0,
                        ne = new Ar.Vector3,
                        F = new Ar.Vector3;
                    for (let Y = 0; Y < a + 1; Y++) {
                        let $ = Y / a * fu,
                            re = Math.sin($) * l,
                            fe = (1 - Math.cos($)) * l,
                            ye = Math.sin($),
                            Se = Math.cos($);
                        ne[E] = (B + re) * I, ne[M] = (U - fe) * z, F[S] = 0, F[E] = ye * Math.sign(ne[E]), F[M] = Se * Math.sign(ne[M]);
                        for (let se = 0; se < G; se++) {
                            let ie = se * Z - le;
                            ne[S] = ie * L, h.push(ne.x, ne.y, ne.z), m.push(F.x, F.y, F.z), v.push(se / Q), v.push(0), V += 1
                        }
                    }
                    for (let Y = 0; Y < a; Y++)
                        for (let $ = 0; $ < Q; $++) {
                            let re = g + $ + G * Y,
                                fe = g + $ + G * (Y + 1),
                                ye = g + ($ + 1) + G * (Y + 1),
                                Se = g + ($ + 1) + G * Y;
                            f.push(re, fe, Se), f.push(fe, ye, Se), j += 6
                        }
                    c.addGroup(y, j, te), y += j, g += V
                }

                function C(S, E, M) {
                    let L = new Ar.Vector3,
                        I = new Ar.Vector3(e / 2, t / 2, r / 2);
                    I.subScalar(l);
                    let z = [],
                        O = S * E * M > 0 ? (k, Q, te) => f.push(k, Q, te) : (k, Q, te) => f.push(k, te, Q);
                    for (let k = 0; k <= a; k++) {
                        let Q = [],
                            te = fu * (1 - k / a),
                            Z = Math.cos(te),
                            le = Math.sin(te),
                            B = 0;
                        for (let U = 0; U <= k; U++) {
                            let G = Math.cos(B),
                                V = Math.sin(B);
                            L.x = Z * G, L.y = le, L.z = Z * V;
                            let j = I.clone().addScaledVector(L, l);
                            h.push(S * j.x, E * j.y, M * j.z), m.push(S * L.x, E * L.y, M * L.z), v.push(0, 0), Q.push(g++), B += fu / k
                        }
                        z.push(Q)
                    }
                    let X = z.length - 1;
                    for (let k = 0; k < X; k++) {
                        let Q = z[k],
                            te = z[k + 1],
                            Z = Q.length - 1;
                        O(Q[0], te[1], te[0]);
                        for (let le = 1; le <= Z; le++) O(Q[le - 1], Q[le], te[le]), O(Q[le], te[le + 1], te[le])
                    }
                }
            }
        };
    var Pd = W(J()),
        Bd = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    detail: 0
                }, n.parameters);
                return {
                    parameters: Object.assign(t, {
                        width: Math.abs(t.width),
                        height: Math.abs(t.height ?? t.width),
                        depth: Math.abs(t.depth ?? t.width)
                    })
                }
            }
            static build(n) {
                let {
                    width: e,
                    height: t,
                    depth: r,
                    detail: i
                } = n.parameters, s = new Pd.DodecahedronBufferGeometry(e * .5, i);
                return s.scale(1, t / e, r / e), Object.assign(s, {
                    userData: je(Ne({}, n), {
                        type: "DodecahedronGeometry"
                    })
                })
            }
        };
    var it = W(J());
    var Ze = W(J()),
        Go = 1e-12,
        zo = class {
            constructor(e) {
                this.position = new Ze.Vector2;
                this.startPosition = new Ze.Vector2;
                this.uuid = Ze.MathUtils.generateUUID();
                this.position = e.clone()
            }
            start() {
                this.reset()
            }
            reset() {
                this.startPosition.copy(this.position)
            }
            applyOffset(e) {
                this.position.copy(this.startPosition).add(e)
            }
            copy(e) {
                return this.position.copy(e.position), this.startPosition.copy(e.startPosition), this
            }
            clone() {
                return new zo(this.position).copy(this)
            }
            toJSON() {
                return [this.position.x, this.position.y]
            }
        },
        ko = class extends zo {
            constructor(e) {
                super(e.position);
                this.parent = e
            }
            copy(e) {
                return super.copy(e), this
            }
            clone() {
                return new ko(this.parent).copy(this)
            }
        },
        on = class extends zo {
            constructor(e, t) {
                super(t);
                this.controls = [];
                this.roundness = 0;
                this.areControlsDirectionsMirrored = !0;
                this.uuid = e, this.controls.push(new ko(this), new ko(this))
            }
            getOppositeControl(e) {
                let t = this.controls.indexOf(e);
                return t === 0 ? this.controls[1] : t === 1 ? this.controls[0] : null
            }
            applyOffsetToControls(e, t = 1) {
                for (let r = 0, i = this.controls.length; r < i; r++) {
                    let s = this.controls[r];
                    this.position.distanceTo(s.position) <= t ? s.position.copy(this.position) : s.applyOffset(e)
                }
            }
            controlsMoved() {
                return !(this.position.equals(this.controls[0].position) && this.position.equals(this.controls[1].position))
            }
            copy(e) {
                return super.copy(e), this.controls[0].copy(e.controls[0]), this.controls[1].copy(e.controls[1]), this.roundness = e.roundness, this.uuid = e.uuid, this
            }
            clone() {
                return new on(this.uuid, this.position).copy(this)
            }
            toJSON() {
                return super.toJSON().concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [this.roundness])
            }
        },
        du = n => n,
        Uo = new Ze.Vector2,
        hu = new Ze.Vector2,
        Qx = new Ze.Vector2,
        Yx = new Ze.Vector2,
        Kx = new Ze.Vector2,
        Xx = new Ze.Vector2,
        Od = new Ze.Vector3,
        Rd = new Ze.Vector3;

    function Fd(n) {
        let e = new Ze.Vector2;
        e.addVectors(n.v0, Uo.subVectors(n.v1, n.v0).multiplyScalar(2 / 3));
        let t = new Ze.Vector2;
        return t.addVectors(n.v2, hu.subVectors(n.v1, n.v2).multiplyScalar(2 / 3)), new Ze.CubicBezierCurve(n.v0, e, t, n.v2)
    }

    function jo(n, e, t = Number.EPSILON) {
        return Math.abs(n - e) < t
    }

    function qx(n, e, t = Number.EPSILON) {
        return n.distanceTo(e) < t
    }

    function Zx(n, e, t = Number.EPSILON) {
        return n.distanceTo(e) < t
    }

    function mu(n, e, t) {
        let r = Math.sqrt(Math.pow(e.x - n.x, 2) + Math.pow(e.y - n.y, 2)),
            i = Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)),
            s = Math.sqrt(Math.pow(t.x - n.x, 2) + Math.pow(t.y - n.y, 2));
        return Math.acos((i * i + r * r - s * s) / (2 * i * r))
    }

    function Gd(n, e, t, r, i) {
        let s = Math.sqrt(Math.pow(e.x - n.x, 2) + Math.pow(e.y - n.y, 2)),
            o = (n.y + e.y) / 2,
            l = (n.x + e.x) / 2,
            a = Math.sqrt(Math.pow(t, 2) - Math.pow(s / 2, 2)) * (n.y - e.y) / s,
            c = Math.sqrt(Math.pow(t, 2) - Math.pow(s / 2, 2)) * (e.x - n.x) / s;
        return r.set(l + a, o + c), i.set(l - a, o - c), [r, i]
    }

    function zd(n, e, t) {
        let r = n.distanceTo(t),
            i = e.distanceTo(t);
        return r < i ? e : n
    }

    function kd(n, e, t, r, i, s) {
        let o = e.x - n.x,
            l = e.y - n.y,
            a = t.x - n.x,
            c = t.y - n.y,
            f = Math.sqrt((o + a) * (o + a) + (l + c) * (l + c)),
            h;
        return mu(e, n, t) > Math.PI && (f *= -1), jo(c, l) ? h = (l + c) * (r / f - .5) * 8 / 3 / (o - a) : h = (o + a) * (r / f - .5) * 8 / 3 / (c - l), i.set(e.x - h * l, e.y + h * o), s.set(t.x + h * c, t.y - h * a), [i, s]
    }

    function pu(n, e) {
        return n.position.equals(n.controls[1].position) && e.position.equals(e.controls[0].position)
    }

    function Ud(n, e, t, r, i = .5) {
        let s = Uo.subVectors(e, n).multiplyScalar(i).add(n),
            o = hu.subVectors(t, e).multiplyScalar(i).add(e),
            l = Qx.subVectors(r, t).multiplyScalar(i).add(t),
            a = s,
            c = Yx.subVectors(o, s).multiplyScalar(i).add(s),
            f = Kx.subVectors(l, o).multiplyScalar(i).add(o),
            h = l,
            m = Xx.subVectors(f, c).multiplyScalar(i).add(c);
        return [n.x, n.y, a.x, a.y, c.x, c.y, m.x, m.y, f.x, f.y, h.x, h.y, r.x, r.y]
    }

    function jd(n, e, t = 12, r = !0) {
        let i = Rd.set(0, 0, 0),
            s, o = 0,
            l = [];
        for (let a = 0; a < e.length; a++) {
            let c = du(e[a]),
                f = Uo,
                h = an(c, t);
            l.push(h);
            for (let m = 0; m <= h; m++)
                if (c instanceof Ze.CubicBezierCurve || c instanceof Ze.QuadraticBezierCurve || c instanceof Ze.LineCurve) {
                    if (c.getPoint(m / h, f), i.set(f.x, f.y, 0), s !== void 0 && Zx(s, i)) continue;
                    s === void 0 && (s = Od), s.copy(i), n.setXYZ(o, i.x, i.y, i.z), o++
                }
        }
        return r && o > 1 && !(n.getX(o - 1) === n.getX(0) && n.getY(o - 1) === n.getY(0) && n.getZ(o - 1) === n.getZ(0)) && (n.setXYZ(o, n.getX(0), n.getY(0), n.getZ(0)), o++), n
    }

    function Vd(n, e, t, r = 12, i = !0) {
        let s = Rd.set(0, 0, 0),
            o = 0,
            l = [];
        for (let a = 0; a < e.length; a++) {
            if (t[a] === !1) continue;
            let c, f = du(e[a]),
                h = Uo,
                m = an(f, r);
            l.push(m);
            for (let v = 0; v <= m; v++)
                if (f instanceof Ze.CubicBezierCurve || f instanceof Ze.QuadraticBezierCurve || f instanceof Ze.LineCurve) {
                    if (f.getPoint(v / m, h), s.set(h.x, h.y, 0), c?.equals(s)) continue;
                    c === void 0 ? c = Od : (n.setXYZ(o, c.x, c.y, c.z), o++, n.setXYZ(o, s.x, s.y, s.z), o++), c.copy(s)
                }
        }
        return i && o > 1 && !(n.getX(o - 1) === n.getX(0) && n.getY(o - 1) === n.getY(0) && n.getZ(o - 1) === n.getZ(0)) && (n.setXYZ(o, n.getX(0), n.getY(0), n.getZ(0)), o++), l
    }

    function gu(n, e = 12, t = !1) {
        let r = [];
        for (let i = 0, s = n.length; i < s; i++) {
            let o = n[i],
                l = 0;
            if (t && o.roundedCurveCorner !== void 0) {
                let a = an(o.roundedCurveCorner, e) * .5;
                i > 0 && (r[i - 1] += a), l += a
            }
            o.curveAfter !== void 0 && (l += an(o.curveAfter, e)), r.push(l)
        }
        return n.length > 0 && t && n[0].roundedCurveCorner !== void 0 && (r[n.length - 1] += an(n[0].roundedCurveCorner, e) * .5), r
    }

    function an(n, e = 12) {
        return n && n instanceof Ze.EllipseCurve ? e * 2 : n && (n instanceof Ze.LineCurve || n instanceof Ze.LineCurve3) ? 1 : n && n instanceof Ze.SplineCurve ? e * n.points.length : e
    }

    function Hd(n, e, t = 12, r = !0) {
        let i, s = 0;
        for (let o = 0; o < e.length; o++) {
            let l = du(e[o]),
                a = an(l, t),
                c = Uo;
            for (let f = 0; f <= a; f++)
                if (l instanceof Ze.CubicBezierCurve || l instanceof Ze.QuadraticBezierCurve || l instanceof Ze.LineCurve) {
                    if (l.getPoint(f / a, c), i !== void 0 && qx(i, c, Go)) continue;
                    i === void 0 && (i = hu), i.copy(c), n.push(c.x, c.y), s++
                }
        }
        return jo(n[0], n[n.length - 2], Go) && jo(n[1], n[n.length - 1], Go) && (n.pop(), n.pop()), r && s > 1 && !(jo(n[s - 1], n[1], Go) && jo(n[s - 2], n[0], Go)) && (n.push(n[0], n[1]), s++), n
    }
    var vu = new it.Vector2,
        $x = new it.Vector2,
        e0 = new it.Vector2,
        t0 = new it.Vector2,
        r0 = new it.Vector2,
        i0 = new it.Vector2,
        Ot = class extends it.Shape {
            constructor(e = 100, t = 100) {
                super();
                this.points = [];
                this.shapeHoles = [];
                this.eventDispatcher = new it.EventDispatcher;
                this.plane = new it.Plane(new it.Vector3(0, 0, -1));
                this.subdivision = 0;
                this.controlSnapDistance = 4;
                this.pointIDs = 0;
                this.isMesh2D = !1;
                this._roundness = 0;
                this.isClosed = !1;
                this.useCubicForRoundedCorners = !0;
                this.uuid = it.MathUtils.generateUUID();
                this.needsUpdate = !1;
                this.roundedCurves = [];
                this._width = e, this._height = t
            }
            get width() {
                return this._width
            }
            get height() {
                return this._height
            }
            get roundness() {
                return this._roundness
            }
            set roundness(e) {
                if (this._roundness !== e) {
                    this._roundness = e;
                    for (let t = 0, r = this.points.length; t < r; t++) this.points[t].roundness = e;
                    this.needsUpdate = !0
                }
            }
            getBezierPoint(e) {
                if (e <= this.points.length - 1) return this.points[e];
                if (this.shapeHoles.length > 0)
                    for (let t = 0, r = this.shapeHoles.length; t < r; t++) {
                        let i = this.shapeHoles[t],
                            s = e - this.points.length;
                        if (s <= i.points.length - 1) return i.points[s]
                    }
                throw new Error("This shape does not have a point for this index: " + e)
            }
            getBezierPointIndex(e) {
                let t = this.points.indexOf(e);
                if (t >= 0) return t;
                if (t = this.points.length, this.shapeHoles.length > 0)
                    for (let r = 0, i = this.shapeHoles.length; r < i; r++) {
                        let s = this.shapeHoles[r],
                            o = s.points.indexOf(e);
                        if (o >= 0) return t + o;
                        t += s.points.length
                    }
                return -1
            }
            getAllPoints() {
                let e = [].concat(...this.shapeHoles.map(t => t.points));
                return [...this.points, ...e]
            }
            applySize(e, t) {
                e === 0 && (e = .001), t === 0 && (t = .001), this.applyScale(e / this.width, t / this.height), this._width = e, this._height = t
            }
            applyScale(e, t) {
                let r = vu.set(e, t);
                for (let i = 0, s = this.points.length; i < s; i++) {
                    let o = this.points[i];
                    o.position.multiply(r), o.controls[0].position.multiply(r), o.controls[1].position.multiply(r)
                }
                for (let i = 0, s = this.shapeHoles.length; i < s; i++) this.shapeHoles[i].applyScale(e, t);
                this._update(!1)
            }
            createPoint(e, t = 0, r = it.MathUtils.generateUUID()) {
                let i;
                e instanceof it.Vector2 ? i = e : i = new it.Vector2(e, t);
                let s = new on(r, i);
                return s.roundness = this.roundness, s
            }
            addPoint(e) {
                this.points.push(e), this.needsUpdate = !0
            }
            addPointAt(e, t) {
                this.points.splice(t, 0, e), this.needsUpdate = !0
            }
            getPointByUuid(e) {
                for (let t = 0, r = this.points.length; t < r; t++) {
                    let i = this.points[t];
                    if (i.uuid === e) return i
                }
                return null
            }
            getFirstPoint() {
                return this.points[0]
            }
            getLastPoint() {
                return this.points[this.points.length - 1]
            }
            removePoint(e) {
                let t = this.points.indexOf(e);
                t >= 0 && this.points.splice(t, 1), this.needsUpdate = !0
            }
            update(e = !0) {
                for (let t = 0, r = this.shapeHoles.length; t < r; t++) this.shapeHoles[t].update(!1);
                this._update(e)
            }
            extractShapePointsToBuffer(e, t = 12, r = !1) {
                this.subdivision = t, this.curveDivisions === void 0 && this.computeCurveDivisions(t);
                let i = r ? this.roundedCurveDivisions : this.curveDivisions;
                return jd(e, r ? this.roundedCurves : this.curves, t, this.autoClose), i.reduce((s, o) => s + o, 0) + 1
            }
            computeCurveDivisions(e = 12) {
                this.curveDivisions = gu(this.points, e, !1), this.roundedCurveDivisions = gu(this.points, e, !0)
            }
            extractFilteredShapePointsToBuffer(e, t, r = 12) {
                return Vd(e, this.curves, t, r, this.autoClose).reduce((s, o) => s + o, 0) * 2
            }
            extractShapePointsToFlatArray(e, t = 12) {
                return this.subdivision = t, this.curveDivisions === void 0 && this.computeCurveDivisions(t), Hd(e, this.roundedCurves, t, this.autoClose)
            }
            getCurveIndexFromVertexId(e, t = !1) {
                let r = 0;
                this.curveDivisions === void 0 && this.computeCurveDivisions(this.subdivision);
                let i = t ? this.roundedCurveDivisions : this.curveDivisions,
                    s = 0;
                t && this.points[0].roundedCurveCorner !== void 0 && (s = an(this.points[0].roundedCurveCorner, this.subdivision) * .5);
                let o = e - s;
                o < 0 && (o += i.reduce((l, a) => l + a, 0));
                for (let l = 0, a = i.length; l < a; l++) {
                    let c = i[l];
                    if (o < r + c) return [l, (o - r + 1) / c];
                    r += c
                }
                return [0, 1]
            }
            getCurveT(e, t, r) {
                let i = this.points[e],
                    s = this.points[e >= this.points.length - 1 ? 0 : e + 1],
                    o = this.curveDivisions,
                    l = o[e];
                if (pu(i, s)) {
                    let f = i.position.distanceTo(s.position);
                    return i.position.distanceTo(vu.set(r.x, r.y)) / f
                }
                let a = 0;
                for (let f = 0; f < e; f++) a += o[f];
                return (t - a) / l
            }
            dispose() {
                this.eventDispatcher = null
            }
            _applyCurveForPoint(e, t) {
                pu(t, e) ? this.lineTo(e.position.x, e.position.y) : this.bezierCurveTo(t.controls[1].position.x, t.controls[1].position.y, e.controls[0].position.x, e.controls[0].position.y, e.position.x, e.position.y);
                let r = this.curves[this.curves.length - 1];
                e.curveBefore = r, t.curveAfter = r;
                let i = r.clone();
                e.roundedCurveBefore = i, t.roundedCurveAfter = i, e.roundedCurveCorner = void 0, this.roundedCurves.push(i)
            }
            _update(e = !0) {
                this.curves = [], this.roundedCurves = [];
                for (let r = 0, i = this.points.length; r < i; r++) {
                    let s = this.points[r];
                    if (r === 0) this.moveTo(s.position.x, s.position.y);
                    else {
                        let o = this.points[r - 1];
                        this._applyCurveForPoint(s, o)
                    }
                }
                let t = this.getLastPoint();
                if (t?.curveAfter && (t.curveAfter = void 0), this.isClosed) {
                    let r = this.points[0],
                        i = this.points[this.points.length - 1];
                    this._applyCurveForPoint(r, i)
                }
                if (this.points.length > 2) {
                    let r = 0;
                    for (let i = 0, s = this.points.length; i < s; i++) {
                        let o = this.points[i],
                            l = o.roundness;
                        if (!o.controlsMoved() && l > 0) {
                            let a = o.curveBefore,
                                c = o.curveAfter;
                            if (a === void 0 || c === void 0) continue;
                            let f = o.roundedCurveBefore,
                                h = o.roundedCurveAfter,
                                m = a.getLength(),
                                v = c.getLength(),
                                g = Math.min(l, m * .499),
                                y = Math.min(l, v * .499),
                                A = Math.min(g, y),
                                w = 1 - A / m,
                                C = A / v,
                                S = a.getPointAt(w, vu),
                                E = c.getPointAt(C, $x);
                            this._subSplitCurve(a, f, w, S, void 0), this._subSplitCurve(c, h, C, void 0, E);
                            let M;
                            if (this.useCubicForRoundedCorners) {
                                let L = mu(S, o.position, E) / 2,
                                    I = Math.tan(L) * S.distanceTo(o.position),
                                    [z, O] = Gd(S, E, I, e0, t0),
                                    X = zd(z, O, o.position),
                                    [k, Q] = kd(X, S, E, I, r0, i0);
                                M = new it.CubicBezierCurve(S.clone(), k.clone(), Q.clone(), E.clone())
                            } else M = new it.QuadraticBezierCurve(S.clone(), o.position.clone(), E.clone());
                            o.roundedCurveCorner = M, this.roundedCurves.splice(i + r, 0, M), r++
                        }
                    }
                }
                e && this.eventDispatcher?.dispatchEvent({
                    type: "update"
                })
            }
            _subSplitCurve(e, t, r, i, s) {
                if (e instanceof it.LineCurve) i !== void 0 && t.v2.copy(i), s !== void 0 && t.v1.copy(s);
                else {
                    let o = e,
                        l = t,
                        a = o.getUtoTmapping(r, 0),
                        c = Ud(o.v0, o.v1, o.v2, o.v3, a);
                    return i !== void 0 && (l.v0.set(c[0], c[1]), l.v1.set(c[2], c[3]), l.v2.set(c[4], c[5]), l.v3.set(c[6], c[7])), s !== void 0 && (l.v0.set(c[6], c[7]), l.v1.set(c[8], c[9]), l.v2.set(c[10], c[11]), l.v3.set(c[12], c[13])), l
                }
                return t
            }
            clone() {
                let e = new Ot(this._width, this._height);
                return e.points = this.points.map(t => t.clone()), e.isClosed = this.isClosed, e.roundness = this.roundness, e.isMesh2D = this.isMesh2D, e
            }
            toJSON() {
                return {
                    points: this.points.reduce((e, t) => e.concat(t.toJSON()), []),
                    shapeHoles: this.shapeHoles.map(e => e.toJSON()),
                    isClosed: this.isClosed,
                    roundness: this.roundness
                }
            }
            fromJSON(e) {
                this.points = [], this.pointIDs = 0;
                let t = e.points.length / 7;
                for (let r = 0; r < t; r++) {
                    let i = r * 7,
                        s = e.points[i + 0],
                        o = e.points[i + 1],
                        l = e.points[i + 2],
                        a = e.points[i + 3],
                        c = e.points[i + 4],
                        f = e.points[i + 5],
                        h = e.points[i + 6],
                        m = new on(it.MathUtils.generateUUID(), new it.Vector2(s, o));
                    m.controls[0].position.set(l, a), m.controls[1].position.set(c, f), m.roundness = h, this.points.push(m)
                }
                return this.shapeHoles = e.shapeHoles?.length ? e.shapeHoles.map(r => {
                    let i = new Ot;
                    return i.fromJSON(r), i
                }) : [], this.isClosed = e.isClosed, this._roundness = e.roundness, this._update(), this
            }
            fromShape(e) {
                let t = (i, s) => {
                        s instanceof it.CubicBezierCurve && s.v3.equals(i.position) && i.controls[0].position.copy(s.v2)
                    },
                    r = i => {
                        let s = [],
                            o, l;
                        for (o = 0, l = i.length; o < l; o++) i[o] instanceof it.QuadraticBezierCurve && (i[o] = Fd(i[o]));
                        for (o = 0, l = i.length; o < l; o++) {
                            let f = i[o],
                                h = o > 0 ? i[o - 1] : null,
                                m;
                            f instanceof it.CubicBezierCurve ? (m = this.createPoint(f.v0), m.controls[1].position.copy(f.v1)) : f instanceof it.LineCurve && (m = this.createPoint(f.v1)), m !== void 0 && (h !== null && t(m, h), s.push(m))
                        }
                        let a = i[i.length - 1],
                            c = !1;
                        return a instanceof it.CubicBezierCurve ? a.v3.equals(s[0].position) && (s[0].controls[0].position.copy(a.v2), c = !0) : a instanceof it.LineCurve && a.v2.equals(s[0].position) && (c = !0), this.isClosed = c, s
                    };
                return this.points = r(e.curves), e instanceof it.Shape && (this.shapeHoles = e.holes.map(i => {
                    let s = new Ot;
                    return s.fromShape(i), s
                })), this.update(), this
            }
        };
    var yu = Math.PI * 2;

    function xu({
        x: n,
        y: e
    }, t, r, i, s) {
        return {
            x: n * t + i,
            y: e * r + s
        }
    }

    function n0(n, e) {
        let t = e === 1.5707963267948966 ? .551915024494 : e === -1.5707963267948966 ? -.551915024494 : 4 / 3 * Math.tan(e / 4),
            r = Math.cos(n),
            i = Math.sin(n),
            s = Math.cos(n + e),
            o = Math.sin(n + e);
        return [{
            x: r - i * t,
            y: i + r * t
        }, {
            x: s + o * t,
            y: o - s * t
        }, {
            x: s,
            y: o
        }]
    }

    function Wd(n, e, t, r) {
        let i = n * r - e * t < 0 ? -1 : 1,
            s = Math.min(1, Math.max(-1, n * t + e * r));
        return i * Math.acos(s)
    }

    function s0(n, e, t, r, i, s, o, l, a, c) {
        let f = Math.pow(i, 2),
            h = Math.pow(s, 2),
            m = Math.pow(o, 2),
            v = Math.pow(l, 2),
            g = f * h - f * v - h * m;
        g < 0 && (g = 0), g /= f * v + h * m, g = Math.sqrt(g) * (a === c ? -1 : 1);
        let y = g * i / s * l,
            A = g * -s / i * o,
            w = y + (n + t) / 2,
            C = A + (e + r) / 2,
            S = (o - y) / i,
            E = (l - A) / s,
            M = (-o - y) / i,
            L = (-l - A) / s,
            I = Wd(1, 0, S, E),
            z = Wd(S, E, M, L);
        return !c && z > 0 && (z -= yu), c && z < 0 && (z += yu), {
            centerx: w,
            centery: C,
            ang1: I,
            ang2: z
        }
    }

    function Jd({
        px: n,
        py: e,
        cx: t,
        cy: r,
        rx: i,
        ry: s,
        largeArcFlag: o,
        sweepFlag: l
    }) {
        let a = [];
        if (i === 0 || s === 0) return [];
        let c = (n - t) / 2,
            f = (e - r) / 2;
        if (c === 0 && f === 0) return [];
        i = Math.abs(i), s = Math.abs(s);
        let h = Math.pow(c, 2) / Math.pow(i, 2) + Math.pow(f, 2) / Math.pow(s, 2);
        h > 1 && (i *= Math.sqrt(h), s *= Math.sqrt(h));
        let m = s0(n, e, t, r, i, s, c, f, o, l),
            {
                ang1: v,
                ang2: g
            } = m,
            {
                centerx: y,
                centery: A
            } = m,
            w = Math.abs(g) / (yu / 4);
        Math.abs(1 - w) < 1e-7 && (w = 1);
        let C = Math.max(Math.ceil(w), 1);
        g /= C;
        for (let S = 0; S < C; S++) a.push(n0(v, g)), v += g;
        return a.map(S => {
            let {
                x: E,
                y: M
            } = xu(S[0], i, s, y, A), {
                x: L,
                y: I
            } = xu(S[1], i, s, y, A), {
                x: z,
                y: O
            } = xu(S[2], i, s, y, A);
            return {
                x1: E,
                y1: M,
                x2: L,
                y2: I,
                x: z,
                y: O
            }
        })
    }
    var Bn = W(J());
    var It;
    (function(n) {
        n[n.ODD = 0] = "ODD", n[n.NONZERO = 1] = "NONZERO", n[n.POSITIVE = 2] = "POSITIVE", n[n.NEGATIVE = 3] = "NEGATIVE", n[n.ABS_GEQ_TWO = 4] = "ABS_GEQ_TWO"
    })(It || (It = {}));
    var Yt;
    (function(n) {
        n[n.POLYGONS = 0] = "POLYGONS", n[n.CONNECTED_POLYGONS = 1] = "CONNECTED_POLYGONS", n[n.BOUNDARY_CONTOURS = 2] = "BOUNDARY_CONTOURS"
    })(Yt || (Yt = {}));

    function Ie(n, e) {
        if (!n) throw e || "Assertion Failed!"
    }
    var Ee = function() {
            function n() {}
            return n.vertEq = function(e, t) {
                return e.s === t.s && e.t === t.t
            }, n.vertLeq = function(e, t) {
                return e.s < t.s || e.s === t.s && e.t <= t.t
            }, n.transLeq = function(e, t) {
                return e.t < t.t || e.t === t.t && e.s <= t.s
            }, n.edgeGoesLeft = function(e) {
                return n.vertLeq(e.Dst, e.Org)
            }, n.edgeGoesRight = function(e) {
                return n.vertLeq(e.Org, e.Dst)
            }, n.vertL1dist = function(e, t) {
                return Math.abs(e.s - t.s) + Math.abs(e.t - t.t)
            }, n.edgeEval = function(e, t, r) {
                Ie(n.vertLeq(e, t) && n.vertLeq(t, r));
                var i = t.s - e.s,
                    s = r.s - t.s;
                return i + s > 0 ? i < s ? t.t - e.t + (e.t - r.t) * (i / (i + s)) : t.t - r.t + (r.t - e.t) * (s / (i + s)) : 0
            }, n.edgeSign = function(e, t, r) {
                Ie(n.vertLeq(e, t) && n.vertLeq(t, r));
                var i = t.s - e.s,
                    s = r.s - t.s;
                return i + s > 0 ? (t.t - r.t) * i + (t.t - e.t) * s : 0
            }, n.transEval = function(e, t, r) {
                Ie(n.transLeq(e, t) && n.transLeq(t, r));
                var i = t.t - e.t,
                    s = r.t - t.t;
                return i + s > 0 ? i < s ? t.s - e.s + (e.s - r.s) * (i / (i + s)) : t.s - r.s + (r.s - e.s) * (s / (i + s)) : 0
            }, n.transSign = function(e, t, r) {
                Ie(n.transLeq(e, t) && n.transLeq(t, r));
                var i = t.t - e.t,
                    s = r.t - t.t;
                return i + s > 0 ? (t.s - r.s) * i + (t.s - e.s) * s : 0
            }, n.vertCCW = function(e, t, r) {
                return e.s * (t.t - r.t) + t.s * (r.t - e.t) + r.s * (e.t - t.t) >= 0
            }, n.interpolate = function(e, t, r, i) {
                return e = e < 0 ? 0 : e, r = r < 0 ? 0 : r, e <= r ? r === 0 ? (t + i) / 2 : t + (i - t) * (e / (e + r)) : i + (t - i) * (r / (e + r))
            }, n.intersect = function(e, t, r, i, s) {
                var o, l, a;
                n.vertLeq(e, t) || (a = e, e = t, t = a), n.vertLeq(r, i) || (a = r, r = i, i = a), n.vertLeq(e, r) || (a = e, e = r, r = a, a = t, t = i, i = a), n.vertLeq(r, t) ? n.vertLeq(t, i) ? (o = n.edgeEval(e, r, t), l = n.edgeEval(r, t, i), o + l < 0 && (o = -o, l = -l), s.s = n.interpolate(o, r.s, l, t.s)) : (o = n.edgeSign(e, r, t), l = -n.edgeSign(e, i, t), o + l < 0 && (o = -o, l = -l), s.s = n.interpolate(o, r.s, l, i.s)) : s.s = (r.s + t.s) / 2, n.transLeq(e, t) || (a = e, e = t, t = a), n.transLeq(r, i) || (a = r, r = i, i = a), n.transLeq(e, r) || (a = e, e = r, r = a, a = t, t = i, i = a), n.transLeq(r, t) ? n.transLeq(t, i) ? (o = n.transEval(e, r, t), l = n.transEval(r, t, i), o + l < 0 && (o = -o, l = -l), s.t = n.interpolate(o, r.t, l, t.t)) : (o = n.transSign(e, r, t), l = -n.transSign(e, i, t), o + l < 0 && (o = -o, l = -l), s.t = n.interpolate(o, r.t, l, i.t)) : s.t = (r.t + t.t) / 2
            }, n
        }(),
        Vo = function() {
            function n() {
                this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1
            }
            return n
        }(),
        ul = function() {
            function n(e) {
                this.side = e, this.next = null, this.Org = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Lface = null, this.activeRegion = null, this.winding = 0
            }
            return Object.defineProperty(n.prototype, "Rface", {
                get: function() {
                    return this.Sym.Lface
                },
                set: function(e) {
                    this.Sym.Lface = e
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(n.prototype, "Dst", {
                get: function() {
                    return this.Sym.Org
                },
                set: function(e) {
                    this.Sym.Org = e
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(n.prototype, "Oprev", {
                get: function() {
                    return this.Sym.Lnext
                },
                set: function(e) {
                    this.Sym.Lnext = e
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(n.prototype, "Lprev", {
                get: function() {
                    return this.Onext.Sym
                },
                set: function(e) {
                    this.Onext.Sym = e
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(n.prototype, "Dprev", {
                get: function() {
                    return this.Lnext.Sym
                },
                set: function(e) {
                    this.Lnext.Sym = e
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(n.prototype, "Rprev", {
                get: function() {
                    return this.Sym.Onext
                },
                set: function(e) {
                    this.Sym.Onext = e
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(n.prototype, "Dnext", {
                get: function() {
                    return this.Sym.Onext.Sym
                },
                set: function(e) {
                    this.Sym.Onext.Sym = e
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(n.prototype, "Rnext", {
                get: function() {
                    return this.Sym.Lnext.Sym
                },
                set: function(e) {
                    this.Sym.Lnext.Sym = e
                },
                enumerable: !0,
                configurable: !0
            }), n
        }(),
        Ds = function() {
            function n() {
                this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0
            }
            return n
        }(),
        Qd = function() {
            function n() {
                var e = new Ds,
                    t = new Vo,
                    r = new ul(0),
                    i = new ul(1);
                e.next = e.prev = e, e.anEdge = null, t.next = t.prev = t, r.next = r, r.Sym = i, i.next = i, i.Sym = r, this.vHead = e, this.fHead = t, this.eHead = r, this.eHeadSym = i
            }
            return n.prototype.makeEdge_ = function(e) {
                var t = new ul(0),
                    r = new ul(1);
                e.Sym.side < e.side && (e = e.Sym);
                var i = e.Sym.next;
                return r.next = i, i.Sym.next = t, t.next = e, e.Sym.next = r, t.Sym = r, t.Onext = t, t.Lnext = r, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, r.Sym = t, r.Onext = r, r.Lnext = t, r.Org = null, r.Lface = null, r.winding = 0, r.activeRegion = null, t
            }, n.prototype.splice_ = function(e, t) {
                var r = e.Onext,
                    i = t.Onext;
                r.Sym.Lnext = t, i.Sym.Lnext = e, e.Onext = i, t.Onext = r
            }, n.prototype.makeVertex_ = function(e, t, r) {
                var i = e;
                Ie(i, "Vertex can't be null!");
                var s = r.prev;
                i.prev = s, s.next = i, i.next = r, r.prev = i, i.anEdge = t;
                var o = t;
                do o.Org = i, o = o.Onext; while (o !== t)
            }, n.prototype.makeFace_ = function(e, t, r) {
                var i = e;
                Ie(i, "Face can't be null");
                var s = r.prev;
                i.prev = s, s.next = i, i.next = r, r.prev = i, i.anEdge = t, i.trail = null, i.marked = !1, i.inside = r.inside;
                var o = t;
                do o.Lface = i, o = o.Lnext; while (o !== t)
            }, n.prototype.killEdge_ = function(e) {
                e.Sym.side < e.side && (e = e.Sym);
                var t = e.next,
                    r = e.Sym.next;
                t.Sym.next = r, r.Sym.next = t
            }, n.prototype.killVertex_ = function(e, t) {
                var r = e.anEdge,
                    i = r;
                do i.Org = t, i = i.Onext; while (i !== r);
                var s = e.prev,
                    o = e.next;
                o.prev = s, s.next = o
            }, n.prototype.killFace_ = function(e, t) {
                var r = e.anEdge,
                    i = r;
                do i.Lface = t, i = i.Lnext; while (i !== r);
                var s = e.prev,
                    o = e.next;
                o.prev = s, s.next = o
            }, n.prototype.makeEdge = function() {
                var e = new Ds,
                    t = new Ds,
                    r = new Vo,
                    i = this.makeEdge_(this.eHead);
                return this.makeVertex_(e, i, this.vHead), this.makeVertex_(t, i.Sym, this.vHead), this.makeFace_(r, i, this.fHead), i
            }, n.prototype.splice = function(e, t) {
                var r = !1,
                    i = !1;
                if (e !== t) {
                    if (t.Org !== e.Org && (i = !0, this.killVertex_(t.Org, e.Org)), t.Lface !== e.Lface && (r = !0, this.killFace_(t.Lface, e.Lface)), this.splice_(t, e), !i) {
                        var s = new Ds;
                        this.makeVertex_(s, t, e.Org), e.Org.anEdge = e
                    }
                    if (!r) {
                        var o = new Vo;
                        this.makeFace_(o, t, e.Lface), e.Lface.anEdge = e
                    }
                }
            }, n.prototype.delete = function(e) {
                var t = e.Sym,
                    r = !1;
                if (e.Lface !== e.Rface && (r = !0, this.killFace_(e.Lface, e.Rface)), e.Onext === e) this.killVertex_(e.Org, null);
                else if (e.Rface.anEdge = e.Oprev, e.Org.anEdge = e.Onext, this.splice_(e, e.Oprev), !r) {
                    var i = new Vo;
                    this.makeFace_(i, e, e.Lface)
                }
                t.Onext === t ? (this.killVertex_(t.Org, null), this.killFace_(t.Lface, null)) : (e.Lface.anEdge = t.Oprev, t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev)), this.killEdge_(e)
            }, n.prototype.addEdgeVertex = function(e) {
                var t = this.makeEdge_(e),
                    r = t.Sym;
                this.splice_(t, e.Lnext), t.Org = e.Dst;
                var i = new Ds;
                return this.makeVertex_(i, r, t.Org), t.Lface = r.Lface = e.Lface, t
            }, n.prototype.splitEdge = function(e) {
                var t = this.addEdgeVertex(e),
                    r = t.Sym;
                return this.splice_(e.Sym, e.Sym.Oprev), this.splice_(e.Sym, r), e.Dst = r.Org, r.Dst.anEdge = r.Sym, r.Rface = e.Rface, r.winding = e.winding, r.Sym.winding = e.Sym.winding, r.idx = e.idx, r.Sym.idx = e.Sym.idx, r
            }, n.prototype.connect = function(e, t) {
                var r = !1,
                    i = this.makeEdge_(e),
                    s = i.Sym;
                if (t.Lface !== e.Lface && (r = !0, this.killFace_(t.Lface, e.Lface)), this.splice_(i, e.Lnext), this.splice_(s, t), i.Org = e.Dst, s.Org = t.Org, i.Lface = s.Lface = e.Lface, e.Lface.anEdge = s, !r) {
                    var o = new Vo;
                    this.makeFace_(o, i, e.Lface)
                }
                return i
            }, n.prototype.zapFace = function(e) {
                var t = e.anEdge,
                    r, i, s, o, l;
                i = t.Lnext;
                do r = i, i = r.Lnext, r.Lface = null, r.Rface === null && (r.Onext === r ? this.killVertex_(r.Org, null) : (r.Org.anEdge = r.Onext, this.splice_(r, r.Oprev)), s = r.Sym, s.Onext === s ? this.killVertex_(s.Org, null) : (s.Org.anEdge = s.Onext, this.splice_(s, s.Oprev)), this.killEdge_(r)); while (r != t);
                o = e.prev, l = e.next, l.prev = o, o.next = l
            }, n.prototype.countFaceVerts_ = function(e) {
                var t = e.anEdge,
                    r = 0;
                do r++, t = t.Lnext; while (t !== e.anEdge);
                return r
            }, n.prototype.mergeConvexFaces = function(e) {
                var t, r, i, s, o, l, a;
                for (t = this.fHead.next; t !== this.fHead; t = t.next)
                    if (!!t.inside)
                        for (r = t.anEdge, o = r.Org; i = r.Lnext, s = r.Sym, s && s.Lface && s.Lface.inside && (l = this.countFaceVerts_(t), a = this.countFaceVerts_(s.Lface), l + a - 2 <= e && Ee.vertCCW(r.Lprev.Org, r.Org, s.Lnext.Lnext.Org) && Ee.vertCCW(s.Lprev.Org, s.Org, r.Lnext.Lnext.Org) && (i = s.Lnext, this.delete(s), r = null, s = null)), !(r && r.Lnext.Org === o);) r = i;
                return !0
            }, n.prototype.check = function() {
                var e = this.fHead,
                    t = this.vHead,
                    r = this.eHead,
                    i, s, o, l, a, c;
                for (s = e, s = e;
                    (i = s.next) !== e; s = i) {
                    Ie(i.prev === s), a = i.anEdge;
                    do Ie(a.Sym !== a), Ie(a.Sym.Sym === a), Ie(a.Lnext.Onext.Sym === a), Ie(a.Onext.Sym.Lnext === a), Ie(a.Lface === i), a = a.Lnext; while (a !== i.anEdge)
                }
                for (Ie(i.prev === s && i.anEdge === null), l = t, l = t;
                    (o = l.next) !== t; l = o) {
                    Ie(o.prev === l), a = o.anEdge;
                    do Ie(a.Sym !== a), Ie(a.Sym.Sym === a), Ie(a.Lnext.Onext.Sym === a), Ie(a.Onext.Sym.Lnext === a), Ie(a.Org === o), a = a.Onext; while (a !== o.anEdge)
                }
                for (Ie(o.prev === l && o.anEdge === null), c = r, c = r;
                    (a = c.next) !== r; c = a) Ie(a.Sym.next === c.Sym), Ie(a.Sym !== a), Ie(a.Sym.Sym === a), Ie(a.Org !== null), Ie(a.Dst !== null), Ie(a.Lnext.Onext.Sym === a), Ie(a.Onext.Sym.Lnext === a);
                Ie(a.Sym.next === c.Sym && a.Sym === this.eHeadSym && a.Sym.Sym === a && a.Org === null && a.Dst === null && a.Lface === null && a.Rface === null)
            }, n
        }(),
        Yd = function() {
            function n() {
                this.handle = null
            }
            return n
        }(),
        Kd = function() {
            function n() {
                this.key = null, this.node = 0
            }
            return n
        }(),
        o0 = function() {
            function n(e, t) {
                this.leq = t, this.max = 0, this.nodes = [], this.handles = [], this.initialized = !1, this.freeList = 0, this.size = 0, this.max = e, this.nodes = [], this.handles = [];
                for (var r = 0; r < e + 1; r++) this.nodes[r] = new Yd, this.handles[r] = new Kd;
                this.initialized = !1, this.nodes[1].handle = 1, this.handles[1].key = null
            }
            return n.prototype.floatDown_ = function(e) {
                var t = this.nodes,
                    r = this.handles,
                    i, s, o;
                for (i = t[e].handle;;) {
                    if (o = e << 1, o < this.size && this.leq(r[t[o + 1].handle].key, r[t[o].handle].key) && ++o, Ie(o <= this.max), s = t[o].handle, o > this.size || this.leq(r[i].key, r[s].key)) {
                        t[e].handle = i, r[i].node = e;
                        break
                    }
                    t[e].handle = s, r[s].node = e, e = o
                }
            }, n.prototype.floatUp_ = function(e) {
                var t = this.nodes,
                    r = this.handles,
                    i, s, o;
                for (i = t[e].handle;;) {
                    if (o = e >> 1, s = t[o].handle, o === 0 || this.leq(r[s].key, r[i].key)) {
                        t[e].handle = i, r[i].node = e;
                        break
                    }
                    t[e].handle = s, r[s].node = e, e = o
                }
            }, n.prototype.init = function() {
                for (var e = this.size; e >= 1; --e) this.floatDown_(e);
                this.initialized = !0
            }, n.prototype.min = function() {
                return this.handles[this.nodes[1].handle].key
            }, n.prototype.insert = function(e) {
                var t, r;
                if (t = ++this.size, t * 2 > this.max) {
                    this.max *= 2;
                    var i, s;
                    for (s = this.nodes.length, this.nodes.length = this.max + 1, i = s; i < this.nodes.length; i++) this.nodes[i] = new Yd;
                    for (s = this.handles.length, this.handles.length = this.max + 1, i = s; i < this.handles.length; i++) this.handles[i] = new Kd
                }
                return this.freeList === 0 ? r = t : (r = this.freeList, this.freeList = this.handles[r].node), this.nodes[t].handle = r, this.handles[r].node = t, this.handles[r].key = e, this.initialized && this.floatUp_(t), r
            }, n.prototype.extractMin = function() {
                var e = this.nodes,
                    t = this.handles,
                    r = e[1].handle,
                    i = t[r].key;
                return this.size > 0 && (e[1].handle = e[this.size].handle, t[e[1].handle].node = 1, t[r].key = null, t[r].node = this.freeList, this.freeList = r, --this.size, this.size > 0 && this.floatDown_(1)), i
            }, n.prototype.delete = function(e) {
                var t = this.nodes,
                    r = this.handles,
                    i;
                Ie(e >= 1 && e <= this.max && r[e].key !== null), i = r[e].node, t[i].handle = t[this.size].handle, r[t[i].handle].node = i, --this.size, i <= this.size && (i <= 1 || this.leq(r[t[i >> 1].handle].key, r[t[i].handle].key) ? this.floatDown_(i) : this.floatUp_(i)), r[e].key = null, r[e].node = this.freeList, this.freeList = e
            }, n
        }(),
        Au = function() {
            function n() {
                this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1
            }
            return n
        }(),
        Xd = function() {
            function n() {
                this.key = null, this.next = null, this.prev = null
            }
            return n
        }(),
        a0 = function() {
            function n(e, t) {
                this.frame = e, this.leq = t, this.head = new Xd, this.head.next = this.head, this.head.prev = this.head
            }
            return n.prototype.min = function() {
                return this.head.next
            }, n.prototype.max = function() {
                return this.head.prev
            }, n.prototype.insert = function(e) {
                return this.insertBefore(this.head, e)
            }, n.prototype.search = function(e) {
                var t = this.head;
                do t = t.next; while (t.key !== null && !this.leq(this.frame, e, t.key));
                return t
            }, n.prototype.insertBefore = function(e, t) {
                do e = e.prev; while (e.key !== null && !this.leq(this.frame, e.key, t));
                var r = new Xd;
                return r.key = t, r.next = e.next, e.next.prev = r, r.prev = e, e.next = r, r
            }, n.prototype.delete = function(e) {
                e.next.prev = e.prev, e.prev.next = e.next
            }, n
        }(),
        l0 = function() {
            function n() {}
            return n.regionBelow = function(e) {
                return e.nodeUp.prev.key
            }, n.regionAbove = function(e) {
                return e.nodeUp.next.key
            }, n.debugEvent = function(e) {}, n.addWinding = function(e, t) {
                e.winding += t.winding, e.Sym.winding += t.Sym.winding
            }, n.edgeLeq = function(e, t, r) {
                var i = e.event,
                    s = t.eUp,
                    o = r.eUp;
                if (s.Dst === i) return o.Dst === i ? Ee.vertLeq(s.Org, o.Org) ? Ee.edgeSign(o.Dst, s.Org, o.Org) <= 0 : Ee.edgeSign(s.Dst, o.Org, s.Org) >= 0 : Ee.edgeSign(o.Dst, i, o.Org) <= 0;
                if (o.Dst === i) return Ee.edgeSign(s.Dst, i, s.Org) >= 0;
                var l = Ee.edgeEval(s.Dst, i, s.Org),
                    a = Ee.edgeEval(o.Dst, i, o.Org);
                return l >= a
            }, n.deleteRegion = function(e, t) {
                t.fixUpperEdge && Ie(t.eUp.winding === 0), t.eUp.activeRegion = null, e.dict.delete(t.nodeUp)
            }, n.fixUpperEdge = function(e, t, r) {
                Ie(t.fixUpperEdge), e.mesh.delete(t.eUp), t.fixUpperEdge = !1, t.eUp = r, r.activeRegion = t
            }, n.topLeftRegion = function(e, t) {
                var r = t.eUp.Org,
                    i;
                do t = n.regionAbove(t); while (t.eUp.Org === r);
                if (t.fixUpperEdge) {
                    if (i = e.mesh.connect(n.regionBelow(t).eUp.Sym, t.eUp.Lnext), i === null) return null;
                    n.fixUpperEdge(e, t, i), t = n.regionAbove(t)
                }
                return t
            }, n.topRightRegion = function(e) {
                var t = e.eUp.Dst;
                do e = n.regionAbove(e); while (e.eUp.Dst === t);
                return e
            }, n.addRegionBelow = function(e, t, r) {
                var i = new Au;
                return i.eUp = r, i.nodeUp = e.dict.insertBefore(t.nodeUp, i), i.fixUpperEdge = !1, i.sentinel = !1, i.dirty = !1, r.activeRegion = i, i
            }, n.isWindingInside = function(e, t) {
                switch (e.windingRule) {
                    case It.ODD:
                        return (t & 1) != 0;
                    case It.NONZERO:
                        return t !== 0;
                    case It.POSITIVE:
                        return t > 0;
                    case It.NEGATIVE:
                        return t < 0;
                    case It.ABS_GEQ_TWO:
                        return t >= 2 || t <= -2
                }
                throw new Error("Invalid winding rulle")
            }, n.computeWinding = function(e, t) {
                t.windingNumber = n.regionAbove(t).windingNumber + t.eUp.winding, t.inside = n.isWindingInside(e, t.windingNumber)
            }, n.finishRegion = function(e, t) {
                var r = t.eUp,
                    i = r.Lface;
                i.inside = t.inside, i.anEdge = r, n.deleteRegion(e, t)
            }, n.finishLeftRegions = function(e, t, r) {
                for (var i, s = null, o = t, l = t.eUp; o !== r;) {
                    if (o.fixUpperEdge = !1, s = n.regionBelow(o), i = s.eUp, i.Org != l.Org) {
                        if (!s.fixUpperEdge) {
                            n.finishRegion(e, o);
                            break
                        }
                        i = e.mesh.connect(l.Lprev, i.Sym), n.fixUpperEdge(e, s, i)
                    }
                    l.Onext !== i && (e.mesh.splice(i.Oprev, i), e.mesh.splice(l, i)), n.finishRegion(e, o), l = s.eUp, o = s
                }
                return l
            }, n.addRightEdges = function(e, t, r, i, s, o) {
                var l, a, c, f, h = !0;
                c = r;
                do Ie(Ee.vertLeq(c.Org, c.Dst)), n.addRegionBelow(e, t, c.Sym), c = c.Onext; while (c !== i);
                for (s === null && (s = n.regionBelow(t).eUp.Rprev), a = t, f = s; l = n.regionBelow(a), c = l.eUp.Sym, c.Org === f.Org;) c.Onext !== f && (e.mesh.splice(c.Oprev, c), e.mesh.splice(f.Oprev, c)), l.windingNumber = a.windingNumber - c.winding, l.inside = n.isWindingInside(e, l.windingNumber), a.dirty = !0, !h && n.checkForRightSplice(e, a) && (n.addWinding(c, f), n.deleteRegion(e, a), e.mesh.delete(f)), h = !1, a = l, f = c;
                a.dirty = !0, Ie(a.windingNumber - c.winding === l.windingNumber), o && n.walkDirtyRegions(e, a)
            }, n.spliceMergeVertices = function(e, t, r) {
                e.mesh.splice(t, r)
            }, n.vertexWeights = function(e, t, r) {
                var i = Ee.vertL1dist(t, e),
                    s = Ee.vertL1dist(r, e),
                    o = .5 * s / (i + s),
                    l = .5 * i / (i + s);
                e.coords[0] += o * t.coords[0] + l * r.coords[0], e.coords[1] += o * t.coords[1] + l * r.coords[1], e.coords[2] += o * t.coords[2] + l * r.coords[2]
            }, n.getIntersectData = function(e, t, r, i, s, o) {
                t.coords[0] = t.coords[1] = t.coords[2] = 0, t.idx = -1, n.vertexWeights(t, r, i), n.vertexWeights(t, s, o)
            }, n.checkForRightSplice = function(e, t) {
                var r = n.regionBelow(t),
                    i = t.eUp,
                    s = r.eUp;
                if (Ee.vertLeq(i.Org, s.Org)) {
                    if (Ee.edgeSign(s.Dst, i.Org, s.Org) > 0) return !1;
                    Ee.vertEq(i.Org, s.Org) ? i.Org !== s.Org && (e.pq.delete(i.Org.pqHandle), n.spliceMergeVertices(e, s.Oprev, i)) : (e.mesh.splitEdge(s.Sym), e.mesh.splice(i, s.Oprev), t.dirty = r.dirty = !0)
                } else {
                    if (Ee.edgeSign(i.Dst, s.Org, i.Org) < 0) return !1;
                    n.regionAbove(t).dirty = t.dirty = !0, e.mesh.splitEdge(i.Sym), e.mesh.splice(s.Oprev, i)
                }
                return !0
            }, n.checkForLeftSplice = function(e, t) {
                var r = n.regionBelow(t),
                    i = t.eUp,
                    s = r.eUp,
                    o;
                if (Ie(!Ee.vertEq(i.Dst, s.Dst)), Ee.vertLeq(i.Dst, s.Dst)) {
                    if (Ee.edgeSign(i.Dst, s.Dst, i.Org) < 0) return !1;
                    n.regionAbove(t).dirty = t.dirty = !0, o = e.mesh.splitEdge(i), e.mesh.splice(s.Sym, o), o.Lface.inside = t.inside
                } else {
                    if (Ee.edgeSign(s.Dst, i.Dst, s.Org) > 0) return !1;
                    t.dirty = r.dirty = !0, o = e.mesh.splitEdge(s), e.mesh.splice(i.Lnext, s.Sym), o.Rface.inside = t.inside
                }
                return !0
            }, n.checkForIntersect = function(e, t) {
                var r = n.regionBelow(t),
                    i = t.eUp,
                    s = r.eUp,
                    o = i.Org,
                    l = s.Org,
                    a = i.Dst,
                    c = s.Dst,
                    f, h, m = new Ds,
                    v, g;
                if (Ie(!Ee.vertEq(c, a)), Ie(Ee.edgeSign(a, e.event, o) <= 0), Ie(Ee.edgeSign(c, e.event, l) >= 0), Ie(o !== e.event && l !== e.event), Ie(!t.fixUpperEdge && !r.fixUpperEdge), o === l || (f = Math.min(o.t, a.t), h = Math.max(l.t, c.t), f > h)) return !1;
                if (Ee.vertLeq(o, l)) {
                    if (Ee.edgeSign(c, o, l) > 0) return !1
                } else if (Ee.edgeSign(a, l, o) < 0) return !1;
                return n.debugEvent(e), Ee.intersect(a, o, c, l, m), Ie(Math.min(o.t, a.t) <= m.t), Ie(m.t <= Math.max(l.t, c.t)), Ie(Math.min(c.s, a.s) <= m.s), Ie(m.s <= Math.max(l.s, o.s)), Ee.vertLeq(m, e.event) && (m.s = e.event.s, m.t = e.event.t), v = Ee.vertLeq(o, l) ? o : l, Ee.vertLeq(v, m) && (m.s = v.s, m.t = v.t), Ee.vertEq(m, o) || Ee.vertEq(m, l) ? (n.checkForRightSplice(e, t), !1) : !Ee.vertEq(a, e.event) && Ee.edgeSign(a, e.event, m) >= 0 || !Ee.vertEq(c, e.event) && Ee.edgeSign(c, e.event, m) <= 0 ? c === e.event ? (e.mesh.splitEdge(i.Sym), e.mesh.splice(s.Sym, i), t = n.topLeftRegion(e, t), i = n.regionBelow(t).eUp, n.finishLeftRegions(e, n.regionBelow(t), r), n.addRightEdges(e, t, i.Oprev, i, i, !0), !0) : a === e.event ? (e.mesh.splitEdge(s.Sym), e.mesh.splice(i.Lnext, s.Oprev), r = t, t = n.topRightRegion(t), g = n.regionBelow(t).eUp.Rprev, r.eUp = s.Oprev, s = n.finishLeftRegions(e, r, null), n.addRightEdges(e, t, s.Onext, i.Rprev, g, !0), !0) : (Ee.edgeSign(a, e.event, m) >= 0 && (n.regionAbove(t).dirty = t.dirty = !0, e.mesh.splitEdge(i.Sym), i.Org.s = e.event.s, i.Org.t = e.event.t), Ee.edgeSign(c, e.event, m) <= 0 && (t.dirty = r.dirty = !0, e.mesh.splitEdge(s.Sym), s.Org.s = e.event.s, s.Org.t = e.event.t), !1) : (e.mesh.splitEdge(i.Sym), e.mesh.splitEdge(s.Sym), e.mesh.splice(s.Oprev, i), i.Org.s = m.s, i.Org.t = m.t, i.Org.pqHandle = e.pq.insert(i.Org), n.getIntersectData(e, i.Org, o, a, l, c), n.regionAbove(t).dirty = t.dirty = r.dirty = !0, !1)
            }, n.walkDirtyRegions = function(e, t) {
                for (var r = n.regionBelow(t), i, s;;) {
                    for (; r.dirty;) t = r, r = n.regionBelow(r);
                    if (!t.dirty && (r = t, t = n.regionAbove(t), t === null || !t.dirty)) return;
                    if (t.dirty = !1, i = t.eUp, s = r.eUp, i.Dst !== s.Dst && n.checkForLeftSplice(e, t) && (r.fixUpperEdge ? (n.deleteRegion(e, r), e.mesh.delete(s), r = n.regionBelow(t), s = r.eUp) : t.fixUpperEdge && (n.deleteRegion(e, t), e.mesh.delete(i), t = n.regionAbove(r), i = t.eUp)), i.Org !== s.Org)
                        if (i.Dst !== s.Dst && !t.fixUpperEdge && !r.fixUpperEdge && (i.Dst === e.event || s.Dst === e.event)) {
                            if (n.checkForIntersect(e, t)) return
                        } else n.checkForRightSplice(e, t);
                    i.Org === s.Org && i.Dst === s.Dst && (n.addWinding(s, i), n.deleteRegion(e, t), e.mesh.delete(i), t = n.regionAbove(r))
                }
            }, n.connectRightVertex = function(e, t, r) {
                var i, s = r.Onext,
                    o = n.regionBelow(t),
                    l = t.eUp,
                    a = o.eUp,
                    c = !1;
                if (l.Dst !== a.Dst && n.checkForIntersect(e, t), Ee.vertEq(l.Org, e.event) && (e.mesh.splice(s.Oprev, l), t = n.topLeftRegion(e, t), s = n.regionBelow(t).eUp, n.finishLeftRegions(e, n.regionBelow(t), o), c = !0), Ee.vertEq(a.Org, e.event) && (e.mesh.splice(r, a.Oprev), r = n.finishLeftRegions(e, o, null), c = !0), c) {
                    n.addRightEdges(e, t, r.Onext, s, s, !0);
                    return
                }
                Ee.vertLeq(a.Org, l.Org) ? i = a.Oprev : i = l, i = e.mesh.connect(r.Lprev, i), n.addRightEdges(e, t, i, i.Onext, i.Onext, !1), i.Sym.activeRegion.fixUpperEdge = !0, n.walkDirtyRegions(e, t)
            }, n.connectLeftDegenerate = function(e, t, r) {
                var i, s, o, l, a;
                if (i = t.eUp, Ee.vertEq(i.Org, r)) {
                    Ie(!1), n.spliceMergeVertices(e, i, r.anEdge);
                    return
                }
                if (!Ee.vertEq(i.Dst, r)) {
                    e.mesh.splitEdge(i.Sym), t.fixUpperEdge && (e.mesh.delete(i.Onext), t.fixUpperEdge = !1), e.mesh.splice(r.anEdge, i), n.sweepEvent(e, r);
                    return
                }
                Ie(!1), t = n.topRightRegion(t), a = n.regionBelow(t), o = a.eUp.Sym, s = l = o.Onext, a.fixUpperEdge && (Ie(s !== o), n.deleteRegion(e, a), e.mesh.delete(o), o = s.Oprev), e.mesh.splice(r.anEdge, o), Ee.edgeGoesLeft(s) || (s = null), n.addRightEdges(e, t, o.Onext, l, s, !0)
            }, n.connectLeftVertex = function(e, t) {
                var r, i, s, o, l, a, c = new Au;
                if (c.eUp = t.anEdge.Sym, r = e.dict.search(c).key, i = n.regionBelow(r), !!i) {
                    if (o = r.eUp, l = i.eUp, Ee.edgeSign(o.Dst, t, o.Org) === 0) {
                        n.connectLeftDegenerate(e, r, t);
                        return
                    }
                    if (s = Ee.vertLeq(l.Dst, o.Dst) ? r : i, r.inside || s.fixUpperEdge) {
                        if (s === r) a = e.mesh.connect(t.anEdge.Sym, o.Lnext);
                        else {
                            var f = e.mesh.connect(l.Dnext, t.anEdge);
                            a = f.Sym
                        }
                        s.fixUpperEdge ? n.fixUpperEdge(e, s, a) : n.computeWinding(e, n.addRegionBelow(e, r, a)), n.sweepEvent(e, t)
                    } else n.addRightEdges(e, r, t.anEdge, t.anEdge, null, !0)
                }
            }, n.sweepEvent = function(e, t) {
                e.event = t, n.debugEvent(e);
                for (var r = t.anEdge; r.activeRegion === null;)
                    if (r = r.Onext, r === t.anEdge) {
                        n.connectLeftVertex(e, t);
                        return
                    } var i = n.topLeftRegion(e, r.activeRegion);
                Ie(i !== null);
                var s = n.regionBelow(i),
                    o = s.eUp,
                    l = n.finishLeftRegions(e, s, null);
                l.Onext === o ? n.connectRightVertex(e, i, l) : n.addRightEdges(e, i, l.Onext, o, o, !0)
            }, n.addSentinel = function(e, t, r, i) {
                var s = new Au,
                    o = e.mesh.makeEdge();
                o.Org.s = r, o.Org.t = i, o.Dst.s = t, o.Dst.t = i, e.event = o.Dst, s.eUp = o, s.windingNumber = 0, s.inside = !1, s.fixUpperEdge = !1, s.sentinel = !0, s.dirty = !1, s.nodeUp = e.dict.insert(s)
            }, n.initEdgeDict = function(e) {
                e.dict = new a0(e, n.edgeLeq);
                var t = e.bmax[0] - e.bmin[0],
                    r = e.bmax[1] - e.bmin[1],
                    i = e.bmin[0] - t,
                    s = e.bmax[0] + t,
                    o = e.bmin[1] - r,
                    l = e.bmax[1] + r;
                n.addSentinel(e, i, s, o), n.addSentinel(e, i, s, l)
            }, n.doneEdgeDict = function(e) {
                for (var t, r = 0;
                    (t = e.dict.min().key) !== null;) t.sentinel || (Ie(t.fixUpperEdge), Ie(++r == 1)), Ie(t.windingNumber === 0), n.deleteRegion(e, t)
            }, n.removeDegenerateEdges = function(e) {
                var t, r, i, s = e.mesh.eHead;
                for (t = s.next; t !== s; t = r) r = t.next, i = t.Lnext, Ee.vertEq(t.Org, t.Dst) && t.Lnext.Lnext !== t && (n.spliceMergeVertices(e, i, t), e.mesh.delete(t), t = i, i = t.Lnext), i.Lnext === t && (i !== t && ((i === r || i === r.Sym) && (r = r.next), e.mesh.delete(i)), (t === r || t === r.Sym) && (r = r.next), e.mesh.delete(t))
            }, n.initPriorityQ = function(e) {
                var t, r, i, s = 0;
                for (i = e.mesh.vHead, r = i.next; r !== i; r = r.next) s++;
                for (s += 8, t = e.pq = new o0(s, Ee.vertLeq), i = e.mesh.vHead, r = i.next; r !== i; r = r.next) r.pqHandle = t.insert(r);
                return r !== i ? !1 : (t.init(), !0)
            }, n.donePriorityQ = function(e) {
                e.pq = null
            }, n.removeDegenerateFaces = function(e, t) {
                var r, i, s;
                for (r = t.fHead.next; r !== t.fHead; r = i) i = r.next, s = r.anEdge, Ie(s.Lnext !== s), s.Lnext.Lnext === s && (n.addWinding(s.Onext, s), e.mesh.delete(s));
                return !0
            }, n.computeInterior = function(e, t) {
                t === void 0 && (t = !0);
                var r, i;
                if (n.removeDegenerateEdges(e), !n.initPriorityQ(e)) return !1;
                for (n.initEdgeDict(e);
                    (r = e.pq.extractMin()) !== null;) {
                    for (; i = e.pq.min(), !(i === null || !Ee.vertEq(i, r));) i = e.pq.extractMin(), n.spliceMergeVertices(e, r.anEdge, i.anEdge);
                    n.sweepEvent(e, r)
                }
                return e.event = e.dict.min().key.eUp.Org, n.debugEvent(e), n.doneEdgeDict(e), n.donePriorityQ(e), n.removeDegenerateFaces(e, e.mesh) ? (t && e.mesh.check(), !0) : !1
            }, n
        }(),
        c0 = function() {
            function n() {
                this.mesh = new Qd, this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = It.ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0
            }
            return n.prototype.dot_ = function(e, t) {
                return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
            }, n.prototype.normalize_ = function(e) {
                var t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2];
                if (!t) throw "Zero-size vector!";
                t = Math.sqrt(t), e[0] /= t, e[1] /= t, e[2] /= t
            }, n.prototype.longAxis_ = function(e) {
                var t = 0;
                return Math.abs(e[1]) > Math.abs(e[0]) && (t = 1), Math.abs(e[2]) > Math.abs(e[t]) && (t = 2), t
            }, n.prototype.computeNormal_ = function(e) {
                var t, r, i, s, o, l, a = [0, 0, 0],
                    c = [0, 0, 0],
                    f = [0, 0, 0],
                    h = [0, 0, 0],
                    m = [0, 0, 0],
                    v = [null, null, null],
                    g = [null, null, null],
                    y = this.mesh.vHead;
                t = y.next;
                for (var A = 0; A < 3; ++A) s = t.coords[A], c[A] = s, g[A] = t, a[A] = s, v[A] = t;
                for (t = y.next; t !== y; t = t.next)
                    for (var w = 0; w < 3; ++w) s = t.coords[w], s < c[w] && (c[w] = s, g[w] = t), s > a[w] && (a[w] = s, v[w] = t);
                var C = 0;
                if (a[1] - c[1] > a[0] - c[0] && (C = 1), a[2] - c[2] > a[C] - c[C] && (C = 2), c[C] >= a[C]) {
                    e[0] = 0, e[1] = 0, e[2] = 1;
                    return
                }
                for (l = 0, r = g[C], i = v[C], f[0] = r.coords[0] - i.coords[0], f[1] = r.coords[1] - i.coords[1], f[2] = r.coords[2] - i.coords[2], t = y.next; t !== y; t = t.next) h[0] = t.coords[0] - i.coords[0], h[1] = t.coords[1] - i.coords[1], h[2] = t.coords[2] - i.coords[2], m[0] = f[1] * h[2] - f[2] * h[1], m[1] = f[2] * h[0] - f[0] * h[2], m[2] = f[0] * h[1] - f[1] * h[0], o = m[0] * m[0] + m[1] * m[1] + m[2] * m[2], o > l && (l = o, e[0] = m[0], e[1] = m[1], e[2] = m[2]);
                l <= 0 && (e[0] = e[1] = e[2] = 0, e[this.longAxis_(f)] = 1)
            }, n.prototype.checkOrientation_ = function() {
                for (var e = this.mesh.fHead, t, r = this.mesh.vHead, i, s = 0, o = e.next; o !== e; o = o.next)
                    if (i = o.anEdge, !(i.winding <= 0))
                        do s += (i.Org.s - i.Dst.s) * (i.Org.t + i.Dst.t), i = i.Lnext; while (i !== o.anEdge);
                if (s < 0) {
                    for (t = r.next; t !== r; t = t.next) t.t = -t.t;
                    this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2]
                }
            }, n.prototype.projectPolygon_ = function() {
                var e = this.mesh.vHead,
                    t = [0, 0, 0],
                    r, i, s = !1;
                t[0] = this.normal[0], t[1] = this.normal[1], t[2] = this.normal[2], !t[0] && !t[1] && !t[2] && (this.computeNormal_(t), s = !0), r = this.sUnit, i = this.tUnit;
                var o = this.longAxis_(t);
                r[o] = 0, r[(o + 1) % 3] = 1, r[(o + 2) % 3] = 0, i[o] = 0, i[(o + 1) % 3] = 0, i[(o + 2) % 3] = t[o] > 0 ? 1 : -1;
                for (var l = e.next; l !== e; l = l.next) l.s = this.dot_(l.coords, r), l.t = this.dot_(l.coords, i);
                s && this.checkOrientation_();
                for (var a = !0, c = e.next; c !== e; c = c.next) a ? (this.bmin[0] = this.bmax[0] = c.s, this.bmin[1] = this.bmax[1] = c.t, a = !1) : (c.s < this.bmin[0] && (this.bmin[0] = c.s), c.s > this.bmax[0] && (this.bmax[0] = c.s), c.t < this.bmin[1] && (this.bmin[1] = c.t), c.t > this.bmax[1] && (this.bmax[1] = c.t))
            }, n.prototype.addWinding_ = function(e, t) {
                e.winding += t.winding, e.Sym.winding += t.Sym.winding
            }, n.prototype.tessellateMonoRegion_ = function(e, t) {
                var r, i;
                if (r = t.anEdge, !(r.Lnext !== r && r.Lnext.Lnext !== r)) throw "Mono region invalid";
                for (; Ee.vertLeq(r.Dst, r.Org); r = r.Lprev);
                for (; Ee.vertLeq(r.Org, r.Dst); r = r.Lnext);
                i = r.Lprev;
                for (var s = void 0; r.Lnext !== i;)
                    if (Ee.vertLeq(r.Dst, i.Org)) {
                        for (; i.Lnext !== r && (Ee.edgeGoesLeft(i.Lnext) || Ee.edgeSign(i.Org, i.Dst, i.Lnext.Dst) <= 0);) s = e.connect(i.Lnext, i), i = s.Sym;
                        i = i.Lprev
                    } else {
                        for (; i.Lnext !== r && (Ee.edgeGoesRight(r.Lprev) || Ee.edgeSign(r.Dst, r.Org, r.Lprev.Org) >= 0);) s = e.connect(r, r.Lprev), r = s.Sym;
                        r = r.Lnext
                    } if (i.Lnext === r) throw "Mono region invalid";
                for (; i.Lnext.Lnext !== r;) s = e.connect(i.Lnext, i), i = s.Sym;
                return !0
            }, n.prototype.tessellateInterior_ = function(e) {
                for (var t, r = e.fHead.next; r !== e.fHead; r = t)
                    if (t = r.next, r.inside && !this.tessellateMonoRegion_(e, r)) return !1;
                return !0
            }, n.prototype.discardExterior_ = function(e) {
                for (var t, r = e.fHead.next; r !== e.fHead; r = t) t = r.next, r.inside || e.zapFace(r)
            }, n.prototype.setWindingNumber_ = function(e, t, r) {
                for (var i, s = e.eHead.next; s !== e.eHead; s = i) i = s.next, s.Rface.inside !== s.Lface.inside ? s.winding = s.Lface.inside ? t : -t : r ? e.delete(s) : s.winding = 0
            }, n.prototype.getNeighbourFace_ = function(e) {
                return !e.Rface || !e.Rface.inside ? -1 : e.Rface.n
            }, n.prototype.outputPolymesh_ = function(e, t, r, i) {
                var s, o = 0,
                    l = 0,
                    a;
                r > 3 && e.mergeConvexFaces(r);
                for (var c = e.vHead.next; c !== e.vHead; c = c.next) c.n = -1;
                for (var f = e.fHead.next; f !== e.fHead; f = f.next)
                    if (f.n = -1, !!f.inside) {
                        s = f.anEdge, a = 0;
                        do {
                            var c = s.Org;
                            c.n === -1 && (c.n = l, l++), a++, s = s.Lnext
                        } while (s !== f.anEdge);
                        if (a > r) throw "Face vertex greater that support polygon";
                        f.n = o, ++o
                    } this.elementCount = o, t === Yt.CONNECTED_POLYGONS && (o *= 2), this.elements = [], this.elements.length = o * r, this.vertexCount = l, this.vertices = [], this.vertices.length = l * i, this.vertexIndices = [], this.vertexIndices.length = l;
                for (var c = e.vHead.next; c !== e.vHead; c = c.next)
                    if (c.n !== -1) {
                        var h = c.n * i;
                        this.vertices[h + 0] = c.coords[0], this.vertices[h + 1] = c.coords[1], i > 2 && (this.vertices[h + 2] = c.coords[2]), this.vertexIndices[c.n] = c.idx
                    } for (var m = 0, f = e.fHead.next; f !== e.fHead; f = f.next)
                    if (!!f.inside) {
                        s = f.anEdge, a = 0;
                        do {
                            var c = s.Org;
                            this.elements[m++] = c.n, a++, s = s.Lnext
                        } while (s !== f.anEdge);
                        for (var v = a; v < r; ++v) this.elements[m++] = -1;
                        if (t === Yt.CONNECTED_POLYGONS) {
                            s = f.anEdge;
                            do this.elements[m++] = this.getNeighbourFace_(s), s = s.Lnext; while (s !== f.anEdge);
                            for (var g = a; g < r; ++g) this.elements[m++] = -1
                        }
                    }
            }, n.prototype.outputContours_ = function(e, t) {
                var r, i, s = 0,
                    o = 0;
                this.vertexCount = 0, this.elementCount = 0;
                for (var l = e.fHead.next; l !== e.fHead; l = l.next)
                    if (!!l.inside) {
                        i = r = l.anEdge;
                        do this.vertexCount++, r = r.Lnext; while (r !== i);
                        this.elementCount++
                    } this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * t, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
                var a = 0,
                    c = 0,
                    f = 0;
                s = 0;
                for (var l = e.fHead.next; l !== e.fHead; l = l.next)
                    if (!!l.inside) {
                        o = 0, i = r = l.anEdge;
                        do this.vertices[a++] = r.Org.coords[0], this.vertices[a++] = r.Org.coords[1], t > 2 && (this.vertices[a++] = r.Org.coords[2]), this.vertexIndices[c++] = this.vertexIdCallback ? this.vertexIdCallback(r) : r.Org.idx, o++, r = r.Lnext; while (r !== i);
                        this.elements[f++] = s, this.elements[f++] = o, s += o
                    }
            }, n.prototype.addContour = function(e, t) {
                this.mesh === null && (this.mesh = new Qd), e < 2 && (e = 2), e > 3 && (e = 3);
                for (var r = null, i = 0; i < t.length; i += e) r === null ? (r = this.mesh.makeEdge(), this.mesh.splice(r, r.Sym)) : (this.mesh.splitEdge(r), r = r.Lnext), r.Org.coords[0] = t[i + 0], r.Org.coords[1] = t[i + 1], e > 2 ? r.Org.coords[2] = t[i + 2] : r.Org.coords[2] = 0, r.Org.idx = this.vertexIndexCounter++, this.edgeCreateCallback && this.edgeCreateCallback(r), r.winding = 1, r.Sym.winding = -1
            }, n.prototype.tesselate = function(e, t, r, i, s, o) {
                if (e === void 0 && (e = It.ODD), t === void 0 && (t = Yt.POLYGONS), o === void 0 && (o = !0), this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, s && (this.normal[0] = s[0], this.normal[1] = s[1], this.normal[2] = s[2]), this.windingRule = e, i < 2 && (i = 2), i > 3 && (i = 3), !this.mesh) return !1;
                this.projectPolygon_(), l0.computeInterior(this, o);
                var l = this.mesh;
                return t === Yt.BOUNDARY_CONTOURS ? this.setWindingNumber_(l, 1, !0) : this.tessellateInterior_(l), o && l.check(), t === Yt.BOUNDARY_CONTOURS ? this.outputContours_(l, i) : this.outputPolymesh_(l, t, r, i), !0
            }, n
        }();

    function Ps(n) {
        var e = n.windingRule,
            t = e === void 0 ? It.ODD : e,
            r = n.elementType,
            i = r === void 0 ? Yt.POLYGONS : r,
            s = n.polySize,
            o = s === void 0 ? 3 : s,
            l = n.vertexSize,
            a = l === void 0 ? 2 : l,
            c = n.normal,
            f = c === void 0 ? [0, 0, 1] : c,
            h = n.contours,
            m = h === void 0 ? [] : h,
            v = n.strict,
            g = v === void 0 ? !0 : v,
            y = n.debug,
            A = y === void 0 ? !1 : y;
        if (!m && g) throw new Error("Contours can't be empty");
        if (!!m) {
            var w = new c0;
            n.edgeCreateCallback && (w.edgeCreateCallback = n.edgeCreateCallback), n.vertexIdCallback && (w.vertexIdCallback = n.vertexIdCallback);
            for (var C = 0; C < m.length; C++) w.addContour(a || 2, m[C]);
            return w.tesselate(t, i, o, a, f, g), {
                vertices: w.vertices,
                vertexIndices: w.vertexIndices,
                vertexCount: w.vertexCount,
                elements: w.elements,
                elementCount: w.elementCount,
                mesh: A ? w.mesh : void 0
            }
        }
    }
    var JI = It.ODD,
        QI = It.NONZERO,
        YI = It.POSITIVE,
        KI = It.NEGATIVE,
        XI = It.ABS_GEQ_TWO,
        qI = Yt.POLYGONS,
        ZI = Yt.CONNECTED_POLYGONS,
        $I = Yt.BOUNDARY_CONTOURS;
    var Ho = class extends Bn.BufferGeometry {
        constructor(e, t = 12, r = 100, i = {}) {
            super();
            this.type = "ShapeGeometry";
            this.windingRule = It.ODD;
            this.elementType = Yt.POLYGONS;
            this.polySize = 3;
            this.vertexSize = 2;
            this.strict = !0;
            this._drawCount = 0, this._shape = e, this._curveSegments = t, this._maxCount = r, this._maxDrawCount = r * 3, this._triangulationOptions = Object.assign({
                windingRule: It.ODD,
                elementType: Yt.POLYGONS,
                polySize: 3,
                vertexSize: 2,
                strict: !0
            }, i), this._positionAttribute = new Bn.BufferAttribute(new Float32Array(r * 3), 3), this._normalAttribute = new Bn.BufferAttribute(new Float32Array(r * 3), 3), this._uvAttribute = new Bn.BufferAttribute(new Float32Array(r * 2), 2), this._indexAttribute = new Bn.BufferAttribute(new Uint32Array(r * 3), 1), this.setAttribute("position", this._positionAttribute), this.setAttribute("normal", this._normalAttribute), this.setAttribute("uv", this._uvAttribute), this.setIndex(this._indexAttribute), this.updateFromShape()
        }
        copy(e) {
            return this._drawCount = e.drawCount, this._maxDrawCount = e._maxDrawCount, this._maxCount = e.maxCount, super.copy(e)
        }
        get curveSegments() {
            return this._curveSegments
        }
        set curveSegments(e) {
            this._curveSegments = e, this.updateFromShape()
        }
        get drawCount() {
            return this._drawCount
        }
        get maxDrawCount() {
            return this._maxDrawCount
        }
        get maxCount() {
            return this._maxCount
        }
        updateFromShape() {
            let e = this._shape.extractShapePointsToFlatArray([], this._curveSegments),
                t = this._shape.shapeHoles.map(a => a.extractShapePointsToFlatArray([], this._curveSegments)),
                r, i = !0,
                s = !0,
                o, l;
            for (let a = 0, c = e.length / 2; a < c; a++) {
                let f = a * 2,
                    h = e[f + 0],
                    m = e[f + 1];
                if (o !== void 0 && h !== o && (i = !1), l !== void 0 && m !== l && (s = !1), o = h, l = m, !i && !s) break
            }
            if (!i && !s && (r = Ps({
                    contours: [e, ...t],
                    windingRule: this._triangulationOptions.windingRule,
                    elementType: this._triangulationOptions.elementType,
                    polySize: this._triangulationOptions.polySize,
                    vertexSize: this._triangulationOptions.vertexSize,
                    strict: this._triangulationOptions.strict
                })), r) {
                this._positionAttribute.array.fill(0), this._normalAttribute.array.fill(0), this._uvAttribute.array.fill(0), this._indexAttribute.array.fill(0), this._drawCount = 0;
                let a = 1 / 0,
                    c = -1 / 0,
                    f = 1 / 0,
                    h = -1 / 0;
                for (let g = 0, y = r.vertexCount; g < y; g++) {
                    let A = g * 2,
                        w = r.vertices[A + 0],
                        C = r.vertices[A + 1];
                    w < a && (a = w), w > c && (c = w), C < f && (f = C), C > h && (h = C)
                }
                let m = c - a,
                    v = h - f;
                for (let g = 0, y = r.vertexCount; g < y; g++) {
                    let A = g * 2,
                        w = r.vertices[A + 0],
                        C = r.vertices[A + 1],
                        S = (w - a) / m,
                        E = (C - f) / v;
                    this._positionAttribute.setXYZ(g, w, C, 0), this._normalAttribute.setXYZ(g, 0, 0, 1), this._uvAttribute.setXY(g, S, E)
                }
                for (let g = 0, y = r.elementCount; g < y; g++) {
                    let A = g * 3,
                        w = r.elements[A + 0],
                        C = r.elements[A + 1],
                        S = r.elements[A + 2];
                    this._indexAttribute.setX(A + 0, w), this._indexAttribute.setX(A + 1, C), this._indexAttribute.setX(A + 2, S), this._drawCount += 3
                }
                this._positionAttribute.needsUpdate = !0, this._normalAttribute.needsUpdate = !0, this._uvAttribute.needsUpdate = !0, this._indexAttribute.needsUpdate = !0, this.setDrawRange(0, this._drawCount)
            }
            return this._drawCount > this._maxDrawCount
        }
    };
    var On = W(J());
    var dl = class {
            constructor(e = 256, t = !1) {
                this.capacity = e, this.size = 0, this.debug = t, this.debug && console.log(`allocating with cap ${e}`);
                let r = e * dl.eSize;
                this.buffer = new ArrayBuffer(r);
                let i = Float32Array.BYTES_PER_ELEMENT,
                    s = 0;
                this.positions = new Float32Array(this.buffer, s * i, 3 * e), s += 3 * e, this.normals = new Float32Array(this.buffer, s * i, 3 * e), s += 3 * e, this.uvs = new Float32Array(this.buffer, s * i, 2 * e)
            }
            realloc(e, t = !1) {
                if (e < this.size) throw Error("cannot shrink buffer");
                if (e <= this.capacity && !t) return;
                this.debug && console.log(`resizing from ${this.capacity} \u2192 ${e}`);
                let r = e * dl.eSize,
                    i = new ArrayBuffer(r),
                    s = Float32Array.BYTES_PER_ELEMENT,
                    o = 0,
                    l = new Float32Array(i, o * s, 3 * e);
                o += 3 * e;
                let a = new Float32Array(i, o * s, 3 * e);
                o += 3 * e;
                let c = new Float32Array(i, o * s, 2 * e);
                l.set(this.positions.slice(0, this.size * 3)), a.set(this.normals.slice(0, this.size * 3)), c.set(this.uvs.slice(0, this.size * 2)), this.buffer = i, this.positions = l, this.normals = a, this.uvs = c, this.capacity = e
            }
            get(e = 1) {
                let t = this.size + e;
                if (t > this.capacity) {
                    let i = this.capacity;
                    for (; t > i;) i *= 2;
                    this.realloc(i)
                }
                let r = this.size;
                return this.size = t, r
            }
            reserve(e) {
                let t = this.size + e;
                t > this.capacity && this.realloc(t)
            }
            shrink() {
                this.debug && console.log(`shrinking ${this.capacity} \u2192 ${this.size}`), this.realloc(this.size, !0)
            }
        },
        fl = dl;
    fl.eSize = (3 + 3 + 2) * Float32Array.BYTES_PER_ELEMENT;
    var bu = (n, e) => ([t, r]) => (r < t && (r += e), (n >= t ? n : n + e) <= r),
        wu = class extends On.BufferGeometry {
            constructor(e, t, r = 0, i = 12, s = 3) {
                super();
                this.type = "ShapeGeometry";
                this.vertexCache = {};
                this._shape = e, this._depth = t, r <= 0 ? (this._bevelSize = 0, this._bevelSegments = 0) : (this._bevelSize = Math.min(r, t / 2 - 1e-12), this._bevelSegments = Math.floor(s));
                let o = this._shape.extractShapePointsToFlatArray([], i),
                    l = this._shape.shapeHoles.map(S => S.extractShapePointsToFlatArray([], i)),
                    a = Ps({
                        windingRule: It.ODD,
                        elementType: Yt.BOUNDARY_CONTOURS,
                        vertexSize: 2,
                        strict: !0,
                        contours: [o, ...l]
                    });
                if (!a) throw new Error("error generating geometry");
                let c = 1 / 0,
                    f = -1 / 0,
                    h = 1 / 0,
                    m = -1 / 0;
                for (let S = 0, E = a.vertexCount; S < E; S++) {
                    let M = S * 2,
                        L = a.vertices[M + 0],
                        I = a.vertices[M + 1];
                    L < c && (c = L), L > f && (f = L), I < h && (h = I), I > m && (m = I)
                }
                this._minX = c, this._minY = h, this._width = f - c, this._height = m - h;
                let v = a.vertexCount * 2 * (2 + this._bevelSegments);
                this._buffer = new fl(v);
                let g = [];
                for (let S = 0, E = a.elementCount; S < E; S++) {
                    let M = S * 2,
                        L = a.elements[M + 0],
                        I = a.elements[M + 1],
                        z = L + I,
                        O = {
                            start: L,
                            count: I,
                            normals: [],
                            continuous: [],
                            concave: []
                        },
                        X = L,
                        k = z - 1,
                        Q = L + 1,
                        te = this._shape.roundedCurves.length;
                    do {
                        let B = X - L,
                            U = a.vertices[k * 2 + 0],
                            G = a.vertices[k * 2 + 1],
                            V = a.vertices[X * 2 + 0],
                            j = a.vertices[X * 2 + 1],
                            ne = a.vertices[Q * 2 + 0],
                            F = a.vertices[Q * 2 + 1],
                            Y = V - U,
                            $ = j - G,
                            re = Math.sqrt(Y * Y + $ * $);
                        Y /= re, $ /= re;
                        let fe = V - ne,
                            ye = j - F,
                            Se = Math.sqrt(fe * fe + ye * ye);
                        fe /= Se, ye /= Se, O.normals[B * 2 + 0] = -ye, O.normals[B * 2 + 1] = fe, O.concave[B] = Y * ye - $ * fe > 0;
                        let se = a.vertexIndices[X];
                        if (Array.isArray(se)) O.continuous[B] = !1;
                        else {
                            let [ie, oe] = this._shape.getCurveIndexFromVertexId(se - 1, !0);
                            if (oe > 0 && oe < 1) O.continuous[B] = !0;
                            else {
                                let he = oe === 1 ? ie + 1 : ie - 1;
                                he = (he + te) % te;
                                let pe = oe === 1 ? 0 : 1,
                                    q = this._shape.roundedCurves[ie].getTangent(oe),
                                    Ae = this._shape.roundedCurves[he].getTangent(pe);
                                O.continuous[B] = q.dot(Ae) > .95
                            }
                        } [k, X, Q] = [X, Q, Q + 1], Q >= z && (Q -= I)
                    } while (Q !== L + 1);
                    let Z = [];
                    Z.push({
                        bevelI: 0,
                        angle: 0,
                        size: 0,
                        boundary: {
                            vertices: a.vertices.slice(L * 2, z * 2),
                            vertexCount: I,
                            vertexIndices: new Array(I).fill(!0).map((B, U) => [U, U]),
                            elements: [0, I],
                            elementCount: 1,
                            mesh: null
                        },
                        reverseMap: [],
                        insetPoints: a.vertices.slice(L * 2, z * 2)
                    });
                    for (let B = 1; B <= this._bevelSegments; B++) {
                        let U = B / this._bevelSegments * Math.PI / 2,
                            G = (1 - Math.cos(U)) * this._bevelSize,
                            V = [],
                            j = [],
                            ne = [],
                            F = [],
                            Y = 0;
                        for (let re = 0; re < I; re++) {
                            let fe = re * 2,
                                ye = (re - 1 + I) % I * 2,
                                Se = a.vertices[O.start * 2 + fe + 0],
                                se = a.vertices[O.start * 2 + fe + 1],
                                ie = -O.normals[ye + 0] * G,
                                oe = -O.normals[ye + 1] * G,
                                he = -O.normals[fe + 0] * G,
                                pe = -O.normals[fe + 1] * G;
                            if (O.concave[re]) {
                                let q = Math.atan2(oe, ie),
                                    Ae = Math.atan2(pe, he);
                                Ae > q && (Ae -= Math.PI * 2);
                                let ke = Ae - q;
                                if (O.continuous[re]) {
                                    let Ce = q + ke / 2,
                                        Te = Math.cos(Ce) * G,
                                        Fe = Math.sin(Ce) * G;
                                    V[2 * Y + 0] = Se + Te, V[2 * Y + 1] = se + Fe, F[Y] = re, Y++
                                } else {
                                    let Ce = Math.max(1, Math.floor(i / 4 * Math.abs(ke) / Math.PI));
                                    for (let Te = 0; Te <= Ce; Te++) {
                                        let Fe = q + ke * (Te / Ce),
                                            nt = Math.cos(Fe) * G,
                                            De = Math.sin(Fe) * G;
                                        V[2 * Y + 0] = Se + nt, V[2 * Y + 1] = se + De, F[Y] = re, Y++
                                    }
                                }
                            } else V[2 * Y + 0] = Se + ie, V[2 * Y + 1] = se + oe, F[Y] = re, j[re] = Y, Y++, V[2 * Y + 0] = Se, V[2 * Y + 1] = se, F[Y] = re, Y++, V[2 * Y + 0] = Se + he, V[2 * Y + 1] = se + pe, F[Y] = re, ne[re] = Y, Y++
                        }
                        let $ = Ps({
                            windingRule: It.POSITIVE,
                            elementType: Yt.BOUNDARY_CONTOURS,
                            vertexSize: 2,
                            strict: !0,
                            contours: [V],
                            edgeCreateCallback: re => {
                                let ye = re.Org.idx,
                                    Se = F[ye],
                                    se = F[(ye + 1) % F.length];
                                re.idx = [Se, se], re.Sym.idx = [se, Se]
                            },
                            vertexIdCallback: re => {
                                let fe = re.Lprev.idx;
                                return [fe ? fe[1] : 0, re.idx[0]]
                            }
                        });
                        if (!$) throw new Error(`error generating bevel geometry for ${B}'th loop`);
                        if (!$.vertexCount) break;
                        for (let re = 0; re < $.vertexIndices.length; re++) {
                            let [fe, ye] = $.vertexIndices[re];
                            if (fe === ye) continue;
                            let Se = ye;
                            ye < fe && (Se += I);
                            for (let se = fe; se < Se; se++) {
                                let ie = se % I,
                                    oe = (se + 1) % I;
                                if (!O.continuous[ie] || !O.continuous[oe]) {
                                    $.vertexIndices[re] = [fe, ie], $.vertexIndices.splice(re + 1, 0, [oe, ye]), $.vertices.splice((re + 1) * 2, 0, $.vertices[re * 2], $.vertices[re * 2 + 1]);
                                    break
                                }
                            }
                        }
                        Z.push({
                            bevelI: B,
                            angle: U,
                            size: G,
                            boundary: $,
                            reverseMap: F,
                            insetPoints: V
                        })
                    }
                    let le = (B, U, G) => {
                        let V = 0,
                            j = B.boundary.vertexIndices.length;
                        for (; V < j && G(B.boundary.vertexIndices[U]);) U = (U + 1) % j, V++;
                        return V
                    };
                    for (let B = 1; B < Z.length; B++) {
                        let U = Z[B - 1],
                            G = Z[B],
                            V = U.boundary.vertexIndices.length,
                            j = G.boundary.vertexIndices.length;
                        if (!V || !j) break;
                        let ne = O.concave.length,
                            F = 0,
                            Y = bu(F, I);
                        for (; !U.boundary.vertexIndices.filter(Y).length || !G.boundary.vertexIndices.filter(Y).length;) F++, Y = bu(F, I);
                        let $ = U.boundary.vertexIndices.findIndex(Y),
                            re = G.boundary.vertexIndices.findIndex(Y);
                        do $ = ($ + 1) % V; while (Y(U.boundary.vertexIndices[$]));
                        do re = (re + 1) % j; while (Y(G.boundary.vertexIndices[re]));
                        F = (F + 1) % I;
                        let fe = F,
                            ye = this.buildBevelVert(O, U, ($ - 1 + V) % V),
                            Se = this.buildBevelVert(O, G, (re - 1 + j) % j),
                            se = ye,
                            ie = Se,
                            oe, he, pe = !1;
                        do {
                            Y = bu(F, I);
                            let q = le(U, $, Y),
                                Ae = le(G, re, Y),
                                ke = pe;
                            if (pe = !1, q && !Ae) {
                                for (let Ce = 0; Ce < q; Ce++) oe = this.buildBevelVert(O, U, ($ + Ce) % V, Ce / (q - 1)), g.push(se.topN, oe.topP, ie.topN), g.push(oe.bottomP, se.bottomN, ie.bottomN), se = oe;
                                pe = !0
                            } else if (!q && Ae)
                                for (let Ce = 0; Ce < Ae; Ce++) he = this.buildBevelVert(O, G, (re + Ce) % j, Ce / (Ae - 1)), g.push(ie.topN, se.topP, he.topP), g.push(se.bottomP, ie.bottomN, he.bottomP), ie = he;
                            else if (q && Ae)
                                if (oe = this.buildBevelVert(O, U, $, 0), he = this.buildBevelVert(O, G, re, 0), ke ? (g.push(se.topN, he.topP, ie.topN), g.push(se.topN, oe.topP, he.topP), g.push(he.bottomP, se.bottomN, ie.bottomN), g.push(oe.bottomP, se.bottomN, he.bottomP)) : (g.push(se.topN, oe.topP, ie.topN), g.push(ie.topN, oe.topP, he.topP), g.push(oe.bottomP, se.bottomN, ie.bottomN), g.push(oe.bottomP, ie.bottomN, he.bottomP)), se = oe, ie = he, q === Ae)
                                    for (let Ce = 1; Ce < q; Ce++) oe = this.buildBevelVert(O, U, ($ + Ce) % V, Ce / (q - 1)), he = this.buildBevelVert(O, G, (re + Ce) % j, Ce / (Ae - 1)), g.push(se.topN, oe.topP, ie.topN), g.push(ie.topN, oe.topP, he.topP), g.push(oe.bottomP, se.bottomN, ie.bottomN), g.push(oe.bottomP, ie.bottomN, he.bottomP), se = oe, ie = he;
                                else if (q > Ae) {
                                let Ce = q / Ae,
                                    Te = 0;
                                for (let Fe = 1; Fe < q; Fe++) oe = this.buildBevelVert(O, U, ($ + Fe) % V, Fe / (q - 1)), g.push(se.topN, oe.topP, ie.topN), g.push(oe.bottomP, se.bottomN, ie.bottomN), se = oe, Fe > (Te + 1) * Ce && (Te++, he = this.buildBevelVert(O, G, (re + Te) % j, Te / (Ae - 1)), g.push(ie.topN, oe.topP, he.topP), g.push(oe.bottomP, ie.bottomN, he.bottomP), ie = he)
                            } else {
                                let Ce = Ae / q,
                                    Te = 0;
                                for (let Fe = 1; Fe < Ae; Fe++) he = this.buildBevelVert(O, G, (re + Fe) % j, Fe / (Ae - 1)), g.push(ie.topN, oe.topP, he.topP), g.push(oe.bottomP, ie.bottomN, he.bottomP), ie = he, Fe > (Te + 1) * Ce && (Te++, oe = this.buildBevelVert(O, U, ($ + Te) % V, Te / (q - 1)), g.push(se.topN, oe.topP, ie.topN), g.push(oe.bottomP, se.bottomN, ie.bottomN), se = oe)
                            }
                            $ = ($ + q) % V, re = (re + Ae) % j, F = (F + 1) % ne
                        } while (F !== fe)
                    } {
                        let B = Z[0];
                        for (let U = 0, G = B.boundary.vertexCount; U < G; U++) {
                            let V = this.buildBevelVert(O, B, U),
                                j = this.buildBevelVert(O, B, (U + 1) % G);
                            g.push(j.topP, V.topN, V.bottomN), g.push(j.topP, V.bottomN, j.bottomP)
                        }
                    } {
                        let B = Z[Z.length - 1],
                            U = Ps({
                                windingRule: Z.length > 1 ? It.POSITIVE : It.ODD,
                                elementType: Yt.POLYGONS,
                                vertexSize: 2,
                                strict: !0,
                                contours: [B.insetPoints, ...l]
                            });
                        if (!U) throw new Error("Error generating geometry for surface");
                        for (let G = 0; G < U.elementCount * 3; G += 3) {
                            let V = this.buildSurfaceVert(U, U.elements[G + 0]),
                                j = this.buildSurfaceVert(U, U.elements[G + 1]),
                                ne = this.buildSurfaceVert(U, U.elements[G + 2]);
                            g.push(V.top, j.top, ne.top), g.push(ne.bottom, j.bottom, V.bottom)
                        }
                    }
                    this.vertexCache = {}
                }
                this._buffer.shrink();
                let y = new On.BufferAttribute(Uint32Array.from(g), 1),
                    A = new On.BufferAttribute(this._buffer.positions, 3),
                    w = new On.BufferAttribute(this._buffer.normals, 3),
                    C = new On.BufferAttribute(this._buffer.uvs, 2);
                A.needsUpdate = !0, w.needsUpdate = !0, C.needsUpdate = !0, y.needsUpdate = !0, this.setAttribute("position", A), this.setAttribute("normal", w), this.setAttribute("uv", C), this.setIndex(y)
            }
            buildSurfaceVert(e, t) {
                let r = t.toString();
                if (r in this.vertexCache) return this.vertexCache[r];
                let i = e.vertices[t * 2 + 0],
                    s = e.vertices[t * 2 + 1],
                    o = (i - this._minX) / this._width,
                    l = (s - this._minY) / this._height,
                    a = this._buffer.get(2),
                    c = a * 3,
                    f = a * 2,
                    h = {
                        top: a + 0,
                        bottom: a + 1
                    };
                return this._buffer.positions[c + 0] = i, this._buffer.positions[c + 1] = s, this._buffer.positions[c + 2] = this._depth, this._buffer.normals[c + 0] = 0, this._buffer.normals[c + 1] = 0, this._buffer.normals[c + 2] = 1, this._buffer.uvs[f + 0] = o, this._buffer.uvs[f + 1] = l, this._buffer.positions[c + 3] = i, this._buffer.positions[c + 4] = s, this._buffer.positions[c + 5] = 0, this._buffer.normals[c + 3] = 0, this._buffer.normals[c + 4] = 0, this._buffer.normals[c + 5] = -1, this._buffer.uvs[f + 2] = o, this._buffer.uvs[f + 3] = l, this.vertexCache[r] = h, h
            }
            buildBevelVert(e, t, r, i = 1) {
                let s = `${t.bevelI}:${r}`;
                if (s in this.vertexCache) return this.vertexCache[s];
                let [o, l] = t.boundary.vertexIndices[r], a, c, f, h;
                o !== l ? (c = o, a = l, h = !1, f = e.continuous[c] && e.continuous[a]) : (a = o, c = (a - 1 + e.count) % e.count, h = e.concave[a] && t.bevelI > 0, f = e.continuous[a] || h);
                let m = Math.cos(t.angle),
                    v = Math.sin(t.angle),
                    g = r * 2,
                    y = a * 2,
                    A = c * 2,
                    w = t.boundary.vertices[g + 0],
                    C = t.boundary.vertices[g + 1],
                    S = (1 - v) * this._bevelSize,
                    E = (w - this._minX) / this._width,
                    M = (C - this._minY) / this._height,
                    L = e.normals[y + 0],
                    I = e.normals[y + 1],
                    z = e.normals[A + 0],
                    O = e.normals[A + 1];
                if (h) {
                    let Z = z - L,
                        le = O - I;
                    L = L + Z * (1 - i), I = I + le * (1 - i);
                    let B = Math.sqrt(L * L + I * I);
                    L /= B, I /= B
                }
                let X = this._buffer.get(f ? 2 : 4),
                    k = X * 3,
                    Q = X * 2,
                    te = {
                        i: r,
                        fi: a,
                        topP: X + 0,
                        topN: X + 0,
                        bottomP: X + 1,
                        bottomN: X + 1
                    };
                return this._buffer.positions[k + 0] = w, this._buffer.positions[k + 1] = C, this._buffer.positions[k + 2] = this._depth - S, this._buffer.normals[k + 0] = L * m, this._buffer.normals[k + 1] = I * m, this._buffer.normals[k + 2] = v, this._buffer.uvs[Q + 0] = E, this._buffer.uvs[Q + 1] = M, this._buffer.positions[k + 3] = w, this._buffer.positions[k + 4] = C, this._buffer.positions[k + 5] = S, this._buffer.normals[k + 3] = L * m, this._buffer.normals[k + 4] = I * m, this._buffer.normals[k + 5] = -v, this._buffer.uvs[Q + 2] = M, this._buffer.uvs[Q + 3] = E, f || (X += 2, k += 6, Q += 4, te.topP = X + 0, te.bottomP = X + 1, this._buffer.positions[k + 0] = w, this._buffer.positions[k + 1] = C, this._buffer.positions[k + 2] = this._depth - S, this._buffer.normals[k + 0] = z * m, this._buffer.normals[k + 1] = O * m, this._buffer.normals[k + 2] = v, this._buffer.uvs[Q + 0] = E, this._buffer.uvs[Q + 1] = M, this._buffer.positions[k + 3] = w, this._buffer.positions[k + 4] = C, this._buffer.positions[k + 5] = S, this._buffer.normals[k + 3] = z * m, this._buffer.normals[k + 4] = O * m, this._buffer.normals[k + 5] = -v, this._buffer.uvs[Q + 2] = M, this._buffer.uvs[Q + 3] = E), this.vertexCache[s] = te, te
            }
        };
    var lr = class {
        static create(n) {
            return this.build(this.normalizeInputs(n))
        }
        static normalizeInputs(n, e) {
            let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    depth: 0,
                    subdivisions: 40,
                    roundness: 0,
                    extrudeDepth: 0,
                    surfaceMaxCount: 100,
                    extrudeBevelSize: 0,
                    extrudeBevelSegments: 3
                }, n.parameters),
                r = Math.abs(t.width),
                i = Math.abs(t.height ?? t.width),
                s = n.shape ?? e?.shape,
                o = s?.roundness ?? t.roundness;
            s !== void 0 && (s instanceof Ot ? (s.width !== r || s.height !== i) && s.applySize(r, i) : s = new Ot(r, i).fromJSON(s), n.parameters?.roundness !== void 0 && n.parameters?.roundness > 0 && s.update(!1));
            let l = s ?? new Ot(r, i);
            return {
                parameters: Object.assign(t, {
                    width: r,
                    height: i,
                    roundness: o
                }),
                shape: l
            }
        }
        static build(n) {
            let {
                extrudeDepth: e,
                extrudeBevelSize: t,
                extrudeBevelSegments: r,
                subdivisions: i,
                roundness: s,
                surfaceMaxCount: o
            } = n.parameters;
            n.shape.roundness = s;
            let l;
            return e <= 0 ? l = new Ho(n.shape, i, o) : l = new wu(n.shape, e, t, i, r), Object.assign(l, {
                userData: je(Ne({}, n), {
                    type: "VectorGeometry"
                })
            })
        }
    };
    var Wo = W(J()),
        qd = Math.PI * 2,
        Zd = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    depth: 0,
                    spikes: 128,
                    angle: 360,
                    innerRadius: 0,
                    extrudeDepth: 0,
                    extrudeBevelSize: 0,
                    extrudeBevelSegments: 1,
                    surfaceMaxCount: 1e3
                }, n.parameters);
                return {
                    shape: new Ot,
                    parameters: Object.assign(t, {
                        width: Math.abs(t.width),
                        height: Math.abs(t.height ?? t.width)
                    })
                }
            }
            static build(n) {
                let {
                    width: e,
                    height: t,
                    spikes: r,
                    angle: i,
                    innerRadius: s,
                    extrudeDepth: o,
                    extrudeBevelSize: l,
                    extrudeBevelSegments: a,
                    surfaceMaxCount: c
                } = n.parameters, f = n.shape, h = e * .5, m = t * .5, v = u0(f, h, m, i * Math.PI / 180, r, s);
                f.isClosed = !0, f.update();
                let g = lr.create({
                    shape: f,
                    parameters: {
                        subdivisions: v,
                        surfaceMaxCount: c,
                        extrudeDepth: o,
                        extrudeBevelSize: l,
                        extrudeBevelSegments: a
                    }
                });
                return Object.assign(g, {
                    userData: je(Ne({}, n), {
                        type: "EllipseGeometry"
                    })
                })
            }
        };

    function u0(n, e, t, r, i, s) {
        if (r >= qd) return i > 30 || i % 4 == 0 ? (d0(n, e, t, s), Math.round(i / 4)) : $d(n, r, i, e, t, s);
        let o = {
                x: 0,
                y: t
            },
            l = r + Math.PI * .5,
            a = {
                x: Math.cos(l) * e,
                y: Math.sin(l) * t
            },
            c = Jd({
                px: o.x,
                py: o.y,
                cx: a.x,
                cy: a.y,
                rx: e,
                ry: t,
                largeArcFlag: r > Math.PI,
                sweepFlag: !0
            });
        return i > 30 || i % c.length == 0 ? f0(n, o.x, o.y, c, i, e, t, s) : $d(n, r, i, e, t, s)
    }

    function f0(n, e, t, r, i, s, o, l) {
        let a = Math.round(i / r.length);
        n.addPoint(Bs(e, t));
        for (let c = 0, f = r.length; c < f; c++) {
            let h = r[c],
                m = n.points[c],
                v = Bs(h.x, h.y);
            m.controls[1].position.set(h.x1, h.y1), v.controls[0].position.set(h.x2, h.y2), n.addPoint(v)
        }
        return l > 0 ? eh(n, s, o, l) : n.addPoint(Bs(0, 0)), a
    }

    function $d(n, e, t, r, i, s) {
        let o = -e / t;
        for (let l = 0; l <= t; l++) {
            let a = o * l,
                c = Math.sin(a) * r,
                f = Math.cos(a) * i;
            n.addPoint(Bs(c, f))
        }
        return e < qd ? s > 0 ? eh(n, r, i, s) : n.addPoint(Bs(0, 0)) : (n.removePoint(n.points[n.points.length - 1]), s > 0 && th(n, r, i, s)), 1
    }

    function d0(n, e, t, r = 0, i = 0, s = 0) {
        let o = .5522847498,
            l = e * o,
            a = t * o;
        n.addPoint(hl(i - e, s, i - e, s - a, i - e, s + a)), n.addPoint(hl(i, s + t, i - l, s + t, i + l, s + t)), n.addPoint(hl(i + e, s, i + e, s + a, i + e, s - a)), n.addPoint(hl(i, s - t, i + l, s - t, i - l, s - t)), r > 0 && th(n, e, t, r)
    }

    function Bs(n, e) {
        return new on(Wo.MathUtils.generateUUID(), new Wo.Vector2(n, e))
    }

    function hl(n, e, t, r, i, s) {
        let o = Bs(n, e);
        return o.controls[0].position.set(t, r), o.controls[1].position.set(i, s), o
    }

    function eh(n, e, t, r) {
        rh(n, e, t, r).forEach(s => n.addPoint(s))
    }

    function th(n, e, t, r) {
        let i = rh(n, e, t, r),
            s = new Ot;
        i.forEach(o => s.addPoint(o)), s.isClosed = !0, n.shapeHoles.push(s)
    }

    function rh(n, e, t, r) {
        let i = r * e / 100,
            s = i * (Math.abs(t) / Math.abs(e)),
            o = new Wo.Vector2(i / e, s / t),
            l = n.points.map(a => a.clone()).reverse();
        return l.forEach(a => {
            a.position.multiply(o);
            let c = a.controls[0].position.clone().multiply(o),
                f = a.controls[1].position.clone().multiply(o);
            a.controls[0].position.copy(f), a.controls[1].position.copy(c)
        }), l
    }
    var Kt = W(J()),
        ih = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                        width: 100,
                        revolutions: 2,
                        segments: 40,
                        pathRadius: 10,
                        pathType: 0,
                        pathSegments: 30,
                        cornerRadius: 30,
                        cornerSegments: 4
                    }, n.parameters),
                    r = Math.abs(t.width),
                    i = Math.abs(t.height ?? r),
                    s = Math.abs(t.depth ?? r),
                    o = Math.abs(Math.min(r, s)) / 2;
                return {
                    parameters: Object.assign(t, {
                        width: r,
                        height: i,
                        depth: s,
                        radius: o,
                        segments: Math.round(t.segments),
                        pathSegments: Math.round(t.pathSegments),
                        cornerSegments: Math.round(t.cornerSegments)
                    })
                }
            }
            static build(n) {
                let {
                    width: e,
                    height: t,
                    depth: r,
                    radius: i,
                    revolutions: s,
                    segments: o,
                    pathRadius: l,
                    pathType: a,
                    pathSegments: c,
                    cornerRadius: f,
                    cornerSegments: h
                } = n.parameters, m = new ml(!1, e, t, r, i, s, o, l, a, c, f, h);
                return Object.assign(m, {
                    userData: je(Ne({}, n), {
                        type: "HelixGeometry"
                    })
                })
            }
        },
        ml = class extends Kt.BufferGeometry {
            constructor(e, t, r, i, s, o, l, a, c, f, h, m) {
                super();
                let v = [],
                    g = [],
                    y = [],
                    A = [],
                    w = [],
                    C = [],
                    S = [],
                    E = new Kt.Vector3,
                    M = new Kt.Vector3,
                    L = new Kt.Vector3,
                    I = new Kt.Vector3,
                    z, O, X, k, Q, te, Z, le, B = new Kt.Vector3,
                    U = new Kt.Vector3,
                    G = new Kt.Vector3,
                    V = new Kt.Vector3,
                    j = new Kt.Vector3,
                    ne = new Kt.Vector3,
                    F = new Kt.Vector3,
                    Y = s - a,
                    $ = r - 2 * a + .001,
                    re = $ / o,
                    fe = Math.ceil(l * o),
                    ye = $ / fe,
                    Se = -$ / 2,
                    se = 2 * Math.PI / f,
                    ie = Math.PI / 2 / m,
                    oe = Math.min((1 - h / 100) * a, a - .1),
                    he = a - oe,
                    pe = e && o == 1;
                pe && (m = 0);

                function q(De, bt) {
                    let Mt = Math.PI / 2;
                    te = bt * ye, le = 2 * Math.PI * (te % re) / re + Mt, te += Se, Z = Math.sin(le) * Y, Q = Math.cos(le) * Y, e ? De.set(Q, Z, te) : De.set(Q, te, Z)
                }
                q(L, -1), q(I, 0), B.copy(L);
                let Ae = L.distanceTo(I),
                    ke = Ae * fe + 2 * he,
                    Ce = 0,
                    Te = ke - he;
                for (let De = 0; De <= fe; De++) {
                    q(E, De), F.subVectors(E, B).normalize(), B.copy(E), j.copy(E).setComponent(+e + 1, 0).normalize(), ne.crossVectors(F, j).normalize();
                    let bt = De == 0 ? 3 * Math.PI / 2 : ie,
                        Mt = De == 0 ? Ce : Te;
                    for (let xt = 0, tr = 0; xt <= f; xt++, tr = xt * se) {
                        if (U.addVectors(L.copy(j).multiplyScalar(a * Math.cos(tr)), I.copy(ne).multiplyScalar(a * Math.sin(tr))), V.copy(U).normalize(), De == 0 || De == fe) {
                            I.copy(V).multiplyScalar(oe), M.addVectors(E, I);
                            for (let rr = 0, dr = bt; rr < m; rr++, dr = rr * ie + bt) {
                                G.addVectors(L.copy(F).multiplyScalar(he * Math.sin(dr)), I.copy(V).multiplyScalar(he * Math.cos(dr))), I.addVectors(M, G), G.normalize(), w.push(I.x, I.y, I.z), C.push(G.x, G.y, G.z);
                                let zt = +(De == 0) + Math.sin(dr);
                                S.push((Mt + he * zt) / ke, xt / f, 0)
                            }
                        }
                        I.addVectors(E, U), g.push(I.x, I.y, I.z), y.push(V.x, V.y, V.z), A.push((he + De * Ae) / ke, xt / f)
                    }
                }
                let Fe = w.length / 2;
                for (let De = 0; De < m; De++)
                    for (let bt = 0; bt <= f; bt++) {
                        let Mt = Fe + (bt * m + De) * 3,
                            xt = ((f - bt) * m + m - De - 1) * 3;
                        g.push(...w.slice(Mt, Mt + 3)), g.unshift(...w.slice(xt, xt + 3)), y.push(...C.slice(Mt, Mt + 3)), y.unshift(...C.slice(xt, xt + 3)), A.push(...S.slice(Mt, Mt + 2)), A.unshift(...S.slice(xt, xt + 2))
                    }
                let nt = f + 1;
                for (let De = 0; De < fe + 2 * m; De++) {
                    let bt = pe && De == fe - 1;
                    for (let Mt = 0; Mt < nt - 1; Mt++) z = De * nt + Mt, O = z + 1, X = bt ? Mt : z + nt, k = bt ? Mt + 1 : O + nt, v.push(z, O, X, O, k, X)
                }
                if (z = g.length / 3 - f - 1, !pe)
                    for (let De = 0; De < f - 2; De++) v.push(z, z + De + 1, z + De + 2), v.push(0, De + 2, De + 1);
                this.setIndex(v), this.setAttribute("position", new Kt.Float32BufferAttribute(g, 3)), this.setAttribute("normal", new Kt.Float32BufferAttribute(y, 3)), this.setAttribute("uv", new Kt.Float32BufferAttribute(A, 2))
            }
        };
    var nh = W(J()),
        sh = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    detail: 0
                }, n.parameters);
                return {
                    parameters: Object.assign(t, {
                        width: Math.abs(t.width),
                        height: Math.abs(t.height ?? t.width),
                        depth: Math.abs(t.depth ?? t.width)
                    })
                }
            }
            static build(n) {
                let {
                    width: e,
                    height: t,
                    depth: r,
                    detail: i
                } = n.parameters, s = new nh.IcosahedronBufferGeometry(e * .5, i);
                return s.scale(1, t / e, r / e), Object.assign(s, {
                    userData: je(Ne({}, n), {
                        type: "IcosahedronGeometry"
                    })
                })
            }
        };
    var pl = W(J()),
        oh = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    segments: 64,
                    verticalSegments: 64,
                    points: [{
                        x: 0,
                        y: -50,
                        id: 0
                    }, {
                        x: 50,
                        y: -50,
                        id: 1
                    }, {
                        x: 50,
                        y: 50,
                        id: 2
                    }, {
                        x: 0,
                        y: 50,
                        id: 3
                    }]
                }, n.parameters);
                return {
                    parameters: Object.assign(t, {
                        width: Math.abs(t.width),
                        height: Math.abs(t.height ?? t.width),
                        depth: Math.abs(t.depth ?? t.width)
                    })
                }
            }
            static build(n) {
                let {
                    points: e,
                    segments: t,
                    verticalSegments: r
                } = n.parameters, i = new pl.Shape;
                i.moveTo(e[0].x, e[0].y), i.bezierCurveTo(e[1].x, e[1].y, e[2].x, e[2].y, e[3].x, e[3].y);
                let s = new pl.LatheBufferGeometry(i.extractPoints(r).shape, t);
                return s.rotateZ(Math.PI), Object.assign(s, {
                    userData: je(Ne({}, n), {
                        type: "LatheGeometry"
                    })
                })
            }
        };
    var wi = W(J());
    var Ui = W(J());
    var be = W(J()),
        bi = new be.Matrix4,
        Su = new be.Object3D,
        gl = new be.Vector3,
        Rn = class extends be.EventDispatcher {
            constructor() {
                super();
                this.uuid = be.MathUtils.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }
            applyMatrix4(e) {
                let t = new be.Matrix3().getNormalMatrix(e);
                for (let r = 0, i = this.vertices.length; r < i; r++) this.vertices[r].applyMatrix4(e);
                for (let r = 0, i = this.faces.length; r < i; r++) {
                    let s = this.faces[r];
                    s.normal.applyMatrix3(t).normalize();
                    for (let o = 0, l = s.vertexNormals.length; o < l; o++) s.vertexNormals[o].applyMatrix3(t).normalize()
                }
                return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
            }
            rotateX(e) {
                return bi.makeRotationX(e), this.applyMatrix4(bi), this
            }
            rotateY(e) {
                return bi.makeRotationY(e), this.applyMatrix4(bi), this
            }
            rotateZ(e) {
                return bi.makeRotationZ(e), this.applyMatrix4(bi), this
            }
            translate(e, t, r) {
                return bi.makeTranslation(e, t, r), this.applyMatrix4(bi), this
            }
            scale(e, t, r) {
                return bi.makeScale(e, t, r), this.applyMatrix4(bi), this
            }
            lookAt(e) {
                return Su.lookAt(e), Su.updateMatrix(), this.applyMatrix4(Su.matrix), this
            }
            fromBufferGeometry(e) {
                let t = this,
                    r = e.index !== null ? e.index : void 0,
                    i = e.attributes;
                if (i.position === void 0) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                let s = i.position,
                    o = i.normal,
                    l = i.color,
                    a = i.uv,
                    c = i.uv2;
                c !== void 0 && (this.faceVertexUvs[1] = []);
                for (let m = 0; m < s.count; m++) t.vertices.push(new be.Vector3().fromBufferAttribute(s, m)), l !== void 0 && t.colors.push(new be.Color().fromBufferAttribute(l, m));

                function f(m, v, g, y) {
                    let A = l === void 0 ? [] : [t.colors[m].clone(), t.colors[v].clone(), t.colors[g].clone()],
                        w = o === void 0 ? [] : [new be.Vector3().fromBufferAttribute(o, m), new be.Vector3().fromBufferAttribute(o, v), new be.Vector3().fromBufferAttribute(o, g)],
                        C = new Jo(m, v, g, w, A, y);
                    t.faces.push(C), a !== void 0 && t.faceVertexUvs[0].push([new be.Vector2().fromBufferAttribute(a, m), new be.Vector2().fromBufferAttribute(a, v), new be.Vector2().fromBufferAttribute(a, g)]), c !== void 0 && t.faceVertexUvs[1].push([new be.Vector2().fromBufferAttribute(c, m), new be.Vector2().fromBufferAttribute(c, v), new be.Vector2().fromBufferAttribute(c, g)])
                }
                let h = e.groups;
                if (h.length > 0)
                    for (let m = 0; m < h.length; m++) {
                        let v = h[m],
                            g = v.start,
                            y = v.count;
                        for (let A = g, w = g + y; A < w; A += 3) r !== void 0 ? f(r.getX(A), r.getX(A + 1), r.getX(A + 2), v.materialIndex) : f(A, A + 1, A + 2, v.materialIndex)
                    } else if (r !== void 0)
                        for (let m = 0; m < r.count; m += 3) f(r.getX(m), r.getX(m + 1), r.getX(m + 2));
                    else
                        for (let m = 0; m < s.count; m += 3) f(m, m + 1, m + 2);
                return this.computeFaceNormals(), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(gl).negate(), this.translate(gl.x, gl.y, gl.z), this
            }
            normalize() {
                this.computeBoundingSphere();
                let e = this.boundingSphere.center,
                    t = this.boundingSphere.radius,
                    r = t === 0 ? 1 : 1 / t,
                    i = new be.Matrix4;
                return i.set(r, 0, 0, -r * e.x, 0, r, 0, -r * e.y, 0, 0, r, -r * e.z, 0, 0, 0, 1), this.applyMatrix4(i), this
            }
            computeFaceNormals() {
                let e = new be.Vector3,
                    t = new be.Vector3;
                for (let r = 0, i = this.faces.length; r < i; r++) {
                    let s = this.faces[r],
                        o = this.vertices[s.a],
                        l = this.vertices[s.b],
                        a = this.vertices[s.c];
                    e.subVectors(a, l), t.subVectors(o, l), e.cross(t), e.normalize(), s.normal.copy(e)
                }
            }
            computeVertexNormals(e = !0) {
                let t = new Array(this.vertices.length);
                for (let r = 0, i = this.vertices.length; r < i; r++) t[r] = new be.Vector3;
                if (e) {
                    let r = new be.Vector3,
                        i = new be.Vector3;
                    for (let s = 0, o = this.faces.length; s < o; s++) {
                        let l = this.faces[s],
                            a = this.vertices[l.a],
                            c = this.vertices[l.b],
                            f = this.vertices[l.c];
                        r.subVectors(f, c), i.subVectors(a, c), r.cross(i), t[l.a].add(r), t[l.b].add(r), t[l.c].add(r)
                    }
                } else {
                    this.computeFaceNormals();
                    for (let r = 0, i = this.faces.length; r < i; r++) {
                        let s = this.faces[r];
                        t[s.a].add(s.normal), t[s.b].add(s.normal), t[s.c].add(s.normal)
                    }
                }
                for (let r = 0, i = this.vertices.length; r < i; r++) t[r].normalize();
                for (let r = 0, i = this.faces.length; r < i; r++) {
                    let s = this.faces[r],
                        o = s.vertexNormals;
                    o.length === 3 ? (o[0].copy(t[s.a]), o[1].copy(t[s.b]), o[2].copy(t[s.c])) : (o[0] = t[s.a].clone(), o[1] = t[s.b].clone(), o[2] = t[s.c].clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            }
            computeFlatVertexNormals() {
                this.computeFaceNormals();
                for (let e = 0, t = this.faces.length; e < t; e++) {
                    let r = this.faces[e],
                        i = r.vertexNormals;
                    i.length === 3 ? (i[0].copy(r.normal), i[1].copy(r.normal), i[2].copy(r.normal)) : (i[0] = r.normal.clone(), i[1] = r.normal.clone(), i[2] = r.normal.clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            }
            computeMorphNormals() {
                for (let t = 0, r = this.faces.length; t < r; t++) {
                    let i = this.faces[t];
                    i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []);
                    for (let s = 0, o = i.vertexNormals.length; s < o; s++) i.__originalVertexNormals[s] ? i.__originalVertexNormals[s].copy(i.vertexNormals[s]) : i.__originalVertexNormals[s] = i.vertexNormals[s].clone()
                }
                let e = new Rn;
                e.faces = this.faces;
                for (let t = 0, r = this.morphTargets.length; t < r; t++) {
                    if (!this.morphNormals[t]) {
                        this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                        let s = this.morphNormals[t].faceNormals,
                            o = this.morphNormals[t].vertexNormals;
                        for (let l = 0, a = this.faces.length; l < a; l++) {
                            let c = new be.Vector3,
                                f = {
                                    a: new be.Vector3,
                                    b: new be.Vector3,
                                    c: new be.Vector3
                                };
                            s.push(c), o.push(f)
                        }
                    }
                    let i = this.morphNormals[t];
                    e.vertices = this.morphTargets[t].vertices, e.computeFaceNormals(), e.computeVertexNormals();
                    for (let s = 0, o = this.faces.length; s < o; s++) {
                        let l = this.faces[s],
                            a = i.faceNormals[s],
                            c = i.vertexNormals[s];
                        a.copy(l.normal), c.a.copy(l.vertexNormals[0]), c.b.copy(l.vertexNormals[1]), c.c.copy(l.vertexNormals[2])
                    }
                }
                for (let t = 0, r = this.faces.length; t < r; t++) {
                    let i = this.faces[t];
                    i.normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
                }
            }
            computeBoundingBox() {
                this.boundingBox === null && (this.boundingBox = new be.Box3), this.boundingBox.setFromPoints(this.vertices)
            }
            computeBoundingSphere() {
                this.boundingSphere === null && (this.boundingSphere = new be.Sphere), this.boundingSphere.setFromPoints(this.vertices)
            }
            merge(e, t, r = 0) {
                if (!(e && e.isGeometry)) {
                    console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
                    return
                }
                let i, s = this.vertices.length,
                    o = this.vertices,
                    l = e.vertices,
                    a = this.faces,
                    c = e.faces,
                    f = this.colors,
                    h = e.colors;
                t !== void 0 && (i = new be.Matrix3().getNormalMatrix(t));
                for (let m = 0, v = l.length; m < v; m++) {
                    let y = l[m].clone();
                    t !== void 0 && y.applyMatrix4(t), o.push(y)
                }
                for (let m = 0, v = h.length; m < v; m++) f.push(h[m].clone());
                for (let m = 0, v = c.length; m < v; m++) {
                    let g = c[m],
                        y, A, w = g.vertexNormals,
                        C = g.vertexColors,
                        S = new Jo(g.a + s, g.b + s, g.c + s);
                    S.normal.copy(g.normal), i !== void 0 && S.normal.applyMatrix3(i).normalize();
                    for (let E = 0, M = w.length; E < M; E++) y = w[E].clone(), i !== void 0 && y.applyMatrix3(i).normalize(), S.vertexNormals.push(y);
                    S.color.copy(g.color);
                    for (let E = 0, M = C.length; E < M; E++) A = C[E], S.vertexColors.push(A.clone());
                    S.materialIndex = g.materialIndex + r, a.push(S)
                }
                for (let m = 0, v = e.faceVertexUvs.length; m < v; m++) {
                    let g = e.faceVertexUvs[m];
                    this.faceVertexUvs[m] === void 0 && (this.faceVertexUvs[m] = []);
                    for (let y = 0, A = g.length; y < A; y++) {
                        let w = g[y],
                            C = [];
                        for (let S = 0, E = w.length; S < E; S++) C.push(w[S].clone());
                        this.faceVertexUvs[m].push(C)
                    }
                }
            }
            mergeMesh(e) {
                if (!(e && e.isMesh)) {
                    console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e);
                    return
                }
                e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)
            }
            mergeVertices(e = 4) {
                let t = {},
                    r = [],
                    i = [],
                    s = Math.pow(10, e);
                for (let a = 0, c = this.vertices.length; a < c; a++) {
                    let f = this.vertices[a],
                        h = Math.round(f.x * s) + "_" + Math.round(f.y * s) + "_" + Math.round(f.z * s);
                    t[h] === void 0 ? (t[h] = a, r.push(this.vertices[a]), i[a] = r.length - 1) : i[a] = i[t[h]]
                }
                let o = [];
                for (let a = 0, c = this.faces.length; a < c; a++) {
                    let f = this.faces[a];
                    f.a = i[f.a], f.b = i[f.b], f.c = i[f.c];
                    let h = [f.a, f.b, f.c];
                    for (let m = 0; m < 3; m++)
                        if (h[m] === h[(m + 1) % 3]) {
                            o.push(a);
                            break
                        }
                }
                for (let a = o.length - 1; a >= 0; a--) {
                    let c = o[a];
                    this.faces.splice(c, 1);
                    for (let f = 0, h = this.faceVertexUvs.length; f < h; f++) this.faceVertexUvs[f].splice(c, 1)
                }
                let l = this.vertices.length - r.length;
                return this.vertices = r, l
            }
            setFromPoints(e) {
                this.vertices = [];
                for (let t = 0, r = e.length; t < r; t++) {
                    let i = e[t];
                    this.vertices.push(new be.Vector3(i.x, i.y, i.z || 0))
                }
                return this
            }
            sortFacesByMaterialIndex() {
                let e = this.faces,
                    t = e.length;
                for (let a = 0; a < t; a++) e[a]._id = a;

                function r(a, c) {
                    return a.materialIndex - c.materialIndex
                }
                e.sort(r);
                let i = this.faceVertexUvs[0],
                    s = this.faceVertexUvs[1],
                    o, l;
                i && i.length === t && (o = []), s && s.length === t && (l = []);
                for (let a = 0; a < t; a++) {
                    let c = e[a]._id;
                    o && o.push(i[c]), l && l.push(s[c])
                }
                o && (this.faceVertexUvs[0] = o), l && (this.faceVertexUvs[1] = l)
            }
            toJSON() {
                let e = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), this.parameters !== void 0) {
                    let g = this.parameters;
                    for (let y in g) g[y] !== void 0 && (e[y] = g[y]);
                    return e
                }
                let t = [];
                for (let g = 0; g < this.vertices.length; g++) {
                    let y = this.vertices[g];
                    t.push(y.x, y.y, y.z)
                }
                let r = [],
                    i = [],
                    s = {},
                    o = [],
                    l = {},
                    a = [],
                    c = {};
                for (let g = 0; g < this.faces.length; g++) {
                    let y = this.faces[g],
                        A = !0,
                        w = !1,
                        C = this.faceVertexUvs[0][g] !== void 0,
                        S = y.normal.length() > 0,
                        E = y.vertexNormals.length > 0,
                        M = y.color.r !== 1 || y.color.g !== 1 || y.color.b !== 1,
                        L = y.vertexColors.length > 0,
                        I = 0;
                    if (I = f(I, 0, 0), I = f(I, 1, A), I = f(I, 2, w), I = f(I, 3, C), I = f(I, 4, S), I = f(I, 5, E), I = f(I, 6, M), I = f(I, 7, L), r.push(I), r.push(y.a, y.b, y.c), r.push(y.materialIndex), C) {
                        let z = this.faceVertexUvs[0][g];
                        r.push(v(z[0]), v(z[1]), v(z[2]))
                    }
                    if (S && r.push(h(y.normal)), E) {
                        let z = y.vertexNormals;
                        r.push(h(z[0]), h(z[1]), h(z[2]))
                    }
                    if (M && r.push(m(y.color)), L) {
                        let z = y.vertexColors;
                        r.push(m(z[0]), m(z[1]), m(z[2]))
                    }
                }

                function f(g, y, A) {
                    return A ? g | 1 << y : g & ~(1 << y)
                }

                function h(g) {
                    let y = g.x.toString() + g.y.toString() + g.z.toString();
                    return s[y] !== void 0 || (s[y] = i.length / 3, i.push(g.x, g.y, g.z)), s[y]
                }

                function m(g) {
                    let y = g.r.toString() + g.g.toString() + g.b.toString();
                    return l[y] !== void 0 || (l[y] = o.length, o.push(g.getHex())), l[y]
                }

                function v(g) {
                    let y = g.x.toString() + g.y.toString();
                    return c[y] !== void 0 || (c[y] = a.length / 2, a.push(g.x, g.y)), c[y]
                }
                return e.data = {}, e.data.vertices = t, e.data.normals = i, o.length > 0 && (e.data.colors = o), a.length > 0 && (e.data.uvs = [a]), e.data.faces = r, e
            }
            clone() {
                return new Rn().copy(this)
            }
            copy(e) {
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                let t = e.vertices;
                for (let m = 0, v = t.length; m < v; m++) this.vertices.push(t[m].clone());
                let r = e.colors;
                for (let m = 0, v = r.length; m < v; m++) this.colors.push(r[m].clone());
                let i = e.faces;
                for (let m = 0, v = i.length; m < v; m++) this.faces.push(i[m].clone());
                for (let m = 0, v = e.faceVertexUvs.length; m < v; m++) {
                    let g = e.faceVertexUvs[m];
                    this.faceVertexUvs[m] === void 0 && (this.faceVertexUvs[m] = []);
                    for (let y = 0, A = g.length; y < A; y++) {
                        let w = g[y],
                            C = [];
                        for (let S = 0, E = w.length; S < E; S++) {
                            let M = w[S];
                            C.push(M.clone())
                        }
                        this.faceVertexUvs[m].push(C)
                    }
                }
                let s = e.morphTargets;
                for (let m = 0, v = s.length; m < v; m++) {
                    let g = {};
                    if (g.name = s[m].name, s[m].vertices !== void 0) {
                        g.vertices = [];
                        for (let y = 0, A = s[m].vertices.length; y < A; y++) g.vertices.push(s[m].vertices[y].clone())
                    }
                    if (s[m].normals !== void 0) {
                        g.normals = [];
                        for (let y = 0, A = s[m].normals.length; y < A; y++) g.normals.push(s[m].normals[y].clone())
                    }
                    this.morphTargets.push(g)
                }
                let o = e.morphNormals;
                for (let m = 0, v = o.length; m < v; m++) {
                    let g = {};
                    if (o[m].vertexNormals !== void 0) {
                        g.vertexNormals = [];
                        for (let y = 0, A = o[m].vertexNormals.length; y < A; y++) {
                            let w = o[m].vertexNormals[y],
                                C = {};
                            C.a = w.a.clone(), C.b = w.b.clone(), C.c = w.c.clone(), g.vertexNormals.push(C)
                        }
                    }
                    if (o[m].faceNormals !== void 0) {
                        g.faceNormals = [];
                        for (let y = 0, A = o[m].faceNormals.length; y < A; y++) g.faceNormals.push(o[m].faceNormals[y].clone())
                    }
                    this.morphNormals.push(g)
                }
                let l = e.skinWeights;
                for (let m = 0, v = l.length; m < v; m++) this.skinWeights.push(l[m].clone());
                let a = e.skinIndices;
                for (let m = 0, v = a.length; m < v; m++) this.skinIndices.push(a[m].clone());
                let c = e.lineDistances;
                for (let m = 0, v = c.length; m < v; m++) this.lineDistances.push(c[m]);
                let f = e.boundingBox;
                f !== null && (this.boundingBox = f.clone());
                let h = e.boundingSphere;
                return h !== null && (this.boundingSphere = h.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
            }
            toBufferGeometry() {
                let e = new ah().fromGeometry(this),
                    t = new be.BufferGeometry,
                    r = new Float32Array(e.vertices.length * 3);
                if (t.setAttribute("position", new be.BufferAttribute(r, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
                    let i = new Float32Array(e.normals.length * 3);
                    t.setAttribute("normal", new be.BufferAttribute(i, 3).copyVector3sArray(e.normals))
                }
                if (e.colors.length > 0) {
                    let i = new Float32Array(e.colors.length * 3);
                    t.setAttribute("color", new be.BufferAttribute(i, 3).copyColorsArray(e.colors))
                }
                if (e.uvs.length > 0) {
                    let i = new Float32Array(e.uvs.length * 2);
                    t.setAttribute("uv", new be.BufferAttribute(i, 2).copyVector2sArray(e.uvs))
                }
                if (e.uvs2.length > 0) {
                    let i = new Float32Array(e.uvs2.length * 2);
                    t.setAttribute("uv2", new be.BufferAttribute(i, 2).copyVector2sArray(e.uvs2))
                }
                t.groups = e.groups;
                for (let i in e.morphTargets) {
                    let s = [],
                        o = e.morphTargets[i];
                    for (let l = 0, a = o.length; l < a; l++) {
                        let c = o[l],
                            f = new be.Float32BufferAttribute(c.data.length * 3, 3);
                        f.name = c.name, s.push(f.copyVector3sArray(c.data))
                    }
                    t.morphAttributes[i] = s
                }
                if (e.skinIndices.length > 0) {
                    let i = new be.Float32BufferAttribute(e.skinIndices.length * 4, 4);
                    t.setAttribute("skinIndex", i.copyVector4sArray(e.skinIndices))
                }
                if (e.skinWeights.length > 0) {
                    let i = new be.Float32BufferAttribute(e.skinWeights.length * 4, 4);
                    t.setAttribute("skinWeight", i.copyVector4sArray(e.skinWeights))
                }
                return e.boundingSphere !== null && (t.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (t.boundingBox = e.boundingBox.clone()), t
            }
            computeTangents() {
                console.error("THREE.Geometry: .computeTangents() has been removed.")
            }
            computeLineDistances() {
                console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
            }
            applyMatrix(e) {
                return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            static createBufferGeometryFromObject(e) {
                let t = new be.BufferGeometry,
                    r = e.geometry;
                if (e.isPoints || e.isLine) {
                    let i = new be.Float32BufferAttribute(r.vertices.length * 3, 3),
                        s = new be.Float32BufferAttribute(r.colors.length * 3, 3);
                    if (t.setAttribute("position", i.copyVector3sArray(r.vertices)), t.setAttribute("color", s.copyColorsArray(r.colors)), r.lineDistances && r.lineDistances.length === r.vertices.length) {
                        let o = new be.Float32BufferAttribute(r.lineDistances.length, 1);
                        t.setAttribute("lineDistance", o.copyArray(r.lineDistances))
                    }
                    r.boundingSphere !== null && (t.boundingSphere = r.boundingSphere.clone()), r.boundingBox !== null && (t.boundingBox = r.boundingBox.clone())
                } else e.isMesh && (t = r.toBufferGeometry());
                return t
            }
        };
    Rn.prototype.isGeometry = !0;
    var ah = class {
            constructor() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }
            computeGroups(e) {
                let t = [],
                    r, i, s, o = e.faces;
                for (i = 0; i < o.length; i++) {
                    let l = o[i];
                    l.materialIndex !== s && (s = l.materialIndex, r !== void 0 && (r.count = i * 3 - r.start, t.push(r)), r = {
                        start: i * 3,
                        materialIndex: s
                    })
                }
                r !== void 0 && (r.count = i * 3 - r.start, t.push(r)), this.groups = t
            }
            fromGeometry(e) {
                let t = e.faces,
                    r = e.vertices,
                    i = e.faceVertexUvs,
                    s = i[0] && i[0].length > 0,
                    o = i[1] && i[1].length > 0,
                    l = e.morphTargets,
                    a = l.length,
                    c;
                if (a > 0) {
                    c = [];
                    for (let w = 0; w < a; w++) c[w] = {
                        name: l[w].name,
                        data: []
                    };
                    this.morphTargets.position = c
                }
                let f = e.morphNormals,
                    h = f.length,
                    m;
                if (h > 0) {
                    m = [];
                    for (let w = 0; w < h; w++) m[w] = {
                        name: f[w].name,
                        data: []
                    };
                    this.morphTargets.normal = m
                }
                let v = e.skinIndices,
                    g = e.skinWeights,
                    y = v.length === r.length,
                    A = g.length === r.length;
                r.length > 0 && t.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                for (let w = 0; w < t.length; w++) {
                    let C = t[w];
                    this.vertices.push(r[C.a], r[C.b], r[C.c]);
                    let S = C.vertexNormals;
                    if (S.length === 3) this.normals.push(S[0], S[1], S[2]);
                    else {
                        let M = C.normal;
                        this.normals.push(M, M, M)
                    }
                    let E = C.vertexColors;
                    if (E.length === 3) this.colors.push(E[0], E[1], E[2]);
                    else {
                        let M = C.color;
                        this.colors.push(M, M, M)
                    }
                    if (s === !0) {
                        let M = i[0][w];
                        M !== void 0 ? this.uvs.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", w), this.uvs.push(new be.Vector2, new be.Vector2, new be.Vector2))
                    }
                    if (o === !0) {
                        let M = i[1][w];
                        M !== void 0 ? this.uvs2.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", w), this.uvs2.push(new be.Vector2, new be.Vector2, new be.Vector2))
                    }
                    for (let M = 0; M < a; M++) {
                        let L = l[M].vertices;
                        c[M].data.push(L[C.a], L[C.b], L[C.c])
                    }
                    for (let M = 0; M < h; M++) {
                        let L = f[M].vertexNormals[w];
                        m[M].data.push(L.a, L.b, L.c)
                    }
                    y && this.skinIndices.push(v[C.a], v[C.b], v[C.c]), A && this.skinWeights.push(g[C.a], g[C.b], g[C.c])
                }
                return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), this
            }
        },
        Jo = class {
            constructor(e, t, r, i, s, o = 0) {
                this.a = e, this.b = t, this.c = r, this.normal = i && i.isVector3 ? i : new be.Vector3, this.vertexNormals = Array.isArray(i) ? i : [], this.color = s && s.isColor ? s : new be.Color, this.vertexColors = Array.isArray(s) ? s : [], this.materialIndex = o
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
                for (let t = 0, r = e.vertexNormals.length; t < r; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                for (let t = 0, r = e.vertexColors.length; t < r; t++) this.vertexColors[t] = e.vertexColors[t].clone();
                return this
            }
        };
    var h0 = ["a", "b", "c"];

    function m0(n, e) {
        switch (e) {
            case "c":
                return n.c;
            case "b":
                return n.b;
            case "a":
            default:
                return n.a
        }
    }

    function Nu(n, e, t) {
        let r = Math.min(n, e),
            i = Math.max(n, e),
            s = r + "_" + i;
        return t.get(s)
    }

    function Cu(n, e, t, r, i, s) {
        let o = Math.min(n, e),
            l = Math.max(n, e),
            a = o + "_" + l,
            c;
        if (r.has(a)) c = r.get(a);
        else {
            let f = t[o],
                h = t[l];
            c = {
                a: f,
                b: h,
                newEdge: null,
                faces: []
            }, r.set(a, c)
        }
        c.faces.push(i), s[n].edges.push(c), s[e].edges.push(c)
    }

    function p0(n, e, t, r) {
        let i, s, o;
        for (i = 0, s = n.length; i < s; i++) t[i] = {
            edges: []
        };
        for (i = 0, s = e.length; i < s; i++) o = e[i], Cu(o.a, o.b, n, r, o, t), Cu(o.b, o.c, n, r, o, t), Cu(o.c, o.a, n, r, o, t)
    }

    function vl(n, e, t, r, i) {
        n.push(new Jo(e, t, r, void 0, void 0, i))
    }

    function Os(n, e) {
        return Math.abs(e - n) / 2 + Math.min(n, e)
    }

    function yl(n, e, t, r) {
        n.push([e.clone(), t.clone(), r.clone()])
    }
    var Tu = class {
        constructor(e = 1) {
            this.subdivisions = e
        }
        modify(e) {
            e instanceof Ui.BufferGeometry ? e = new Rn().fromBufferGeometry(e) : e = e.clone(), e.mergeVertices();
            let t = this.subdivisions;
            for (; t-- > 0;) this._smooth(e);
            return e.computeFaceNormals(), e.computeVertexNormals(), e
        }
        _smooth(e) {
            let t = new Ui.Vector3,
                r, i, s, o, l, a = e.vertices,
                c = e.faces,
                f = e.faceVertexUvs[0],
                h = f !== void 0 && f.length > 0,
                m = [],
                v = new Map;
            p0(a, c, m, v);
            let g = [],
                y, A, w, C, S, E, M;
            for (let Se of Array.from(v.keys())) {
                for (A = v.get(Se), w = new Ui.Vector3, S = 3 / 8, E = 1 / 8, M = A.faces.length, M != 2 && (S = .5, E = 0, M != 1), w.addVectors(A.a, A.b).multiplyScalar(S), t.set(0, 0, 0), o = 0; o < M; o++) {
                    for (C = A.faces[o], l = 0; l < 3 && (y = a[m0(C, h0[l])], !(y !== A.a && y !== A.b)); l++);
                    y && t.add(y)
                }
                t.multiplyScalar(E), w.add(t), A.newEdge = g.length, g.push(w)
            }
            let L, I, z, O, X, k, Q, te = [];
            for (i = 0, s = a.length; i < s; i++) {
                for (k = a[i], X = m[i].edges, r = X.length, r == 3 ? L = 3 / 16 : r > 3 && (L = 3 / (8 * r)), I = 1 - r * Number(L), z = L, r <= 2 && (r == 2 ? (I = 3 / 4, z = 1 / 8) : r == 1 || r == 0), Q = k.clone().multiplyScalar(I), t.set(0, 0, 0), o = 0; o < r; o++) O = X[o], y = O.a !== k ? O.a : O.b, t.add(y);
                t.multiplyScalar(Number(z)), Q.add(t), te.push(Q)
            }
            let Z = te.concat(g),
                le = te.length,
                B, U, G, V = [],
                j = [],
                ne, F, Y, $, re = new Ui.Vector2,
                fe = new Ui.Vector2,
                ye = new Ui.Vector2;
            for (i = 0, s = c.length; i < s; i++) C = c[i], B = Number(Nu(C.a, C.b, v).newEdge) + le, U = Number(Nu(C.b, C.c, v).newEdge) + le, G = Number(Nu(C.c, C.a, v).newEdge) + le, vl(V, B, U, G, C.materialIndex), vl(V, C.a, B, G, C.materialIndex), vl(V, C.b, U, B, C.materialIndex), vl(V, C.c, G, U, C.materialIndex), h && (ne = f[i], F = ne[0], Y = ne[1], $ = ne[2], re.set(Os(F.x, Y.x), Os(F.y, Y.y)), fe.set(Os(Y.x, $.x), Os(Y.y, $.y)), ye.set(Os(F.x, $.x), Os(F.y, $.y)), yl(j, re, fe, ye), yl(j, F, re, ye), yl(j, Y, fe, re), yl(j, $, ye, fe));
            e.vertices = Z, e.faces = V, h && (e.faceVertexUvs[0] = j)
        }
    };
    var Vt = new wi.Vector3,
        Fn = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = n.geometry ?? e?.geometry ?? new wi.BufferGeometry().copy(new wi.BoxBufferGeometry(100, 100, 100)),
                    r;
                e === void 0 ? (t.computeBoundingBox(), t.boundingBox.getSize(Vt), r = {
                    width: Vt.x,
                    height: Vt.y,
                    depth: Vt.z,
                    subdivisions: 0
                }) : r = e.parameters;
                let i = Ne(Ne({}, r), n.parameters);
                return {
                    parameters: {
                        width: Math.abs(i.width),
                        height: Math.abs(i.height),
                        depth: Math.abs(i.depth),
                        subdivisions: Math.abs(i.subdivisions)
                    },
                    geometry: t
                }
            }
            static build(n) {
                let {
                    width: e,
                    height: t,
                    depth: r,
                    subdivisions: i
                } = n.parameters, s = n.geometry ?? new wi.BufferGeometry().copy(new wi.BoxBufferGeometry(100, 100, 100)), o = s.userData.parameters;
                o === void 0 ? (s.computeBoundingBox(), s.boundingBox.getSize(Vt)) : Vt.set(o.width, o.height, o.depth), (e !== Vt.x || t !== Vt.y || r !== Vt.z) && s.scale(Vt.x === 0 ? 1 : e / Vt.x, Vt.y === 0 ? 1 : t / Vt.y, Vt.z === 0 ? 1 : r / Vt.z);
                let l = s.originalGeometry;
                return i > 0 ? (l === void 0 || o?.subdivisions > i) && (l === void 0 && (l = s), s = new Tu(i).modify(l).toBufferGeometry()) : (l !== void 0 && (s = l), l = void 0), l !== void 0 && Object.assign(s, {
                    originalGeometry: l
                }), delete n.geometry, Object.assign(s, {
                    userData: je(Ne({}, n), {
                        type: "NonParametricGeometry"
                    })
                })
            }
            static loadFromUrl(n, e, t) {
                new wi.BufferGeometryLoader(t).load(n, i => {
                    let s = this.normalizeInputs({
                        geometry: i
                    });
                    i.boundingBox.getSize(Vt);
                    let o = 100 / Vt.x;
                    Object.assign(s.parameters, {
                        width: 100,
                        height: Vt.y * o,
                        depth: Vt.z * o
                    }), e(this.build(s))
                })
            }
        };
    var lh = class {
        static create(n) {
            return this.build(this.normalizeInputs(n))
        }
        static normalizeInputs(n, e) {
            let t = Object.assign({}, e?.parameters ?? {
                width: 100,
                depth: 0,
                spikes: 5,
                cornerRadius: 0,
                extrudeDepth: 0,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 3
            }, n.parameters);
            return {
                shape: new Ot,
                parameters: Object.assign(t, {
                    surfaceMaxCount: t.surfaceMaxCount ?? t.cornerRadius > 0 ? 1e3 : 100,
                    width: Math.abs(t.width),
                    height: Math.abs(t.height ?? t.width)
                })
            }
        }
        static build(n) {
            let {
                width: e,
                height: t,
                spikes: r,
                cornerRadius: i,
                extrudeDepth: s,
                extrudeBevelSize: o,
                extrudeBevelSegments: l,
                surfaceMaxCount: a
            } = n.parameters, c = n.shape, f = e * .5, h = t * .5, m = 0, v = 0, g = 2 * Math.PI / r;
            for (let A = 0; A < r; A++) {
                let w = g * A,
                    C = m + Math.sin(w) * f,
                    S = v + Math.cos(w) * h;
                c.addPoint(c.createPoint(C, S))
            }
            c.isClosed = !0;
            for (let A = 0, w = c.points.length; A < w; A++) c.points[A].roundness = i;
            c.roundness = i, c.update();
            let y = lr.create({
                shape: c,
                parameters: {
                    surfaceMaxCount: a,
                    roundness: i,
                    extrudeDepth: s,
                    extrudeBevelSize: o,
                    extrudeBevelSegments: l
                }
            });
            return Object.assign(y, {
                userData: je(Ne({}, n), {
                    type: "PolygonGeometry"
                })
            })
        }
    };
    var $e = W(J()),
        ch = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    radialSegments: 4,
                    heightSegments: 1,
                    cornerRadius: 0,
                    cornerSegments: 8,
                    openEnded: !1
                }, n.parameters);
                return {
                    parameters: Object.assign(t, {
                        width: Math.abs(t.width),
                        height: Math.abs(t.height ?? t.width),
                        depth: Math.abs(t.depth ?? t.width)
                    })
                }
            }
            static build(n) {
                let {
                    width: e,
                    height: t,
                    depth: r,
                    radialSegments: i,
                    heightSegments: s,
                    openEnded: o,
                    cornerRadius: l,
                    cornerSegments: a
                } = n.parameters, c = new uh(e * .5, t, i, s, o, l, a);
                return c.scale(1, 1, r / e), Object.assign(c, {
                    userData: je(Ne({}, n), {
                        type: "PyramidGeometry"
                    })
                })
            }
        };

    function Qo(n, e, t) {
        t.x = n.x * e.x, t.y = n.y, t.z = n.x * e.y
    }

    function Eu(n, e, t, r, i, s) {
        let o = e.clone().sub(n),
            l = t.clone().sub(n),
            a = o.angleTo(l);
        if (o.normalize(), l.normalize(), r === i) {
            let c = o.add(l).normalize();
            s.copy(n).addScaledVector(c, r / Math.sin(a / 2))
        } else {
            let c = o.angleTo(l);
            s.copy(n), s.addScaledVector(o, i / Math.sin(c)), s.addScaledVector(l, r / Math.sin(c))
        }
    }

    function g0(n, e, t) {
        let r = n.clone().sub(e),
            i = t.clone().sub(e);
        return r.projectOnVector(i), r.add(e)
    }
    var uh = class extends $e.BufferGeometry {
        constructor(e = .5, t = 1, r = 4, i = 1, s = !1, o = 0, l = 4) {
            super();
            r = Math.floor(Math.max(3, r)), i = Math.floor(i), l = Math.floor(l);
            let a = [],
                c = [],
                f = [],
                h = [],
                m = 0,
                v = t / 2,
                g = Math.PI / r,
                y = e * Math.cos(Math.PI / r),
                A = 2 * Math.PI / r,
                w = (r - 2) * Math.PI / r,
                C = Math.PI - w,
                S = new $e.Vector3(0, -v, 0),
                E = new $e.Vector3(0, v, 0),
                M = new $e.Vector2(e, -v),
                L = new $e.Vector2(y, -v),
                I = new $e.Vector2(0, E.y).sub(L),
                z = new $e.Vector2(0, E.y).sub(M),
                O = new $e.Vector2(I.y, -I.x).normalize(),
                X = new $e.Vector2(z.y, -z.x).normalize(),
                Q = e * Math.cos(Math.PI / r) * Math.tan((Math.PI - I.angle()) / 2) - 1e-8;
            o = Math.min(o, Q);
            let te; {
                let j = new $e.Vector3(O.x, O.y, 0),
                    ne = new $e.Vector3(Math.cos(A) * j.x, j.y, Math.sin(A) * j.x);
                te = j.angleTo(ne)
            }
            let Z = o / Math.tan((Math.PI - I.angle()) / 2),
                le = o / Math.tan((Math.PI - te) / 2),
                B = new $e.Vector3;
            if (!s) {
                c.push(S.x, S.y, S.z), f.push(0, -1, 0), h.push(0, 0);
                let j = m++,
                    ne = [],
                    F = M.clone(),
                    Y = Z / Math.cos(Math.PI / r);
                F.x -= Y;
                for (let $ = 0; $ < r; $++) {
                    let re = $ / r * Math.PI * 2 + g,
                        fe = new $e.Vector2(Math.sin(re), Math.cos(re));
                    Qo(F, fe, B), c.push(B.x, B.y, B.z), f.push(0, -1, 0), h.push(0, 0), ne.push(m++)
                }
                for (let $ = 0; $ < ne.length; $++) a.push(ne[$], j, ne[($ + 1) % ne.length])
            }
            let U = []; {
                let j = new $e.Vector3,
                    ne = new $e.Vector3,
                    F = new $e.Vector3,
                    Y = new $e.Vector3,
                    $ = new $e.Vector3,
                    re = new $e.Vector3;
                for (let fe = 0; fe < r; fe++) {
                    let ye = fe / r * Math.PI * 2 + g,
                        Se = (fe + .5) / r * Math.PI * 2 + g,
                        se = (fe + 1) / r * Math.PI * 2 + g,
                        ie = new $e.Vector2(Math.sin(ye), Math.cos(ye)),
                        oe = new $e.Vector2(Math.sin(Se), Math.cos(Se)),
                        he = new $e.Vector2(Math.sin(se), Math.cos(se));
                    Qo(M, ie, ne), Qo(M, he, F), Qo(O, oe, j), Eu(E, ne, F, le, le, Y), c.push(Y.x, Y.y, Y.z), Eu(ne, E, F, le, Z, $), c.push($.x, $.y, $.z), Eu(F, ne, E, Z, le, re), c.push(re.x, re.y, re.z), f.push(j.x, j.y, j.z), f.push(j.x, j.y, j.z), f.push(j.x, j.y, j.z), h.push(0, 0), h.push(0, 0), h.push(0, 0);
                    let pe = m++,
                        q = m++,
                        Ae = m++;
                    if (a.push(pe, q, Ae), o > 0) {
                        {
                            let Te = ne.clone().add(F).multiplyScalar(.5),
                                Fe = E.clone().sub(Te).normalize(),
                                De = S.clone().sub(Te).normalize().add(Fe).normalize().multiplyScalar(-1),
                                bt = re.clone().sub($);
                            G(Te, bt, De, I.angle())
                        }
                        let ke, Ce; {
                            let Te = new $e.Vector3;
                            Qo(X, he, Te);
                            let Fe = re.clone().add(Y).multiplyScalar(.5);
                            Fe = g0(Fe, F, E);
                            let nt = re.clone().sub(Y);
                            [ke, Ce] = G(Fe, nt, Te, te, Y.y)
                        } {
                            let Te = ke,
                                Fe = Te.clone().setY(0).normalize(),
                                nt = new $e.Vector3(0, -1, 0),
                                De = Fe.clone().cross(nt);
                            V(Te, Fe, nt, De)
                        }
                        U.concat(Ce); {
                            let Te = I.angle(),
                                Fe = Math.PI - Te,
                                nt = E.clone();
                            nt.y -= o / Math.sin(Te - Math.PI / 2);
                            let De = new $e.Vector3,
                                bt = [];
                            for (let xt = 0; xt < l; xt++) {
                                let tr = [],
                                    rr = Math.PI / 2 - Fe * xt / l,
                                    dr = Math.cos(rr),
                                    zt = Math.sin(rr),
                                    gi = Se;
                                for (let is = 0; is <= xt; is++) {
                                    let Kr = Math.cos(gi),
                                        wn = Math.sin(gi);
                                    j.x = dr * wn, j.y = zt, j.z = dr * Kr, De.copy(nt).addScaledVector(j, o), c.push(De.x, De.y, De.z), f.push(j.x, j.y, j.z), h.push(0, 0), tr.push(m++), gi += Math.PI * 2 / xt / r
                                }
                                bt.push(tr)
                            }
                            Ce.reverse(), bt.push(Ce);
                            let Mt = bt.length - 1;
                            for (let xt = 0; xt < Mt; xt++) {
                                let tr = bt[xt],
                                    rr = bt[xt + 1],
                                    dr = tr.length - 1;
                                a.push(rr[1], tr[0], rr[0]);
                                for (let zt = 1; zt <= dr; zt++) a.push(tr[zt], tr[zt - 1], rr[zt]), a.push(rr[zt + 1], tr[zt], rr[zt])
                            }
                        }
                    }
                }
            }
            this.setIndex(a), this.setAttribute("position", new $e.Float32BufferAttribute(c, 3)), this.setAttribute("normal", new $e.Float32BufferAttribute(f, 3)), this.setAttribute("uv", new $e.Float32BufferAttribute(h, 2));

            function G(j, ne, F, Y, $) {
                let re = -Y / 2,
                    fe = (Math.PI - Y) / 2,
                    ye = ne.clone().normalize().cross(F);
                j.addScaledVector(F, -o / Math.sin(fe));
                let Se = new $e.Vector3,
                    se = new $e.Vector3,
                    ie = 1,
                    oe = m,
                    he = [];
                for (let pe = 0; pe <= l; pe++) {
                    let q = re + pe / l * Y;
                    se.set(0, 0, 0), se.addScaledVector(ye, Math.sin(q)), se.addScaledVector(F, Math.cos(q));
                    for (let Ae = 0; Ae <= ie; Ae++) {
                        let ke = Ae / ie - .5;
                        if (Se.copy(j), Se.addScaledVector(ne, ke), Se.addScaledVector(se, o), $ != null) {
                            let Ce = Math.max(0, Se.y - $);
                            Se.addScaledVector(ne, -Ce / ne.y)
                        }
                        c.push(Se.x, Se.y, Se.z), f.push(se.x, se.y, se.z), h.push(0, 0), Ae === 0 && he.push(m), m++
                    }
                }
                for (let pe = 0; pe < l; pe++)
                    for (let q = 0; q < ie; q++) {
                        let Ae = oe + q + (ie + 1) * pe,
                            ke = Ae + (ie + 1),
                            Ce = ke + 1,
                            Te = Ae + 1;
                        a.push(Ae, ke, Te), a.push(ke, Ce, Te)
                    }
                return [j.clone().addScaledVector(ne, .5), he]
            }

            function V(j, ne, F, Y) {
                let $ = Math.PI / 2,
                    re = z.angle() - $,
                    fe = [],
                    ye = new $e.Vector3,
                    Se = new $e.Vector3;
                for (let ie = 0; ie <= l; ie++) {
                    let oe = [],
                        he = ie / l;
                    for (let pe = 0; pe <= ie; pe++) {
                        let Ae = ((ie ? pe / ie : 0) - .5) * C,
                            ke = Math.cos(Ae),
                            Ce = Math.sin(Ae),
                            Te = Math.atan(Math.tan(re) * ke),
                            Fe = ($ + Te) * he,
                            nt = Math.cos(Fe),
                            De = Math.sin(Fe);
                        ye.set(0, 0, 0), ye.addScaledVector(ne, De * ke), ye.addScaledVector(F, nt), ye.addScaledVector(Y, De * Ce), Se.copy(j).addScaledVector(ye, o), c.push(Se.x, Se.y, Se.z), f.push(ye.x, ye.y, ye.z), h.push(0, 0), oe.push(m++)
                    }
                    fe.push(oe)
                }
                let se = fe.length - 1;
                for (let ie = 0; ie < se; ie++) {
                    let oe = fe[ie],
                        he = fe[ie + 1],
                        pe = oe.length - 1;
                    a.push(oe[0], he[1], he[0]);
                    for (let q = 1; q <= pe; q++) a.push(oe[q - 1], oe[q], he[q]), a.push(oe[q], he[q + 1], he[q])
                }
            }
        }
    };
    var xl = class {
        static create(n) {
            return this.build(this.normalizeInputs(n))
        }
        static normalizeInputs(n, e) {
            let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    depth: 0,
                    cornerRadius: [0, 0, 0, 0],
                    cornerType: 1,
                    extrudeDepth: 0,
                    extrudeBevelSize: 0,
                    extrudeBevelSegments: 1
                }, n.parameters),
                r = Object.assign(e?.ui ?? {
                    enabledIndieCorners: !1
                }, n.ui),
                i = t.cornerRadius.reduce((s, o) => s + o, 0);
            return {
                shape: new Ot,
                parameters: Object.assign(t, {
                    surfaceMaxCount: t.surfaceMaxCount ?? i > 0 ? 1e3 : 100,
                    width: Math.abs(t.width),
                    height: Math.abs(t.height ?? t.width)
                }),
                ui: r
            }
        }
        static build(n) {
            let e = n.shape,
                {
                    width: t,
                    height: r,
                    cornerRadius: i,
                    cornerType: s,
                    extrudeDepth: o,
                    extrudeBevelSize: l,
                    extrudeBevelSegments: a,
                    surfaceMaxCount: c
                } = n.parameters,
                f = {
                    x: t * .5,
                    y: r * .5
                },
                h = {
                    x: -f.x,
                    y: -f.y
                },
                m = {
                    x: f.x,
                    y: f.y
                };

            function v(M, L, I) {
                return L > t && I > r ? Math.min(M * t / L, M * r / I) : L > t ? M * t / L : I > r ? M * r / I : M
            }
            let g = [];
            g[0] = i[0] === 0 ? 0 : v(i[0], i[0] + i[3], i[0] + i[1]), g[1] = i[1] === 0 ? 0 : v(i[1], i[1] + i[2], i[1] + i[0]), g[2] = i[2] === 0 ? 0 : v(i[2], i[2] + i[1], i[2] + i[3]), g[3] = i[3] === 0 ? 0 : v(i[3], i[3] + i[0], i[3] + i[2]);
            let y = h.x,
                A = m.x,
                w = m.y,
                C = h.y;
            e.addPoint(e.createPoint(y, w)), e.addPoint(e.createPoint(A, w)), e.addPoint(e.createPoint(A, C)), e.addPoint(e.createPoint(y, C)), e.isClosed = !0;
            let S = !0;
            for (let M = 0, L = e.points.length; M < L; M++) e.points[M].roundness = g[M], M > 0 && g[M] !== g[M - 1] && (S = !1);
            S && (e.roundness = g[0]), e.useCubicForRoundedCorners = s !== 1, e.update();
            let E = lr.create({
                shape: e,
                parameters: {
                    surfaceMaxCount: c,
                    extrudeDepth: o,
                    extrudeBevelSize: l,
                    extrudeBevelSegments: a
                }
            });
            return Object.assign(E, {
                userData: je(Ne({}, n), {
                    type: "RectangleGeometry"
                })
            })
        }
    };
    var fh = W(J()),
        dh = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    widthSegments: 64,
                    heightSegments: 64,
                    phiStart: 0,
                    phiLength: 2 * Math.PI,
                    thetaStart: 0,
                    thetaLength: Math.PI
                }, n.parameters);
                return {
                    parameters: Object.assign(t, {
                        width: Math.abs(t.width),
                        height: Math.abs(t.height ?? t.width),
                        depth: Math.abs(t.depth ?? t.width)
                    })
                }
            }
            static build(n) {
                let {
                    width: e = 100,
                    height: t = e,
                    depth: r = e,
                    widthSegments: i = 64,
                    heightSegments: s = 64,
                    phiStart: o,
                    phiLength: l,
                    thetaStart: a,
                    thetaLength: c
                } = n.parameters, f = new fh.SphereBufferGeometry(.5 * e, i, s, o, l, a, c);
                return f.scale(1, t / e, r / e), Object.assign(f, {
                    userData: je(Ne({}, n), {
                        type: "SphereGeometry"
                    })
                })
            }
        };
    var hh = class {
        static create(n) {
            return this.build(this.normalizeInputs(n))
        }
        static normalizeInputs(n, e) {
            let t = Object.assign({}, e?.parameters ?? {
                width: 100,
                depth: 0,
                innerRadiusPercent: 38.19,
                spikes: 5,
                cornerRadius: 0,
                angle: 360,
                extrudeDepth: 0,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 1
            }, n.parameters);
            return {
                shape: new Ot,
                parameters: Object.assign(t, {
                    surfaceMaxCount: t.surfaceMaxCount ?? t.cornerRadius > 0 ? 1e3 : 100,
                    width: Math.abs(t.width),
                    height: Math.abs(t.height ?? t.width)
                })
            }
        }
        static build(n) {
            let {
                width: e,
                height: t,
                innerRadiusPercent: r,
                spikes: i,
                cornerRadius: s,
                angle: o,
                extrudeDepth: l,
                extrudeBevelSize: a,
                extrudeBevelSegments: c,
                surfaceMaxCount: f
            } = n.parameters, h = n.shape, m = e * .5, v = t * .5, g = 0, y = 0, A = o * Math.PI / 360 / i, w = Math.PI / 2 * 3 * -1, C = m * r / 100, S = v * r / 100;
            if (i == 3 && r == 50) {
                A = 2 * Math.PI / i;
                for (let M = 0; M < i; M++) {
                    let L = A * M,
                        I = g + Math.sin(L) * m,
                        z = y + Math.cos(L) * v;
                    h.addPoint(h.createPoint(I, z))
                }
            } else
                for (let M = 0; M < i; M++) {
                    let L = g + Math.cos(w) * m,
                        I = y + Math.sin(w) * v;
                    h.addPoint(h.createPoint(L, I)), w += A, L = g + Math.cos(w) * C, I = y + Math.sin(w) * S, M <= i, h.addPoint(h.createPoint(L, I)), w += A
                }
            h.isClosed = !0;
            for (let M = 0, L = h.points.length; M < L; M++) h.points[M].roundness = s;
            h.roundness = s, h.update();
            let E = lr.create({
                shape: h,
                parameters: {
                    surfaceMaxCount: f,
                    roundness: s,
                    extrudeDepth: l,
                    extrudeBevelSize: a,
                    extrudeBevelSegments: c
                }
            });
            return Object.assign(E, {
                userData: je(Ne({}, n), {
                    type: "StarGeometry"
                })
            })
        }
    };
    var mh = W(J()),
        ph = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    depth: 0
                }, n.parameters);
                return {
                    parameters: Object.assign(t, {
                        width: Math.abs(t.width),
                        height: Math.abs(t.height ?? t.width),
                        depth: Math.abs(t.depth ?? 0)
                    })
                }
            }
            static build(n) {
                let {
                    width: e,
                    height: t
                } = n.parameters, r = new mh.PlaneBufferGeometry(e, t);
                return Object.assign(r, {
                    userData: je(Ne({}, n), {
                        type: "TextFrameGeometry"
                    })
                })
            }
        };
    var gh = class {
        static create(n) {
            return this.build(this.normalizeInputs(n))
        }
        static normalizeInputs(n, e) {
            let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    radialSegments: 64,
                    tubularSegments: 64,
                    arc: Math.PI * 2,
                    cornerRadius: 30,
                    cornerSegments: 8
                }, n.parameters),
                r = Math.abs(t.width),
                i = Math.abs(t.height ?? t.width),
                s = Math.abs(t.depth ?? t.width * .25);
            return {
                parameters: Object.assign(t, {
                    width: r,
                    height: i,
                    depth: s
                })
            }
        }
        static build(n) {
            let {
                width: e,
                height: t,
                depth: r,
                radialSegments: i,
                tubularSegments: s,
                arc: o,
                cornerRadius: l,
                cornerSegments: a
            } = n.parameters, c = v0(e, t, r, e * .5, o, s, 0, 0, i, l, a);
            return c.scale(1, t / e, 1), Object.assign(c, {
                userData: je(Ne({}, n), {
                    type: "TorusGeometry"
                })
            })
        }
    };

    function v0(n, e, t, r, i, s, o, l, a, c, f) {
        return [e, t] = [t, e], o = e / 2, i /= 2 * Math.PI, i == 1 && (c = 0), new ml(!0, n, e, t, r, i, s, o, l, a, c, f)
    }
    var vh = W(J()),
        yh = class {
            static create(n) {
                return this.build(this.normalizeInputs(n))
            }
            static normalizeInputs(n, e) {
                let t = Object.assign({}, e?.parameters ?? {
                    width: 100,
                    depth: 1,
                    tube: 50,
                    tubularSegments: 64,
                    radialSegments: 32,
                    p: 2,
                    q: 3
                }, n.parameters);
                return {
                    parameters: Object.assign(t, {
                        width: Math.abs(t.width),
                        height: Math.abs(t.height ?? t.width),
                        depth: Math.abs(t.depth ?? 1)
                    })
                }
            }
            static build(n) {
                let {
                    width: e,
                    tube: t,
                    tubularSegments: r,
                    radialSegments: i,
                    p: s,
                    q: o
                } = n.parameters, l = e * .5 - t, a = new vh.TorusKnotBufferGeometry(l, t, r, i, s, o);
                return Object.assign(a, {
                    userData: je(Ne({}, n), {
                        type: "TorusKnotGeometry"
                    })
                })
            }
        };
    var xh = class {
        static create(n) {
            return this.build(this.normalizeInputs(n))
        }
        static normalizeInputs(n, e) {
            let t = Object.assign({}, e?.parameters ?? {
                width: 100,
                depth: 0,
                spikes: 5,
                cornerRadius: 0,
                extrudeDepth: 0,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 1,
                isRect: !1
            }, n.parameters);
            return {
                shape: new Ot,
                parameters: Object.assign(t, {
                    surfaceMaxCount: t.surfaceMaxCount ?? t.cornerRadius > 0 ? 1e3 : 100,
                    width: Math.abs(t.width),
                    height: Math.abs(t.height ?? t.width * (t.isRect ? 1 : Math.sqrt(3) / 2))
                })
            }
        }
        static build(n) {
            let {
                width: e = 100,
                height: t,
                cornerRadius: r,
                extrudeDepth: i,
                extrudeBevelSize: s,
                extrudeBevelSegments: o,
                isRect: l,
                surfaceMaxCount: a
            } = n.parameters, c = n.shape, f = e * .5, h = t * .5;
            l ? (c.addPoint(c.createPoint(-f, h)), c.addPoint(c.createPoint(f, -h)), c.addPoint(c.createPoint(-f, -h))) : (c.addPoint(c.createPoint(0, h)), c.addPoint(c.createPoint(f, -h)), c.addPoint(c.createPoint(-f, -h))), c.isClosed = !0;
            for (let v = 0, g = c.points.length; v < g; v++) c.points[v].roundness = r;
            c.roundness = r, c.update();
            let m = lr.create({
                shape: c,
                parameters: {
                    surfaceMaxCount: a,
                    roundness: r,
                    extrudeDepth: i,
                    extrudeBevelSize: s,
                    extrudeBevelSegments: o
                }
            });
            return Object.assign(m, {
                userData: je(Ne({}, n), {
                    type: "TriangleGeometry"
                })
            })
        }
    };
    var Lt = W(J());
    var mt = W(J()),
        Rs = class {
            static computeTangents(e) {
                e.computeTangents(), console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.")
            }
            static mergeBufferGeometries(e, t = !1) {
                let r = e[0].index !== null,
                    i = new Set(Object.keys(e[0].attributes)),
                    s = new Set(Object.keys(e[0].morphAttributes)),
                    o = {},
                    l = {},
                    a = e[0].morphTargetsRelative,
                    c = new mt.BufferGeometry,
                    f = 0;
                for (let h = 0; h < e.length; ++h) {
                    let m = e[h],
                        v = 0;
                    if (r !== (m.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
                    for (let g in m.attributes) {
                        if (!i.has(g)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + g + '" attribute exists among all geometries, or in none of them.'), null;
                        o[g] === void 0 && (o[g] = []), o[g].push(m.attributes[g]), v++
                    }
                    if (v !== i.size) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."), null;
                    if (a !== m.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
                    for (let g in m.morphAttributes) {
                        if (!s.has(g)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."), null;
                        l[g] === void 0 && (l[g] = []), l[g].push(m.morphAttributes[g])
                    }
                    if (c.userData.mergedUserData = c.userData.mergedUserData || [], c.userData.mergedUserData.push(m.userData), t) {
                        let g;
                        if (r) g = m.index.count;
                        else if (m.attributes.position !== void 0) g = m.attributes.position.count;
                        else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"), null;
                        c.addGroup(f, g, h), f += g
                    }
                }
                if (r) {
                    let h = 0,
                        m = [];
                    for (let v = 0; v < e.length; ++v) {
                        let g = e[v].index;
                        for (let y = 0; y < g.count; ++y) m.push(g.getX(y) + h);
                        h += e[v].attributes.position.count
                    }
                    c.setIndex(m)
                }
                for (let h in o) {
                    let m = this.mergeBufferAttributes(o[h]);
                    if (!m) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + h + " attribute."), null;
                    c.setAttribute(h, m)
                }
                for (let h in l) {
                    let m = l[h][0].length;
                    if (m === 0) break;
                    c.morphAttributes = c.morphAttributes || {}, c.morphAttributes[h] = [];
                    for (let v = 0; v < m; ++v) {
                        let g = [];
                        for (let A = 0; A < l[h].length; ++A) g.push(l[h][A][v]);
                        let y = this.mergeBufferAttributes(g);
                        if (!y) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + h + " morphAttribute."), null;
                        c.morphAttributes[h].push(y)
                    }
                }
                return c
            }
            static mergeBufferAttributes(e) {
                let t, r, i, s = 0;
                for (let a = 0; a < e.length; ++a) {
                    let c = e[a];
                    if (c.isInterleavedBufferAttribute) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."), null;
                    if (t === void 0 && (t = c.array.constructor), t !== c.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
                    if (r === void 0 && (r = c.itemSize), r !== c.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
                    if (i === void 0 && (i = c.normalized), i !== c.normalized) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
                    s += c.array.length
                }
                let o = new t(s),
                    l = 0;
                for (let a = 0; a < e.length; ++a) o.set(e[a].array, l), l += e[a].array.length;
                return new mt.BufferAttribute(o, r, i)
            }
            static interleaveAttributes(e) {
                let t, r = 0,
                    i = 0;
                for (let f = 0, h = e.length; f < h; ++f) {
                    let m = e[f];
                    if (t === void 0 && (t = m.array.constructor), t !== m.array.constructor) return console.error("AttributeBuffers of different types cannot be interleaved"), null;
                    r += m.array.length, i += m.itemSize
                }
                let s = new mt.InterleavedBuffer(new t(r), i),
                    o = 0,
                    l = [],
                    a = ["getX", "getY", "getZ", "getW"],
                    c = ["setX", "setY", "setZ", "setW"];
                for (let f = 0, h = e.length; f < h; f++) {
                    let m = e[f],
                        v = m.itemSize,
                        g = m.count,
                        y = new mt.InterleavedBufferAttribute(s, v, o, m.normalized);
                    l.push(y), o += v;
                    for (let A = 0; A < g; A++)
                        for (let w = 0; w < v; w++) y[c[w]](A, m[a[w]](A))
                }
                return l
            }
            static estimateBytesUsed(e) {
                let t = 0;
                for (let i in e.attributes) {
                    let s = e.getAttribute(i);
                    t += s.count * s.itemSize * s.array.BYTES_PER_ELEMENT
                }
                let r = e.getIndex();
                return t += r ? r.count * r.itemSize * r.array.BYTES_PER_ELEMENT : 0, t
            }
            static mergeVertices(e, t = 1e-4) {
                t = Math.max(t, Number.EPSILON);
                let r = {},
                    i = e.getIndex(),
                    s = e.getAttribute("position"),
                    o = i ? i.count : s.count,
                    l = 0,
                    a = Object.keys(e.attributes),
                    c = {},
                    f = {},
                    h = [],
                    m = ["getX", "getY", "getZ", "getW"];
                for (let A = 0, w = a.length; A < w; A++) {
                    let C = a[A];
                    c[C] = [];
                    let S = e.morphAttributes[C];
                    S && (f[C] = new Array(S.length).fill().map(() => []))
                }
                let v = Math.log10(1 / t),
                    g = Math.pow(10, v);
                for (let A = 0; A < o; A++) {
                    let w = i ? i.getX(A) : A,
                        C = "";
                    for (let S = 0, E = a.length; S < E; S++) {
                        let M = a[S],
                            L = e.getAttribute(M),
                            I = L.itemSize;
                        for (let z = 0; z < I; z++) C += `${~~(L[m[z]](w)*g)},`
                    }
                    if (C in r) h.push(r[C]);
                    else {
                        for (let S = 0, E = a.length; S < E; S++) {
                            let M = a[S],
                                L = e.getAttribute(M),
                                I = e.morphAttributes[M],
                                z = L.itemSize,
                                O = c[M],
                                X = f[M];
                            for (let k = 0; k < z; k++) {
                                let Q = m[k];
                                if (O.push(L[Q](w)), I)
                                    for (let te = 0, Z = I.length; te < Z; te++) X[te].push(I[te][Q](w))
                            }
                        }
                        r[C] = l, h.push(l), l++
                    }
                }
                let y = e.clone();
                for (let A = 0, w = a.length; A < w; A++) {
                    let C = a[A],
                        S = e.getAttribute(C),
                        E = new S.array.constructor(c[C]),
                        M = new mt.BufferAttribute(E, S.itemSize, S.normalized);
                    if (y.setAttribute(C, M), C in f)
                        for (let L = 0; L < f[C].length; L++) {
                            let I = e.morphAttributes[C][L],
                                z = new I.array.constructor(f[C][L]),
                                O = new mt.BufferAttribute(z, I.itemSize, I.normalized);
                            y.morphAttributes[C][L] = O
                        }
                }
                return y.setIndex(h), y
            }
            static toTrianglesDrawMode(e, t) {
                if (t === mt.TrianglesDrawMode) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e;
                if (t === mt.TriangleFanDrawMode || t === mt.TriangleStripDrawMode) {
                    let r = e.getIndex();
                    if (r === null) {
                        let l = [],
                            a = e.getAttribute("position");
                        if (a !== void 0) {
                            for (let c = 0; c < a.count; c++) l.push(c);
                            e.setIndex(l), r = e.getIndex()
                        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e
                    }
                    let i = r.count - 2,
                        s = [];
                    if (t === mt.TriangleFanDrawMode)
                        for (let l = 1; l <= i; l++) s.push(r.getX(0)), s.push(r.getX(l)), s.push(r.getX(l + 1));
                    else
                        for (let l = 0; l < i; l++) l % 2 == 0 ? (s.push(r.getX(l)), s.push(r.getX(l + 1)), s.push(r.getX(l + 2))) : (s.push(r.getX(l + 2)), s.push(r.getX(l + 1)), s.push(r.getX(l)));
                    s.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                    let o = e.clone();
                    return o.setIndex(s), o.clearGroups(), o
                } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e
            }
            static computeMorphedAttributes(e) {
                if (e.geometry.isBufferGeometry !== !0) return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."), null;
                let t = new mt.Vector3,
                    r = new mt.Vector3,
                    i = new mt.Vector3,
                    s = new mt.Vector3,
                    o = new mt.Vector3,
                    l = new mt.Vector3,
                    a = new mt.Vector3,
                    c = new mt.Vector3,
                    f = new mt.Vector3;

                function h(ne, F, Y, $, re, fe, ye, Se, se) {
                    t.fromBufferAttribute(Y, fe), r.fromBufferAttribute(Y, ye), i.fromBufferAttribute(Y, Se);
                    let ie = ne.morphTargetInfluences;
                    if (F.morphTargets && $ && ie) {
                        a.set(0, 0, 0), c.set(0, 0, 0), f.set(0, 0, 0);
                        for (let oe = 0, he = $.length; oe < he; oe++) {
                            let pe = ie[oe],
                                q = $[oe];
                            pe !== 0 && (s.fromBufferAttribute(q, fe), o.fromBufferAttribute(q, ye), l.fromBufferAttribute(q, Se), re ? (a.addScaledVector(s, pe), c.addScaledVector(o, pe), f.addScaledVector(l, pe)) : (a.addScaledVector(s.sub(t), pe), c.addScaledVector(o.sub(r), pe), f.addScaledVector(l.sub(i), pe)))
                        }
                        t.add(a), r.add(c), i.add(f)
                    }
                    ne.isSkinnedMesh && (ne.boneTransform(fe, t), ne.boneTransform(ye, r), ne.boneTransform(Se, i)), se[fe * 3 + 0] = t.x, se[fe * 3 + 1] = t.y, se[fe * 3 + 2] = t.z, se[ye * 3 + 0] = r.x, se[ye * 3 + 1] = r.y, se[ye * 3 + 2] = r.z, se[Se * 3 + 0] = i.x, se[Se * 3 + 1] = i.y, se[Se * 3 + 2] = i.z
                }
                let m = e.geometry,
                    v = e.material,
                    g, y, A, w = m.index,
                    C = m.attributes.position,
                    S = m.morphAttributes.position,
                    E = m.morphTargetsRelative,
                    M = m.attributes.normal,
                    L = m.morphAttributes.position,
                    I = m.groups,
                    z = m.drawRange,
                    O, X, k, Q, te, Z, le, B, U = new Float32Array(C.count * C.itemSize),
                    G = new Float32Array(M.count * M.itemSize);
                if (w !== null)
                    if (Array.isArray(v))
                        for (O = 0, k = I.length; O < k; O++)
                            for (te = I[O], Z = v[te.materialIndex], le = Math.max(te.start, z.start), B = Math.min(te.start + te.count, z.start + z.count), X = le, Q = B; X < Q; X += 3) g = w.getX(X), y = w.getX(X + 1), A = w.getX(X + 2), h(e, Z, C, S, E, g, y, A, U), h(e, Z, M, L, E, g, y, A, G);
                    else
                        for (le = Math.max(0, z.start), B = Math.min(w.count, z.start + z.count), O = le, k = B; O < k; O += 3) g = w.getX(O), y = w.getX(O + 1), A = w.getX(O + 2), h(e, v, C, S, E, g, y, A, U), h(e, v, M, L, E, g, y, A, G);
                else if (C !== void 0)
                    if (Array.isArray(v))
                        for (O = 0, k = I.length; O < k; O++)
                            for (te = I[O], Z = v[te.materialIndex], le = Math.max(te.start, z.start), B = Math.min(te.start + te.count, z.start + z.count), X = le, Q = B; X < Q; X += 3) g = X, y = X + 1, A = X + 2, h(e, Z, C, S, E, g, y, A, U), h(e, Z, M, L, E, g, y, A, G);
                    else
                        for (le = Math.max(0, z.start), B = Math.min(C.count, z.start + z.count), O = le, k = B; O < k; O += 3) g = O, y = O + 1, A = O + 2, h(e, v, C, S, E, g, y, A, U), h(e, v, M, L, E, g, y, A, G);
                let V = new mt.Float32BufferAttribute(U, 3),
                    j = new mt.Float32BufferAttribute(G, 3);
                return {
                    positionAttribute: C,
                    normalAttribute: M,
                    morphedPositionAttribute: V,
                    morphedNormalAttribute: j
                }
            }
        };
    var y0 = function() {
            var n = typeof document != "undefined" && document.currentScript ? document.currentScript.src : void 0;
            return function(e) {
                e = e || {};
                var e = typeof e != "undefined" ? e : {},
                    t, r;
                e.ready = new Promise(function(u, d) {
                    t = u, r = d
                });
                var i = {},
                    s;
                for (s in e) e.hasOwnProperty(s) && (i[s] = e[s]);
                var o = [],
                    l = "./this.program",
                    a = function(u, d) {
                        throw d
                    },
                    c = !0,
                    f = !1,
                    h = "";

                function m(u) {
                    return e.locateFile ? e.locateFile(u, h) : h + u
                }
                var v, g, y, A;
                (c || f) && (f ? h = self.location.href : typeof document != "undefined" && document.currentScript && (h = document.currentScript.src), n && (h = n), h.indexOf("blob:") !== 0 ? h = h.substr(0, h.lastIndexOf("/") + 1) : h = "", v = function(u) {
                    var d = new XMLHttpRequest;
                    return d.open("GET", u, !1), d.send(null), d.responseText
                }, f && (y = function(u) {
                    var d = new XMLHttpRequest;
                    return d.open("GET", u, !1), d.responseType = "arraybuffer", d.send(null), new Uint8Array(d.response)
                }), g = function(u, d, p) {
                    var x = new XMLHttpRequest;
                    x.open("GET", u, !0), x.responseType = "arraybuffer", x.onload = function() {
                        if (x.status == 200 || x.status == 0 && x.response) {
                            d(x.response);
                            return
                        }
                        p()
                    }, x.onerror = p, x.send(null)
                }, A = function(u) {
                    document.title = u
                });
                var w = e.print || console.log.bind(console),
                    C = e.printErr || console.warn.bind(console);
                for (s in i) i.hasOwnProperty(s) && (e[s] = i[s]);
                i = null, e.arguments && (o = e.arguments), e.thisProgram && (l = e.thisProgram), e.quit && (a = e.quit);
                var S = 0,
                    E = function(u) {
                        S = u
                    },
                    M;
                e.wasmBinary && (M = e.wasmBinary);
                var L = e.noExitRuntime || !0;
                typeof WebAssembly != "object" && hr("no native wasm support detected");
                var I, z = !1,
                    O;

                function X(u, d) {
                    u || hr("Assertion failed: " + d)
                }

                function k(u) {
                    var d = e["_" + u];
                    return X(d, "Cannot call unknown function " + u + ", make sure it is exported"), d
                }

                function Q(u, d, p, x, N) {
                    var T = {
                        string: function(ge) {
                            var ze = 0;
                            if (ge != null && ge !== 0) {
                                var Ke = (ge.length << 2) + 1;
                                ze = Gc(Ke), U(ge, ze, Ke)
                            }
                            return ze
                        },
                        array: function(ge) {
                            var ze = Gc(ge.length);
                            return fe(ge, ze), ze
                        }
                    };

                    function _(ge) {
                        return d === "string" ? le(ge) : d === "boolean" ? Boolean(ge) : ge
                    }
                    var D = k(u),
                        R = [],
                        K = 0;
                    if (x)
                        for (var ee = 0; ee < x.length; ee++) {
                            var ue = T[p[ee]];
                            ue ? (K === 0 && (K = id()), R[ee] = ue(x[ee])) : R[ee] = x[ee]
                        }
                    var ce = D.apply(null, R);

                    function de(ge) {
                        return K !== 0 && nd(K), _(ge)
                    }
                    return ce = de(ce), ce
                }
                var te = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;

                function Z(u, d, p) {
                    for (var x = d + p, N = d; u[N] && !(N >= x);) ++N;
                    if (N - d > 16 && u.subarray && te) return te.decode(u.subarray(d, N));
                    for (var T = ""; d < N;) {
                        var _ = u[d++];
                        if (!(_ & 128)) {
                            T += String.fromCharCode(_);
                            continue
                        }
                        var D = u[d++] & 63;
                        if ((_ & 224) == 192) {
                            T += String.fromCharCode((_ & 31) << 6 | D);
                            continue
                        }
                        var R = u[d++] & 63;
                        if ((_ & 240) == 224 ? _ = (_ & 15) << 12 | D << 6 | R : _ = (_ & 7) << 18 | D << 12 | R << 6 | u[d++] & 63, _ < 65536) T += String.fromCharCode(_);
                        else {
                            var K = _ - 65536;
                            T += String.fromCharCode(55296 | K >> 10, 56320 | K & 1023)
                        }
                    }
                    return T
                }

                function le(u, d) {
                    return u ? Z(oe, u, d) : ""
                }

                function B(u, d, p, x) {
                    if (!(x > 0)) return 0;
                    for (var N = p, T = p + x - 1, _ = 0; _ < u.length; ++_) {
                        var D = u.charCodeAt(_);
                        if (D >= 55296 && D <= 57343) {
                            var R = u.charCodeAt(++_);
                            D = 65536 + ((D & 1023) << 10) | R & 1023
                        }
                        if (D <= 127) {
                            if (p >= T) break;
                            d[p++] = D
                        } else if (D <= 2047) {
                            if (p + 1 >= T) break;
                            d[p++] = 192 | D >> 6, d[p++] = 128 | D & 63
                        } else if (D <= 65535) {
                            if (p + 2 >= T) break;
                            d[p++] = 224 | D >> 12, d[p++] = 128 | D >> 6 & 63, d[p++] = 128 | D & 63
                        } else {
                            if (p + 3 >= T) break;
                            d[p++] = 240 | D >> 18, d[p++] = 128 | D >> 12 & 63, d[p++] = 128 | D >> 6 & 63, d[p++] = 128 | D & 63
                        }
                    }
                    return d[p] = 0, p - N
                }

                function U(u, d, p) {
                    return B(u, oe, d, p)
                }

                function G(u) {
                    for (var d = 0, p = 0; p < u.length; ++p) {
                        var x = u.charCodeAt(p);
                        x >= 55296 && x <= 57343 && (x = 65536 + ((x & 1023) << 10) | u.charCodeAt(++p) & 1023), x <= 127 ? ++d : x <= 2047 ? d += 2 : x <= 65535 ? d += 3 : d += 4
                    }
                    return d
                }
                var V = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;

                function j(u, d) {
                    for (var p = u, x = p >> 1, N = x + d / 2; !(x >= N) && pe[x];) ++x;
                    if (p = x << 1, p - u > 32 && V) return V.decode(oe.subarray(u, p));
                    for (var T = "", _ = 0; !(_ >= d / 2); ++_) {
                        var D = he[u + _ * 2 >> 1];
                        if (D == 0) break;
                        T += String.fromCharCode(D)
                    }
                    return T
                }

                function ne(u, d, p) {
                    if (p === void 0 && (p = 2147483647), p < 2) return 0;
                    p -= 2;
                    for (var x = d, N = p < u.length * 2 ? p / 2 : u.length, T = 0; T < N; ++T) {
                        var _ = u.charCodeAt(T);
                        he[d >> 1] = _, d += 2
                    }
                    return he[d >> 1] = 0, d - x
                }

                function F(u) {
                    return u.length * 2
                }

                function Y(u, d) {
                    for (var p = 0, x = ""; !(p >= d / 4);) {
                        var N = q[u + p * 4 >> 2];
                        if (N == 0) break;
                        if (++p, N >= 65536) {
                            var T = N - 65536;
                            x += String.fromCharCode(55296 | T >> 10, 56320 | T & 1023)
                        } else x += String.fromCharCode(N)
                    }
                    return x
                }

                function $(u, d, p) {
                    if (p === void 0 && (p = 2147483647), p < 4) return 0;
                    for (var x = d, N = x + p - 4, T = 0; T < u.length; ++T) {
                        var _ = u.charCodeAt(T);
                        if (_ >= 55296 && _ <= 57343) {
                            var D = u.charCodeAt(++T);
                            _ = 65536 + ((_ & 1023) << 10) | D & 1023
                        }
                        if (q[d >> 2] = _, d += 4, d + 4 > N) break
                    }
                    return q[d >> 2] = 0, d - x
                }

                function re(u) {
                    for (var d = 0, p = 0; p < u.length; ++p) {
                        var x = u.charCodeAt(p);
                        x >= 55296 && x <= 57343 && ++p, d += 4
                    }
                    return d
                }

                function fe(u, d) {
                    ie.set(u, d)
                }

                function ye(u, d, p) {
                    for (var x = 0; x < u.length; ++x) ie[d++ >> 0] = u.charCodeAt(x);
                    p || (ie[d >> 0] = 0)
                }

                function Se(u, d) {
                    return u % d > 0 && (u += d - u % d), u
                }
                var se, ie, oe, he, pe, q, Ae, ke, Ce;

                function Te(u) {
                    se = u, e.HEAP8 = ie = new Int8Array(u), e.HEAP16 = he = new Int16Array(u), e.HEAP32 = q = new Int32Array(u), e.HEAPU8 = oe = new Uint8Array(u), e.HEAPU16 = pe = new Uint16Array(u), e.HEAPU32 = Ae = new Uint32Array(u), e.HEAPF32 = ke = new Float32Array(u), e.HEAPF64 = Ce = new Float64Array(u)
                }
                var Fe = e.INITIAL_MEMORY || 16777216,
                    nt, De = [],
                    bt = [],
                    Mt = [],
                    xt = !1;

                function tr() {
                    if (e.preRun)
                        for (typeof e.preRun == "function" && (e.preRun = [e.preRun]); e.preRun.length;) zt(e.preRun.shift());
                    vi(De)
                }

                function rr() {
                    xt = !0, !e.noFSInit && !b.init.initialized && b.init(), b.ignorePermissions = !1, rn.init(), vi(bt)
                }

                function dr() {
                    if (e.postRun)
                        for (typeof e.postRun == "function" && (e.postRun = [e.postRun]); e.postRun.length;) is(e.postRun.shift());
                    vi(Mt)
                }

                function zt(u) {
                    De.unshift(u)
                }

                function gi(u) {
                    bt.unshift(u)
                }

                function is(u) {
                    Mt.unshift(u)
                }
                var Kr = 0,
                    wn = null,
                    en = null;

                function ho(u) {
                    return u
                }

                function ns(u) {
                    Kr++, e.monitorRunDependencies && e.monitorRunDependencies(Kr)
                }

                function Sn(u) {
                    if (Kr--, e.monitorRunDependencies && e.monitorRunDependencies(Kr), Kr == 0 && (wn !== null && (clearInterval(wn), wn = null), en)) {
                        var d = en;
                        en = null, d()
                    }
                }
                e.preloadedImages = {}, e.preloadedAudios = {};

                function hr(u) {
                    e.onAbort && e.onAbort(u), u += "", C(u), z = !0, O = 1, u = "abort(" + u + "). Build with -s ASSERTIONS=1 for more info.";
                    var d = new WebAssembly.RuntimeError(u);
                    throw r(d), d
                }
                var Oa = "data:application/octet-stream;base64,";

                function mo(u) {
                    return u.startsWith(Oa)
                }
                var mr;
                mr = "process.wasm", mo(mr) || (mr = m(mr));

                function P(u) {
                    try {
                        if (u == mr && M) return new Uint8Array(M);
                        if (y) return y(u);
                        throw "both async and sync fetching of the wasm failed"
                    } catch (d) {
                        hr(d)
                    }
                }

                function Je() {
                    return !M && (c || f) && typeof fetch == "function" ? fetch(mr, {
                        credentials: "same-origin"
                    }).then(function(u) {
                        if (!u.ok) throw "failed to load wasm binary file at '" + mr + "'";
                        return u.arrayBuffer()
                    }).catch(function() {
                        return P(mr)
                    }) : Promise.resolve().then(function() {
                        return P(mr)
                    })
                }

                function wt() {
                    var u = {
                        a: wx
                    };

                    function d(_, D) {
                        var R = _.exports;
                        e.asm = R, I = e.asm.M, Te(I.buffer), nt = e.asm.O, gi(e.asm.N), Sn("wasm-instantiate")
                    }
                    ns("wasm-instantiate");

                    function p(_) {
                        d(_.instance)
                    }

                    function x(_) {
                        return Je().then(function(D) {
                            return WebAssembly.instantiate(D, u)
                        }).then(function(D) {
                            return D
                        }).then(_, function(D) {
                            C("failed to asynchronously prepare wasm: " + D), hr(D)
                        })
                    }

                    function N() {
                        return !M && typeof WebAssembly.instantiateStreaming == "function" && !mo(mr) && typeof fetch == "function" ? fetch(mr, {
                            credentials: "same-origin"
                        }).then(function(_) {
                            var D = WebAssembly.instantiateStreaming(_, u);
                            return D.then(p, function(R) {
                                return C("wasm streaming compile failed: " + R), C("falling back to ArrayBuffer instantiation"), x(p)
                            })
                        }) : x(p)
                    }
                    if (e.instantiateWasm) try {
                        var T = e.instantiateWasm(u, d);
                        return T
                    } catch (_) {
                        return C("Module.instantiateWasm callback failed with error: " + _), !1
                    }
                    return N().catch(r), {}
                }
                var tt, Zt;

                function vi(u) {
                    for (; u.length > 0;) {
                        var d = u.shift();
                        if (typeof d == "function") {
                            d(e);
                            continue
                        }
                        var p = d.func;
                        typeof p == "number" ? d.arg === void 0 ? nt.get(p)() : nt.get(p)(d.arg) : p(d.arg === void 0 ? null : d.arg)
                    }
                }

                function ss(u) {
                    return $a(u + 16) + 16
                }

                function Ra(u) {
                    this.excPtr = u, this.ptr = u - 16, this.set_type = function(d) {
                        q[this.ptr + 4 >> 2] = d
                    }, this.get_type = function() {
                        return q[this.ptr + 4 >> 2]
                    }, this.set_destructor = function(d) {
                        q[this.ptr + 8 >> 2] = d
                    }, this.get_destructor = function() {
                        return q[this.ptr + 8 >> 2]
                    }, this.set_refcount = function(d) {
                        q[this.ptr >> 2] = d
                    }, this.set_caught = function(d) {
                        d = d ? 1 : 0, ie[this.ptr + 12 >> 0] = d
                    }, this.get_caught = function() {
                        return ie[this.ptr + 12 >> 0] != 0
                    }, this.set_rethrown = function(d) {
                        d = d ? 1 : 0, ie[this.ptr + 13 >> 0] = d
                    }, this.get_rethrown = function() {
                        return ie[this.ptr + 13 >> 0] != 0
                    }, this.init = function(d, p) {
                        this.set_type(d), this.set_destructor(p), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1)
                    }, this.add_ref = function() {
                        var d = q[this.ptr >> 2];
                        q[this.ptr >> 2] = d + 1
                    }, this.release_ref = function() {
                        var d = q[this.ptr >> 2];
                        return q[this.ptr >> 2] = d - 1, d === 1
                    }
                }
                var Xr = 0,
                    qr = 0;

                function Zv(u, d, p) {
                    var x = new Ra(u);
                    throw x.init(d, p), Xr = u, qr++, u
                }
                var Fa = {};

                function Ga(u) {
                    for (; u.length;) {
                        var d = u.pop(),
                            p = u.pop();
                        p(d)
                    }
                }

                function os(u) {
                    return this.fromWireType(Ae[u >> 2])
                }
                var as = {},
                    Nn = {},
                    za = {},
                    $v = 48,
                    ey = 57;

                function Tc(u) {
                    if (u === void 0) return "_unknown";
                    u = u.replace(/[^a-zA-Z0-9_]/g, "$");
                    var d = u.charCodeAt(0);
                    return d >= $v && d <= ey ? "_" + u : u
                }

                function ka(u, d) {
                    return u = Tc(u), new Function("body", "return function " + u + `() {
    "use strict";    return body.apply(this, arguments);
};
`)(d)
                }

                function Ec(u, d) {
                    var p = ka(d, function(x) {
                        this.name = d, this.message = x;
                        var N = new Error(x).stack;
                        N !== void 0 && (this.stack = this.toString() + `
` + N.replace(/^Error(:[^\n]*)?\n/, ""))
                    });
                    return p.prototype = Object.create(u.prototype), p.prototype.constructor = p, p.prototype.toString = function() {
                        return this.message === void 0 ? this.name : this.name + ": " + this.message
                    }, p
                }
                var jf = void 0;

                function Ua(u) {
                    throw new jf(u)
                }

                function yi(u, d, p) {
                    u.forEach(function(D) {
                        za[D] = d
                    });

                    function x(D) {
                        var R = p(D);
                        R.length !== u.length && Ua("Mismatched type converter count");
                        for (var K = 0; K < u.length; ++K) xi(u[K], R[K])
                    }
                    var N = new Array(d.length),
                        T = [],
                        _ = 0;
                    d.forEach(function(D, R) {
                        Nn.hasOwnProperty(D) ? N[R] = Nn[D] : (T.push(D), as.hasOwnProperty(D) || (as[D] = []), as[D].push(function() {
                            N[R] = Nn[D], ++_, _ === T.length && x(N)
                        }))
                    }), T.length === 0 && x(N)
                }

                function ty(u) {
                    var d = Fa[u];
                    delete Fa[u];
                    var p = d.elements,
                        x = p.length,
                        N = p.map(function(D) {
                            return D.getterReturnType
                        }).concat(p.map(function(D) {
                            return D.setterArgumentType
                        })),
                        T = d.rawConstructor,
                        _ = d.rawDestructor;
                    yi([u], N, function(D) {
                        return p.forEach(function(R, K) {
                            var ee = D[K],
                                ue = R.getter,
                                ce = R.getterContext,
                                de = D[K + x],
                                ge = R.setter,
                                ze = R.setterContext;
                            R.read = function(Ke) {
                                return ee.fromWireType(ue(ce, Ke))
                            }, R.write = function(Ke, st) {
                                var ae = [];
                                ge(ze, Ke, de.toWireType(ae, st)), Ga(ae)
                            }
                        }), [{
                            name: d.name,
                            fromWireType: function(R) {
                                for (var K = new Array(x), ee = 0; ee < x; ++ee) K[ee] = p[ee].read(R);
                                return _(R), K
                            },
                            toWireType: function(R, K) {
                                if (x !== K.length) throw new TypeError("Incorrect number of tuple elements for " + d.name + ": expected=" + x + ", actual=" + K.length);
                                for (var ee = T(), ue = 0; ue < x; ++ue) p[ue].write(ee, K[ue]);
                                return R !== null && R.push(_, ee), ee
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: os,
                            destructorFunction: _
                        }]
                    })
                }
                var ja = {};

                function ry(u) {
                    var d = ja[u];
                    delete ja[u];
                    var p = d.rawConstructor,
                        x = d.rawDestructor,
                        N = d.fields,
                        T = N.map(function(_) {
                            return _.getterReturnType
                        }).concat(N.map(function(_) {
                            return _.setterArgumentType
                        }));
                    yi([u], T, function(_) {
                        var D = {};
                        return N.forEach(function(R, K) {
                            var ee = R.fieldName,
                                ue = _[K],
                                ce = R.getter,
                                de = R.getterContext,
                                ge = _[K + N.length],
                                ze = R.setter,
                                Ke = R.setterContext;
                            D[ee] = {
                                read: function(st) {
                                    return ue.fromWireType(ce(de, st))
                                },
                                write: function(st, ae) {
                                    var me = [];
                                    ze(Ke, st, ge.toWireType(me, ae)), Ga(me)
                                }
                            }
                        }), [{
                            name: d.name,
                            fromWireType: function(R) {
                                var K = {};
                                for (var ee in D) K[ee] = D[ee].read(R);
                                return x(R), K
                            },
                            toWireType: function(R, K) {
                                for (var ee in D)
                                    if (!(ee in K)) throw new TypeError('Missing field:  "' + ee + '"');
                                var ue = p();
                                for (ee in D) D[ee].write(ue, K[ee]);
                                return R !== null && R.push(x, ue), ue
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: os,
                            destructorFunction: x
                        }]
                    })
                }

                function iy(u, d, p, x, N) {}

                function Va(u) {
                    switch (u) {
                        case 1:
                            return 0;
                        case 2:
                            return 1;
                        case 4:
                            return 2;
                        case 8:
                            return 3;
                        default:
                            throw new TypeError("Unknown type size: " + u)
                    }
                }

                function ny() {
                    for (var u = new Array(256), d = 0; d < 256; ++d) u[d] = String.fromCharCode(d);
                    Vf = u
                }
                var Vf = void 0;

                function kt(u) {
                    for (var d = "", p = u; oe[p];) d += Vf[oe[p++]];
                    return d
                }
                var ls = void 0;

                function rt(u) {
                    throw new ls(u)
                }

                function xi(u, d, p) {
                    if (p = p || {}, !("argPackAdvance" in d)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
                    var x = d.name;
                    if (u || rt('type "' + x + '" must have a positive integer typeid pointer'), Nn.hasOwnProperty(u)) {
                        if (p.ignoreDuplicateRegistrations) return;
                        rt("Cannot register type '" + x + "' twice")
                    }
                    if (Nn[u] = d, delete za[u], as.hasOwnProperty(u)) {
                        var N = as[u];
                        delete as[u], N.forEach(function(T) {
                            T()
                        })
                    }
                }

                function sy(u, d, p, x, N) {
                    var T = Va(p);
                    d = kt(d), xi(u, {
                        name: d,
                        fromWireType: function(_) {
                            return !!_
                        },
                        toWireType: function(_, D) {
                            return D ? x : N
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: function(_) {
                            var D;
                            if (p === 1) D = ie;
                            else if (p === 2) D = he;
                            else if (p === 4) D = q;
                            else throw new TypeError("Unknown boolean type size: " + d);
                            return this.fromWireType(D[_ >> T])
                        },
                        destructorFunction: null
                    })
                }

                function oy(u) {
                    if (!(this instanceof tn) || !(u instanceof tn)) return !1;
                    for (var d = this.$$.ptrType.registeredClass, p = this.$$.ptr, x = u.$$.ptrType.registeredClass, N = u.$$.ptr; d.baseClass;) p = d.upcast(p), d = d.baseClass;
                    for (; x.baseClass;) N = x.upcast(N), x = x.baseClass;
                    return d === x && p === N
                }

                function ay(u) {
                    return {
                        count: u.count,
                        deleteScheduled: u.deleteScheduled,
                        preservePointerOnDelete: u.preservePointerOnDelete,
                        ptr: u.ptr,
                        ptrType: u.ptrType,
                        smartPtr: u.smartPtr,
                        smartPtrType: u.smartPtrType
                    }
                }

                function Mc(u) {
                    function d(p) {
                        return p.$$.ptrType.registeredClass.name
                    }
                    rt(d(u) + " instance already deleted")
                }
                var _c = !1;

                function Hf(u) {}

                function ly(u) {
                    u.smartPtr ? u.smartPtrType.rawDestructor(u.smartPtr) : u.ptrType.registeredClass.rawDestructor(u.ptr)
                }

                function Wf(u) {
                    u.count.value -= 1;
                    var d = u.count.value === 0;
                    d && ly(u)
                }

                function po(u) {
                    return typeof FinalizationGroup == "undefined" ? (po = function(d) {
                        return d
                    }, u) : (_c = new FinalizationGroup(function(d) {
                        for (var p = d.next(); !p.done; p = d.next()) {
                            var x = p.value;
                            x.ptr ? Wf(x) : console.warn("object already deleted: " + x.ptr)
                        }
                    }), po = function(d) {
                        return _c.register(d, d.$$, d.$$), d
                    }, Hf = function(d) {
                        _c.unregister(d.$$)
                    }, po(u))
                }

                function cy() {
                    if (this.$$.ptr || Mc(this), this.$$.preservePointerOnDelete) return this.$$.count.value += 1, this;
                    var u = po(Object.create(Object.getPrototypeOf(this), {
                        $$: {
                            value: ay(this.$$)
                        }
                    }));
                    return u.$$.count.value += 1, u.$$.deleteScheduled = !1, u
                }

                function uy() {
                    this.$$.ptr || Mc(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && rt("Object already scheduled for deletion"), Hf(this), Wf(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0)
                }

                function fy() {
                    return !this.$$.ptr
                }
                var go = void 0,
                    vo = [];

                function Ic() {
                    for (; vo.length;) {
                        var u = vo.pop();
                        u.$$.deleteScheduled = !1, u.delete()
                    }
                }

                function dy() {
                    return this.$$.ptr || Mc(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && rt("Object already scheduled for deletion"), vo.push(this), vo.length === 1 && go && go(Ic), this.$$.deleteScheduled = !0, this
                }

                function hy() {
                    tn.prototype.isAliasOf = oy, tn.prototype.clone = cy, tn.prototype.delete = uy, tn.prototype.isDeleted = fy, tn.prototype.deleteLater = dy
                }

                function tn() {}
                var Jf = {};

                function Qf(u, d, p) {
                    if (u[d].overloadTable === void 0) {
                        var x = u[d];
                        u[d] = function() {
                            return u[d].overloadTable.hasOwnProperty(arguments.length) || rt("Function '" + p + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + u[d].overloadTable + ")!"), u[d].overloadTable[arguments.length].apply(this, arguments)
                        }, u[d].overloadTable = [], u[d].overloadTable[x.argCount] = x
                    }
                }

                function Lc(u, d, p) {
                    e.hasOwnProperty(u) ? ((p === void 0 || e[u].overloadTable !== void 0 && e[u].overloadTable[p] !== void 0) && rt("Cannot register public name '" + u + "' twice"), Qf(e, u, u), e.hasOwnProperty(p) && rt("Cannot register multiple overloads of a function with the same number of arguments (" + p + ")!"), e[u].overloadTable[p] = d) : (e[u] = d, p !== void 0 && (e[u].numArguments = p))
                }

                function my(u, d, p, x, N, T, _, D) {
                    this.name = u, this.constructor = d, this.instancePrototype = p, this.rawDestructor = x, this.baseClass = N, this.getActualType = T, this.upcast = _, this.downcast = D, this.pureVirtualFunctions = []
                }

                function Ha(u, d, p) {
                    for (; d !== p;) d.upcast || rt("Expected null or instance of " + p.name + ", got an instance of " + d.name), u = d.upcast(u), d = d.baseClass;
                    return u
                }

                function py(u, d) {
                    if (d === null) return this.isReference && rt("null is not a valid " + this.name), 0;
                    d.$$ || rt('Cannot pass "' + us(d) + '" as a ' + this.name), d.$$.ptr || rt("Cannot pass deleted object as a pointer of type " + this.name);
                    var p = d.$$.ptrType.registeredClass,
                        x = Ha(d.$$.ptr, p, this.registeredClass);
                    return x
                }

                function gy(u, d) {
                    var p;
                    if (d === null) return this.isReference && rt("null is not a valid " + this.name), this.isSmartPointer ? (p = this.rawConstructor(), u !== null && u.push(this.rawDestructor, p), p) : 0;
                    d.$$ || rt('Cannot pass "' + us(d) + '" as a ' + this.name), d.$$.ptr || rt("Cannot pass deleted object as a pointer of type " + this.name), !this.isConst && d.$$.ptrType.isConst && rt("Cannot convert argument of type " + (d.$$.smartPtrType ? d.$$.smartPtrType.name : d.$$.ptrType.name) + " to parameter type " + this.name);
                    var x = d.$$.ptrType.registeredClass;
                    if (p = Ha(d.$$.ptr, x, this.registeredClass), this.isSmartPointer) switch (d.$$.smartPtr === void 0 && rt("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
                        case 0:
                            d.$$.smartPtrType === this ? p = d.$$.smartPtr : rt("Cannot convert argument of type " + (d.$$.smartPtrType ? d.$$.smartPtrType.name : d.$$.ptrType.name) + " to parameter type " + this.name);
                            break;
                        case 1:
                            p = d.$$.smartPtr;
                            break;
                        case 2:
                            if (d.$$.smartPtrType === this) p = d.$$.smartPtr;
                            else {
                                var N = d.clone();
                                p = this.rawShare(p, Oc(function() {
                                    N.delete()
                                })), u !== null && u.push(this.rawDestructor, p)
                            }
                            break;
                        default:
                            rt("Unsupporting sharing policy")
                    }
                    return p
                }

                function vy(u, d) {
                    if (d === null) return this.isReference && rt("null is not a valid " + this.name), 0;
                    d.$$ || rt('Cannot pass "' + us(d) + '" as a ' + this.name), d.$$.ptr || rt("Cannot pass deleted object as a pointer of type " + this.name), d.$$.ptrType.isConst && rt("Cannot convert argument of type " + d.$$.ptrType.name + " to parameter type " + this.name);
                    var p = d.$$.ptrType.registeredClass,
                        x = Ha(d.$$.ptr, p, this.registeredClass);
                    return x
                }

                function yy(u) {
                    return this.rawGetPointee && (u = this.rawGetPointee(u)), u
                }

                function xy(u) {
                    this.rawDestructor && this.rawDestructor(u)
                }

                function Ay(u) {
                    u !== null && u.delete()
                }

                function Yf(u, d, p) {
                    if (d === p) return u;
                    if (p.baseClass === void 0) return null;
                    var x = Yf(u, d, p.baseClass);
                    return x === null ? null : p.downcast(x)
                }

                function by() {
                    return Object.keys(yo).length
                }

                function wy() {
                    var u = [];
                    for (var d in yo) yo.hasOwnProperty(d) && u.push(yo[d]);
                    return u
                }

                function Sy(u) {
                    go = u, vo.length && go && go(Ic)
                }

                function Ny() {
                    e.getInheritedInstanceCount = by, e.getLiveInheritedInstances = wy, e.flushPendingDeletes = Ic, e.setDelayFunction = Sy
                }
                var yo = {};

                function Cy(u, d) {
                    for (d === void 0 && rt("ptr should not be undefined"); u.baseClass;) d = u.upcast(d), u = u.baseClass;
                    return d
                }

                function Ty(u, d) {
                    return d = Cy(u, d), yo[d]
                }

                function Wa(u, d) {
                    (!d.ptrType || !d.ptr) && Ua("makeClassHandle requires ptr and ptrType");
                    var p = !!d.smartPtrType,
                        x = !!d.smartPtr;
                    return p !== x && Ua("Both smartPtrType and smartPtr must be specified"), d.count = {
                        value: 1
                    }, po(Object.create(u, {
                        $$: {
                            value: d
                        }
                    }))
                }

                function Ey(u) {
                    var d = this.getPointee(u);
                    if (!d) return this.destructor(u), null;
                    var p = Ty(this.registeredClass, d);
                    if (p !== void 0) {
                        if (p.$$.count.value === 0) return p.$$.ptr = d, p.$$.smartPtr = u, p.clone();
                        var x = p.clone();
                        return this.destructor(u), x
                    }

                    function N() {
                        return this.isSmartPointer ? Wa(this.registeredClass.instancePrototype, {
                            ptrType: this.pointeeType,
                            ptr: d,
                            smartPtrType: this,
                            smartPtr: u
                        }) : Wa(this.registeredClass.instancePrototype, {
                            ptrType: this,
                            ptr: u
                        })
                    }
                    var T = this.registeredClass.getActualType(d),
                        _ = Jf[T];
                    if (!_) return N.call(this);
                    var D;
                    this.isConst ? D = _.constPointerType : D = _.pointerType;
                    var R = Yf(d, this.registeredClass, D.registeredClass);
                    return R === null ? N.call(this) : this.isSmartPointer ? Wa(D.registeredClass.instancePrototype, {
                        ptrType: D,
                        ptr: R,
                        smartPtrType: this,
                        smartPtr: u
                    }) : Wa(D.registeredClass.instancePrototype, {
                        ptrType: D,
                        ptr: R
                    })
                }

                function My() {
                    Ri.prototype.getPointee = yy, Ri.prototype.destructor = xy, Ri.prototype.argPackAdvance = 8, Ri.prototype.readValueFromPointer = os, Ri.prototype.deleteObject = Ay, Ri.prototype.fromWireType = Ey
                }

                function Ri(u, d, p, x, N, T, _, D, R, K, ee) {
                    this.name = u, this.registeredClass = d, this.isReference = p, this.isConst = x, this.isSmartPointer = N, this.pointeeType = T, this.sharingPolicy = _, this.rawGetPointee = D, this.rawConstructor = R, this.rawShare = K, this.rawDestructor = ee, !N && d.baseClass === void 0 ? x ? (this.toWireType = py, this.destructorFunction = null) : (this.toWireType = vy, this.destructorFunction = null) : this.toWireType = gy
                }

                function Kf(u, d, p) {
                    e.hasOwnProperty(u) || Ua("Replacing nonexistant public symbol"), e[u].overloadTable !== void 0 && p !== void 0 ? e[u].overloadTable[p] = d : (e[u] = d, e[u].argCount = p)
                }

                function _y(u, d, p) {
                    var x = e["dynCall_" + u];
                    return p && p.length ? x.apply(null, [d].concat(p)) : x.call(null, d)
                }

                function Iy(u, d, p) {
                    return u.includes("j") ? _y(u, d, p) : nt.get(d).apply(null, p)
                }

                function Ly(u, d) {
                    var p = [];
                    return function() {
                        p.length = arguments.length;
                        for (var x = 0; x < arguments.length; x++) p[x] = arguments[x];
                        return Iy(u, d, p)
                    }
                }

                function $t(u, d) {
                    u = kt(u);

                    function p() {
                        return u.includes("j") ? Ly(u, d) : nt.get(d)
                    }
                    var x = p();
                    return typeof x != "function" && rt("unknown function pointer with signature " + u + ": " + d), x
                }
                var Xf = void 0;

                function qf(u) {
                    var d = rd(u),
                        p = kt(d);
                    return Gi(d), p
                }

                function cs(u, d) {
                    var p = [],
                        x = {};

                    function N(T) {
                        if (!x[T] && !Nn[T]) {
                            if (za[T]) {
                                za[T].forEach(N);
                                return
                            }
                            p.push(T), x[T] = !0
                        }
                    }
                    throw d.forEach(N), new Xf(u + ": " + p.map(qf).join([", "]))
                }

                function Dy(u, d, p, x, N, T, _, D, R, K, ee, ue, ce) {
                    ee = kt(ee), T = $t(N, T), D && (D = $t(_, D)), K && (K = $t(R, K)), ce = $t(ue, ce);
                    var de = Tc(ee);
                    Lc(de, function() {
                        cs("Cannot construct " + ee + " due to unbound types", [x])
                    }), yi([u, d, p], x ? [x] : [], function(ge) {
                        ge = ge[0];
                        var ze, Ke;
                        x ? (ze = ge.registeredClass, Ke = ze.instancePrototype) : Ke = tn.prototype;
                        var st = ka(de, function() {
                                if (Object.getPrototypeOf(this) !== ae) throw new ls("Use 'new' to construct " + ee);
                                if (me.constructor_body === void 0) throw new ls(ee + " has no accessible constructor");
                                var $r = me.constructor_body[arguments.length];
                                if ($r === void 0) throw new ls("Tried to invoke ctor of " + ee + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(me.constructor_body).toString() + ") parameters instead!");
                                return $r.apply(this, arguments)
                            }),
                            ae = Object.create(Ke, {
                                constructor: {
                                    value: st
                                }
                            });
                        st.prototype = ae;
                        var me = new my(ee, st, ae, ce, ze, T, D, K),
                            ct = new Ri(ee, me, !0, !1, !1),
                            Xe = new Ri(ee + "*", me, !1, !1, !1),
                            dt = new Ri(ee + " const*", me, !1, !0, !1);
                        return Jf[u] = {
                            pointerType: Xe,
                            constPointerType: dt
                        }, Kf(de, st), [ct, Xe, dt]
                    })
                }

                function Dc(u, d) {
                    for (var p = [], x = 0; x < u; x++) p.push(q[(d >> 2) + x]);
                    return p
                }

                function Py(u, d, p, x, N, T) {
                    X(d > 0);
                    var _ = Dc(d, p);
                    N = $t(x, N), yi([], [u], function(D) {
                        D = D[0];
                        var R = "constructor " + D.name;
                        if (D.registeredClass.constructor_body === void 0 && (D.registeredClass.constructor_body = []), D.registeredClass.constructor_body[d - 1] !== void 0) throw new ls("Cannot register multiple constructors with identical number of parameters (" + (d - 1) + ") for class '" + D.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
                        return D.registeredClass.constructor_body[d - 1] = function() {
                            cs("Cannot construct " + D.name + " due to unbound types", _)
                        }, yi([], _, function(K) {
                            return K.splice(1, 0, null), D.registeredClass.constructor_body[d - 1] = Pc(R, K, null, N, T), []
                        }), []
                    })
                }

                function By(u, d) {
                    if (!(u instanceof Function)) throw new TypeError("new_ called with constructor type " + typeof u + " which is not a function");
                    var p = ka(u.name || "unknownFunctionName", function() {});
                    p.prototype = u.prototype;
                    var x = new p,
                        N = u.apply(x, d);
                    return N instanceof Object ? N : x
                }

                function Pc(u, d, p, x, N) {
                    var T = d.length;
                    T < 2 && rt("argTypes array size mismatch! Must at least get return value and 'this' types!");
                    for (var _ = d[1] !== null && p !== null, D = !1, R = 1; R < d.length; ++R)
                        if (d[R] !== null && d[R].destructorFunction === void 0) {
                            D = !0;
                            break
                        } for (var K = d[0].name !== "void", ee = "", ue = "", R = 0; R < T - 2; ++R) ee += (R !== 0 ? ", " : "") + "arg" + R, ue += (R !== 0 ? ", " : "") + "arg" + R + "Wired";
                    var ce = "return function " + Tc(u) + "(" + ee + `) {
if (arguments.length !== ` + (T - 2) + `) {
throwBindingError('function ` + u + " called with ' + arguments.length + ' arguments, expected " + (T - 2) + ` args!');
}
`;
                    D && (ce += `var destructors = [];
`);
                    var de = D ? "destructors" : "null",
                        ge = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"],
                        ze = [rt, x, N, Ga, d[0], d[1]];
                    _ && (ce += "var thisWired = classParam.toWireType(" + de + `, this);
`);
                    for (var R = 0; R < T - 2; ++R) ce += "var arg" + R + "Wired = argType" + R + ".toWireType(" + de + ", arg" + R + "); // " + d[R + 2].name + `
`, ge.push("argType" + R), ze.push(d[R + 2]);
                    if (_ && (ue = "thisWired" + (ue.length > 0 ? ", " : "") + ue), ce += (K ? "var rv = " : "") + "invoker(fn" + (ue.length > 0 ? ", " : "") + ue + `);
`, D) ce += `runDestructors(destructors);
`;
                    else
                        for (var R = _ ? 1 : 2; R < d.length; ++R) {
                            var Ke = R === 1 ? "thisWired" : "arg" + (R - 2) + "Wired";
                            d[R].destructorFunction !== null && (ce += Ke + "_dtor(" + Ke + "); // " + d[R].name + `
`, ge.push(Ke + "_dtor"), ze.push(d[R].destructorFunction))
                        }
                    K && (ce += `var ret = retType.fromWireType(rv);
return ret;
`), ce += `}
`, ge.push(ce);
                    var st = By(Function, ge).apply(null, ze);
                    return st
                }

                function Oy(u, d, p, x, N, T, _, D) {
                    var R = Dc(p, x);
                    d = kt(d), T = $t(N, T), yi([], [u], function(K) {
                        K = K[0];
                        var ee = K.name + "." + d;
                        d.startsWith("@@") && (d = Symbol[d.substring(2)]), D && K.registeredClass.pureVirtualFunctions.push(d);

                        function ue() {
                            cs("Cannot call " + ee + " due to unbound types", R)
                        }
                        var ce = K.registeredClass.instancePrototype,
                            de = ce[d];
                        return de === void 0 || de.overloadTable === void 0 && de.className !== K.name && de.argCount === p - 2 ? (ue.argCount = p - 2, ue.className = K.name, ce[d] = ue) : (Qf(ce, d, ee), ce[d].overloadTable[p - 2] = ue), yi([], R, function(ge) {
                            var ze = Pc(ee, ge, K, T, _);
                            return ce[d].overloadTable === void 0 ? (ze.argCount = p - 2, ce[d] = ze) : ce[d].overloadTable[p - 2] = ze, []
                        }), []
                    })
                }

                function Zf(u, d, p) {
                    return u instanceof Object || rt(p + ' with invalid "this": ' + u), u instanceof d.registeredClass.constructor || rt(p + ' incompatible with "this" of type ' + u.constructor.name), u.$$.ptr || rt("cannot call emscripten binding method " + p + " on deleted object"), Ha(u.$$.ptr, u.$$.ptrType.registeredClass, d.registeredClass)
                }

                function Ry(u, d, p, x, N, T, _, D, R, K) {
                    d = kt(d), N = $t(x, N), yi([], [u], function(ee) {
                        ee = ee[0];
                        var ue = ee.name + "." + d,
                            ce = {
                                get: function() {
                                    cs("Cannot access " + ue + " due to unbound types", [p, _])
                                },
                                enumerable: !0,
                                configurable: !0
                            };
                        return R ? ce.set = function() {
                            cs("Cannot access " + ue + " due to unbound types", [p, _])
                        } : ce.set = function(de) {
                            rt(ue + " is a read-only property")
                        }, Object.defineProperty(ee.registeredClass.instancePrototype, d, ce), yi([], R ? [p, _] : [p], function(de) {
                            var ge = de[0],
                                ze = {
                                    get: function() {
                                        var st = Zf(this, ee, ue + " getter");
                                        return ge.fromWireType(N(T, st))
                                    },
                                    enumerable: !0
                                };
                            if (R) {
                                R = $t(D, R);
                                var Ke = de[1];
                                ze.set = function(st) {
                                    var ae = Zf(this, ee, ue + " setter"),
                                        me = [];
                                    R(K, ae, Ke.toWireType(me, st)), Ga(me)
                                }
                            }
                            return Object.defineProperty(ee.registeredClass.instancePrototype, d, ze), []
                        }), []
                    })
                }
                var Bc = [],
                    Zr = [{}, {
                        value: void 0
                    }, {
                        value: null
                    }, {
                        value: !0
                    }, {
                        value: !1
                    }];

                function $f(u) {
                    u > 4 && --Zr[u].refcount == 0 && (Zr[u] = void 0, Bc.push(u))
                }

                function Fy() {
                    for (var u = 0, d = 5; d < Zr.length; ++d) Zr[d] !== void 0 && ++u;
                    return u
                }

                function Gy() {
                    for (var u = 5; u < Zr.length; ++u)
                        if (Zr[u] !== void 0) return Zr[u];
                    return null
                }

                function zy() {
                    e.count_emval_handles = Fy, e.get_first_emval = Gy
                }

                function Oc(u) {
                    switch (u) {
                        case void 0:
                            return 1;
                        case null:
                            return 2;
                        case !0:
                            return 3;
                        case !1:
                            return 4;
                        default: {
                            var d = Bc.length ? Bc.pop() : Zr.length;
                            return Zr[d] = {
                                refcount: 1,
                                value: u
                            }, d
                        }
                    }
                }

                function ky(u, d) {
                    d = kt(d), xi(u, {
                        name: d,
                        fromWireType: function(p) {
                            var x = Zr[p].value;
                            return $f(p), x
                        },
                        toWireType: function(p, x) {
                            return Oc(x)
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: os,
                        destructorFunction: null
                    })
                }

                function Uy(u, d, p) {
                    switch (d) {
                        case 0:
                            return function(x) {
                                var N = p ? ie : oe;
                                return this.fromWireType(N[x])
                            };
                        case 1:
                            return function(x) {
                                var N = p ? he : pe;
                                return this.fromWireType(N[x >> 1])
                            };
                        case 2:
                            return function(x) {
                                var N = p ? q : Ae;
                                return this.fromWireType(N[x >> 2])
                            };
                        default:
                            throw new TypeError("Unknown integer type: " + u)
                    }
                }

                function jy(u, d, p, x) {
                    var N = Va(p);
                    d = kt(d);

                    function T() {}
                    T.values = {}, xi(u, {
                        name: d,
                        constructor: T,
                        fromWireType: function(_) {
                            return this.constructor.values[_]
                        },
                        toWireType: function(_, D) {
                            return D.value
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: Uy(d, N, x),
                        destructorFunction: null
                    }), Lc(d, T)
                }

                function ed(u, d) {
                    var p = Nn[u];
                    return p === void 0 && rt(d + " has unknown type " + qf(u)), p
                }

                function Vy(u, d, p) {
                    var x = ed(u, "enum");
                    d = kt(d);
                    var N = x.constructor,
                        T = Object.create(x.constructor.prototype, {
                            value: {
                                value: p
                            },
                            constructor: {
                                value: ka(x.name + "_" + d, function() {})
                            }
                        });
                    N.values[p] = T, N[d] = T
                }

                function us(u) {
                    if (u === null) return "null";
                    var d = typeof u;
                    return d === "object" || d === "array" || d === "function" ? u.toString() : "" + u
                }

                function Hy(u, d) {
                    switch (d) {
                        case 2:
                            return function(p) {
                                return this.fromWireType(ke[p >> 2])
                            };
                        case 3:
                            return function(p) {
                                return this.fromWireType(Ce[p >> 3])
                            };
                        default:
                            throw new TypeError("Unknown float type: " + u)
                    }
                }

                function Wy(u, d, p) {
                    var x = Va(p);
                    d = kt(d), xi(u, {
                        name: d,
                        fromWireType: function(N) {
                            return N
                        },
                        toWireType: function(N, T) {
                            if (typeof T != "number" && typeof T != "boolean") throw new TypeError('Cannot convert "' + us(T) + '" to ' + this.name);
                            return T
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: Hy(d, x),
                        destructorFunction: null
                    })
                }

                function Jy(u, d, p, x, N, T) {
                    var _ = Dc(d, p);
                    u = kt(u), N = $t(x, N), Lc(u, function() {
                        cs("Cannot call " + u + " due to unbound types", _)
                    }, d - 1), yi([], _, function(D) {
                        var R = [D[0], null].concat(D.slice(1));
                        return Kf(u, Pc(u, R, null, N, T), d - 1), []
                    })
                }

                function Qy(u, d, p) {
                    switch (d) {
                        case 0:
                            return p ? function(N) {
                                return ie[N]
                            } : function(N) {
                                return oe[N]
                            };
                        case 1:
                            return p ? function(N) {
                                return he[N >> 1]
                            } : function(N) {
                                return pe[N >> 1]
                            };
                        case 2:
                            return p ? function(N) {
                                return q[N >> 2]
                            } : function(N) {
                                return Ae[N >> 2]
                            };
                        default:
                            throw new TypeError("Unknown integer type: " + u)
                    }
                }

                function Yy(u, d, p, x, N) {
                    d = kt(d), N === -1 && (N = 4294967295);
                    var T = Va(p),
                        _ = function(K) {
                            return K
                        };
                    if (x === 0) {
                        var D = 32 - 8 * p;
                        _ = function(K) {
                            return K << D >>> D
                        }
                    }
                    var R = d.includes("unsigned");
                    xi(u, {
                        name: d,
                        fromWireType: _,
                        toWireType: function(K, ee) {
                            if (typeof ee != "number" && typeof ee != "boolean") throw new TypeError('Cannot convert "' + us(ee) + '" to ' + this.name);
                            if (ee < x || ee > N) throw new TypeError('Passing a number "' + us(ee) + '" from JS side to C/C++ side to an argument of type "' + d + '", which is outside the valid range [' + x + ", " + N + "]!");
                            return R ? ee >>> 0 : ee | 0
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: Qy(d, T, x !== 0),
                        destructorFunction: null
                    })
                }

                function Ky(u, d, p) {
                    var x = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array],
                        N = x[d];

                    function T(_) {
                        _ = _ >> 2;
                        var D = Ae,
                            R = D[_],
                            K = D[_ + 1];
                        return new N(se, K, R)
                    }
                    p = kt(p), xi(u, {
                        name: p,
                        fromWireType: T,
                        argPackAdvance: 8,
                        readValueFromPointer: T
                    }, {
                        ignoreDuplicateRegistrations: !0
                    })
                }

                function Xy(u, d) {
                    d = kt(d);
                    var p = d === "std::string";
                    xi(u, {
                        name: d,
                        fromWireType: function(x) {
                            var N = Ae[x >> 2],
                                T;
                            if (p)
                                for (var _ = x + 4, D = 0; D <= N; ++D) {
                                    var R = x + 4 + D;
                                    if (D == N || oe[R] == 0) {
                                        var K = R - _,
                                            ee = le(_, K);
                                        T === void 0 ? T = ee : (T += String.fromCharCode(0), T += ee), _ = R + 1
                                    }
                                } else {
                                    for (var ue = new Array(N), D = 0; D < N; ++D) ue[D] = String.fromCharCode(oe[x + 4 + D]);
                                    T = ue.join("")
                                }
                            return Gi(x), T
                        },
                        toWireType: function(x, N) {
                            N instanceof ArrayBuffer && (N = new Uint8Array(N));
                            var T, _ = typeof N == "string";
                            _ || N instanceof Uint8Array || N instanceof Uint8ClampedArray || N instanceof Int8Array || rt("Cannot pass non-string to std::string"), p && _ ? T = function() {
                                return G(N)
                            } : T = function() {
                                return N.length
                            };
                            var D = T(),
                                R = $a(4 + D + 1);
                            if (Ae[R >> 2] = D, p && _) U(N, R + 4, D + 1);
                            else if (_)
                                for (var K = 0; K < D; ++K) {
                                    var ee = N.charCodeAt(K);
                                    ee > 255 && (Gi(R), rt("String has UTF-16 code units that do not fit in 8 bits")), oe[R + 4 + K] = ee
                                } else
                                    for (var K = 0; K < D; ++K) oe[R + 4 + K] = N[K];
                            return x !== null && x.push(Gi, R), R
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: os,
                        destructorFunction: function(x) {
                            Gi(x)
                        }
                    })
                }

                function qy(u, d, p) {
                    p = kt(p);
                    var x, N, T, _, D;
                    d === 2 ? (x = j, N = ne, _ = F, T = function() {
                        return pe
                    }, D = 1) : d === 4 && (x = Y, N = $, _ = re, T = function() {
                        return Ae
                    }, D = 2), xi(u, {
                        name: p,
                        fromWireType: function(R) {
                            for (var K = Ae[R >> 2], ee = T(), ue, ce = R + 4, de = 0; de <= K; ++de) {
                                var ge = R + 4 + de * d;
                                if (de == K || ee[ge >> D] == 0) {
                                    var ze = ge - ce,
                                        Ke = x(ce, ze);
                                    ue === void 0 ? ue = Ke : (ue += String.fromCharCode(0), ue += Ke), ce = ge + d
                                }
                            }
                            return Gi(R), ue
                        },
                        toWireType: function(R, K) {
                            typeof K != "string" && rt("Cannot pass non-string to C++ string type " + p);
                            var ee = _(K),
                                ue = $a(4 + ee + d);
                            return Ae[ue >> 2] = ee >> D, N(K, ue + 4, ee + d), R !== null && R.push(Gi, ue), ue
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: os,
                        destructorFunction: function(R) {
                            Gi(R)
                        }
                    })
                }

                function Zy(u, d, p, x, N, T) {
                    Fa[u] = {
                        name: kt(d),
                        rawConstructor: $t(p, x),
                        rawDestructor: $t(N, T),
                        elements: []
                    }
                }

                function $y(u, d, p, x, N, T, _, D, R) {
                    Fa[u].elements.push({
                        getterReturnType: d,
                        getter: $t(p, x),
                        getterContext: N,
                        setterArgumentType: T,
                        setter: $t(_, D),
                        setterContext: R
                    })
                }

                function ex(u, d, p, x, N, T) {
                    ja[u] = {
                        name: kt(d),
                        rawConstructor: $t(p, x),
                        rawDestructor: $t(N, T),
                        fields: []
                    }
                }

                function tx(u, d, p, x, N, T, _, D, R, K) {
                    ja[u].fields.push({
                        fieldName: kt(d),
                        getterReturnType: p,
                        getter: $t(x, N),
                        getterContext: T,
                        setterArgumentType: _,
                        setter: $t(D, R),
                        setterContext: K
                    })
                }

                function rx(u, d) {
                    d = kt(d), xi(u, {
                        isVoid: !0,
                        name: d,
                        argPackAdvance: 0,
                        fromWireType: function() {},
                        toWireType: function(p, x) {}
                    })
                }

                function ix(u) {
                    u > 4 && (Zr[u].refcount += 1)
                }

                function nx(u, d) {
                    u = ed(u, "_emval_take_value");
                    var p = u.readValueFromPointer(d);
                    return Oc(p)
                }

                function sx() {
                    hr()
                }

                function ox(u, d, p) {
                    oe.copyWithin(u, d, d + p)
                }

                function ax(u) {
                    try {
                        return I.grow(u - se.byteLength + 65535 >>> 16), Te(I.buffer), 1
                    } catch (d) {}
                }

                function lx(u) {
                    var d = oe.length;
                    u = u >>> 0;
                    var p = 2147483648;
                    if (u > p) return !1;
                    for (var x = 1; x <= 4; x *= 2) {
                        var N = d * (1 + .2 / x);
                        N = Math.min(N, u + 100663296);
                        var T = Math.min(p, Se(Math.max(u, N), 65536)),
                            _ = ax(T);
                        if (_) return !0
                    }
                    return !1
                }
                var Rc = {};

                function cx() {
                    return l || "./this.program"
                }

                function xo() {
                    if (!xo.strings) {
                        var u = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
                            d = {
                                USER: "web_user",
                                LOGNAME: "web_user",
                                PATH: "/",
                                PWD: "/",
                                HOME: "/home/web_user",
                                LANG: u,
                                _: cx()
                            };
                        for (var p in Rc) Rc[p] === void 0 ? delete d[p] : d[p] = Rc[p];
                        var x = [];
                        for (var p in d) x.push(p + "=" + d[p]);
                        xo.strings = x
                    }
                    return xo.strings
                }
                var ft = {
                    splitPath: function(u) {
                        var d = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
                        return d.exec(u).slice(1)
                    },
                    normalizeArray: function(u, d) {
                        for (var p = 0, x = u.length - 1; x >= 0; x--) {
                            var N = u[x];
                            N === "." ? u.splice(x, 1) : N === ".." ? (u.splice(x, 1), p++) : p && (u.splice(x, 1), p--)
                        }
                        if (d)
                            for (; p; p--) u.unshift("..");
                        return u
                    },
                    normalize: function(u) {
                        var d = u.charAt(0) === "/",
                            p = u.substr(-1) === "/";
                        return u = ft.normalizeArray(u.split("/").filter(function(x) {
                            return !!x
                        }), !d).join("/"), !u && !d && (u = "."), u && p && (u += "/"), (d ? "/" : "") + u
                    },
                    dirname: function(u) {
                        var d = ft.splitPath(u),
                            p = d[0],
                            x = d[1];
                        return !p && !x ? "." : (x && (x = x.substr(0, x.length - 1)), p + x)
                    },
                    basename: function(u) {
                        if (u === "/") return "/";
                        u = ft.normalize(u), u = u.replace(/\/$/, "");
                        var d = u.lastIndexOf("/");
                        return d === -1 ? u : u.substr(d + 1)
                    },
                    extname: function(u) {
                        return ft.splitPath(u)[3]
                    },
                    join: function() {
                        var u = Array.prototype.slice.call(arguments, 0);
                        return ft.normalize(u.join("/"))
                    },
                    join2: function(u, d) {
                        return ft.normalize(u + "/" + d)
                    }
                };

                function ux() {
                    if (typeof crypto == "object" && typeof crypto.getRandomValues == "function") {
                        var u = new Uint8Array(1);
                        return function() {
                            return crypto.getRandomValues(u), u[0]
                        }
                    } else return function() {
                        hr("randomDevice")
                    }
                }
                var Fi = {
                        resolve: function() {
                            for (var u = "", d = !1, p = arguments.length - 1; p >= -1 && !d; p--) {
                                var x = p >= 0 ? arguments[p] : b.cwd();
                                if (typeof x != "string") throw new TypeError("Arguments to path.resolve must be strings");
                                if (!x) return "";
                                u = x + "/" + u, d = x.charAt(0) === "/"
                            }
                            return u = ft.normalizeArray(u.split("/").filter(function(N) {
                                return !!N
                            }), !d).join("/"), (d ? "/" : "") + u || "."
                        },
                        relative: function(u, d) {
                            u = Fi.resolve(u).substr(1), d = Fi.resolve(d).substr(1);

                            function p(K) {
                                for (var ee = 0; ee < K.length && K[ee] === ""; ee++);
                                for (var ue = K.length - 1; ue >= 0 && K[ue] === ""; ue--);
                                return ee > ue ? [] : K.slice(ee, ue - ee + 1)
                            }
                            for (var x = p(u.split("/")), N = p(d.split("/")), T = Math.min(x.length, N.length), _ = T, D = 0; D < T; D++)
                                if (x[D] !== N[D]) {
                                    _ = D;
                                    break
                                } for (var R = [], D = _; D < x.length; D++) R.push("..");
                            return R = R.concat(N.slice(_)), R.join("/")
                        }
                    },
                    rn = {
                        ttys: [],
                        init: function() {},
                        shutdown: function() {},
                        register: function(u, d) {
                            rn.ttys[u] = {
                                input: [],
                                output: [],
                                ops: d
                            }, b.registerDevice(u, rn.stream_ops)
                        },
                        stream_ops: {
                            open: function(u) {
                                var d = rn.ttys[u.node.rdev];
                                if (!d) throw new b.ErrnoError(43);
                                u.tty = d, u.seekable = !1
                            },
                            close: function(u) {
                                u.tty.ops.flush(u.tty)
                            },
                            flush: function(u) {
                                u.tty.ops.flush(u.tty)
                            },
                            read: function(u, d, p, x, N) {
                                if (!u.tty || !u.tty.ops.get_char) throw new b.ErrnoError(60);
                                for (var T = 0, _ = 0; _ < x; _++) {
                                    var D;
                                    try {
                                        D = u.tty.ops.get_char(u.tty)
                                    } catch (R) {
                                        throw new b.ErrnoError(29)
                                    }
                                    if (D === void 0 && T === 0) throw new b.ErrnoError(6);
                                    if (D == null) break;
                                    T++, d[p + _] = D
                                }
                                return T && (u.node.timestamp = Date.now()), T
                            },
                            write: function(u, d, p, x, N) {
                                if (!u.tty || !u.tty.ops.put_char) throw new b.ErrnoError(60);
                                try {
                                    for (var T = 0; T < x; T++) u.tty.ops.put_char(u.tty, d[p + T])
                                } catch (_) {
                                    throw new b.ErrnoError(29)
                                }
                                return x && (u.node.timestamp = Date.now()), T
                            }
                        },
                        default_tty_ops: {
                            get_char: function(u) {
                                if (!u.input.length) {
                                    var d = null;
                                    if (typeof window != "undefined" && typeof window.prompt == "function" ? (d = window.prompt("Input: "), d !== null && (d += `
`)) : typeof readline == "function" && (d = readline(), d !== null && (d += `
`)), !d) return null;
                                    u.input = Za(d, !0)
                                }
                                return u.input.shift()
                            },
                            put_char: function(u, d) {
                                d === null || d === 10 ? (w(Z(u.output, 0)), u.output = []) : d != 0 && u.output.push(d)
                            },
                            flush: function(u) {
                                u.output && u.output.length > 0 && (w(Z(u.output, 0)), u.output = [])
                            }
                        },
                        default_tty1_ops: {
                            put_char: function(u, d) {
                                d === null || d === 10 ? (C(Z(u.output, 0)), u.output = []) : d != 0 && u.output.push(d)
                            },
                            flush: function(u) {
                                u.output && u.output.length > 0 && (C(Z(u.output, 0)), u.output = [])
                            }
                        }
                    };

                function fx(u) {
                    hr()
                }
                var Ue = {
                    ops_table: null,
                    mount: function(u) {
                        return Ue.createNode(null, "/", 16384 | 511, 0)
                    },
                    createNode: function(u, d, p, x) {
                        if (b.isBlkdev(p) || b.isFIFO(p)) throw new b.ErrnoError(63);
                        Ue.ops_table || (Ue.ops_table = {
                            dir: {
                                node: {
                                    getattr: Ue.node_ops.getattr,
                                    setattr: Ue.node_ops.setattr,
                                    lookup: Ue.node_ops.lookup,
                                    mknod: Ue.node_ops.mknod,
                                    rename: Ue.node_ops.rename,
                                    unlink: Ue.node_ops.unlink,
                                    rmdir: Ue.node_ops.rmdir,
                                    readdir: Ue.node_ops.readdir,
                                    symlink: Ue.node_ops.symlink
                                },
                                stream: {
                                    llseek: Ue.stream_ops.llseek
                                }
                            },
                            file: {
                                node: {
                                    getattr: Ue.node_ops.getattr,
                                    setattr: Ue.node_ops.setattr
                                },
                                stream: {
                                    llseek: Ue.stream_ops.llseek,
                                    read: Ue.stream_ops.read,
                                    write: Ue.stream_ops.write,
                                    allocate: Ue.stream_ops.allocate,
                                    mmap: Ue.stream_ops.mmap,
                                    msync: Ue.stream_ops.msync
                                }
                            },
                            link: {
                                node: {
                                    getattr: Ue.node_ops.getattr,
                                    setattr: Ue.node_ops.setattr,
                                    readlink: Ue.node_ops.readlink
                                },
                                stream: {}
                            },
                            chrdev: {
                                node: {
                                    getattr: Ue.node_ops.getattr,
                                    setattr: Ue.node_ops.setattr
                                },
                                stream: b.chrdev_stream_ops
                            }
                        });
                        var N = b.createNode(u, d, p, x);
                        return b.isDir(N.mode) ? (N.node_ops = Ue.ops_table.dir.node, N.stream_ops = Ue.ops_table.dir.stream, N.contents = {}) : b.isFile(N.mode) ? (N.node_ops = Ue.ops_table.file.node, N.stream_ops = Ue.ops_table.file.stream, N.usedBytes = 0, N.contents = null) : b.isLink(N.mode) ? (N.node_ops = Ue.ops_table.link.node, N.stream_ops = Ue.ops_table.link.stream) : b.isChrdev(N.mode) && (N.node_ops = Ue.ops_table.chrdev.node, N.stream_ops = Ue.ops_table.chrdev.stream), N.timestamp = Date.now(), u && (u.contents[d] = N, u.timestamp = N.timestamp), N
                    },
                    getFileDataAsTypedArray: function(u) {
                        return u.contents ? u.contents.subarray ? u.contents.subarray(0, u.usedBytes) : new Uint8Array(u.contents) : new Uint8Array(0)
                    },
                    expandFileStorage: function(u, d) {
                        var p = u.contents ? u.contents.length : 0;
                        if (!(p >= d)) {
                            var x = 1024 * 1024;
                            d = Math.max(d, p * (p < x ? 2 : 1.125) >>> 0), p != 0 && (d = Math.max(d, 256));
                            var N = u.contents;
                            u.contents = new Uint8Array(d), u.usedBytes > 0 && u.contents.set(N.subarray(0, u.usedBytes), 0)
                        }
                    },
                    resizeFileStorage: function(u, d) {
                        if (u.usedBytes != d)
                            if (d == 0) u.contents = null, u.usedBytes = 0;
                            else {
                                var p = u.contents;
                                u.contents = new Uint8Array(d), p && u.contents.set(p.subarray(0, Math.min(d, u.usedBytes))), u.usedBytes = d
                            }
                    },
                    node_ops: {
                        getattr: function(u) {
                            var d = {};
                            return d.dev = b.isChrdev(u.mode) ? u.id : 1, d.ino = u.id, d.mode = u.mode, d.nlink = 1, d.uid = 0, d.gid = 0, d.rdev = u.rdev, b.isDir(u.mode) ? d.size = 4096 : b.isFile(u.mode) ? d.size = u.usedBytes : b.isLink(u.mode) ? d.size = u.link.length : d.size = 0, d.atime = new Date(u.timestamp), d.mtime = new Date(u.timestamp), d.ctime = new Date(u.timestamp), d.blksize = 4096, d.blocks = Math.ceil(d.size / d.blksize), d
                        },
                        setattr: function(u, d) {
                            d.mode !== void 0 && (u.mode = d.mode), d.timestamp !== void 0 && (u.timestamp = d.timestamp), d.size !== void 0 && Ue.resizeFileStorage(u, d.size)
                        },
                        lookup: function(u, d) {
                            throw b.genericErrors[44]
                        },
                        mknod: function(u, d, p, x) {
                            return Ue.createNode(u, d, p, x)
                        },
                        rename: function(u, d, p) {
                            if (b.isDir(u.mode)) {
                                var x;
                                try {
                                    x = b.lookupNode(d, p)
                                } catch (T) {}
                                if (x)
                                    for (var N in x.contents) throw new b.ErrnoError(55)
                            }
                            delete u.parent.contents[u.name], u.parent.timestamp = Date.now(), u.name = p, d.contents[p] = u, d.timestamp = u.parent.timestamp, u.parent = d
                        },
                        unlink: function(u, d) {
                            delete u.contents[d], u.timestamp = Date.now()
                        },
                        rmdir: function(u, d) {
                            var p = b.lookupNode(u, d);
                            for (var x in p.contents) throw new b.ErrnoError(55);
                            delete u.contents[d], u.timestamp = Date.now()
                        },
                        readdir: function(u) {
                            var d = [".", ".."];
                            for (var p in u.contents) !u.contents.hasOwnProperty(p) || d.push(p);
                            return d
                        },
                        symlink: function(u, d, p) {
                            var x = Ue.createNode(u, d, 511 | 40960, 0);
                            return x.link = p, x
                        },
                        readlink: function(u) {
                            if (!b.isLink(u.mode)) throw new b.ErrnoError(28);
                            return u.link
                        }
                    },
                    stream_ops: {
                        read: function(u, d, p, x, N) {
                            var T = u.node.contents;
                            if (N >= u.node.usedBytes) return 0;
                            var _ = Math.min(u.node.usedBytes - N, x);
                            if (_ > 8 && T.subarray) d.set(T.subarray(N, N + _), p);
                            else
                                for (var D = 0; D < _; D++) d[p + D] = T[N + D];
                            return _
                        },
                        write: function(u, d, p, x, N, T) {
                            if (d.buffer === ie.buffer && (T = !1), !x) return 0;
                            var _ = u.node;
                            if (_.timestamp = Date.now(), d.subarray && (!_.contents || _.contents.subarray)) {
                                if (T) return _.contents = d.subarray(p, p + x), _.usedBytes = x, x;
                                if (_.usedBytes === 0 && N === 0) return _.contents = d.slice(p, p + x), _.usedBytes = x, x;
                                if (N + x <= _.usedBytes) return _.contents.set(d.subarray(p, p + x), N), x
                            }
                            if (Ue.expandFileStorage(_, N + x), _.contents.subarray && d.subarray) _.contents.set(d.subarray(p, p + x), N);
                            else
                                for (var D = 0; D < x; D++) _.contents[N + D] = d[p + D];
                            return _.usedBytes = Math.max(_.usedBytes, N + x), x
                        },
                        llseek: function(u, d, p) {
                            var x = d;
                            if (p === 1 ? x += u.position : p === 2 && b.isFile(u.node.mode) && (x += u.node.usedBytes), x < 0) throw new b.ErrnoError(28);
                            return x
                        },
                        allocate: function(u, d, p) {
                            Ue.expandFileStorage(u.node, d + p), u.node.usedBytes = Math.max(u.node.usedBytes, d + p)
                        },
                        mmap: function(u, d, p, x, N, T) {
                            if (d !== 0) throw new b.ErrnoError(28);
                            if (!b.isFile(u.node.mode)) throw new b.ErrnoError(43);
                            var _, D, R = u.node.contents;
                            if (!(T & 2) && R.buffer === se) D = !1, _ = R.byteOffset;
                            else {
                                if ((x > 0 || x + p < R.length) && (R.subarray ? R = R.subarray(x, x + p) : R = Array.prototype.slice.call(R, x, x + p)), D = !0, _ = fx(p), !_) throw new b.ErrnoError(48);
                                ie.set(R, _)
                            }
                            return {
                                ptr: _,
                                allocated: D
                            }
                        },
                        msync: function(u, d, p, x, N) {
                            if (!b.isFile(u.node.mode)) throw new b.ErrnoError(43);
                            if (N & 2) return 0;
                            var T = Ue.stream_ops.write(u, d, 0, x, p, !1);
                            return 0
                        }
                    }
                };

                function dx(u, d, p, x) {
                    var N = x ? "" : ho("al " + u);
                    g(u, function(T) {
                        X(T, 'Loading data file "' + u + '" failed (no arrayBuffer).'), d(new Uint8Array(T)), N && Sn(N)
                    }, function(T) {
                        if (p) p();
                        else throw 'Loading data file "' + u + '" failed.'
                    }), N && ns(N)
                }
                var b = {
                        root: null,
                        mounts: [],
                        devices: {},
                        streams: [],
                        nextInode: 1,
                        nameTable: null,
                        currentPath: "/",
                        initialized: !1,
                        ignorePermissions: !0,
                        trackingDelegate: {},
                        tracking: {
                            openFlags: {
                                READ: 1,
                                WRITE: 2
                            }
                        },
                        ErrnoError: null,
                        genericErrors: {},
                        filesystems: null,
                        syncFSRequests: 0,
                        lookupPath: function(u, d) {
                            if (u = Fi.resolve(b.cwd(), u), d = d || {}, !u) return {
                                path: "",
                                node: null
                            };
                            var p = {
                                follow_mount: !0,
                                recurse_count: 0
                            };
                            for (var x in p) d[x] === void 0 && (d[x] = p[x]);
                            if (d.recurse_count > 8) throw new b.ErrnoError(32);
                            for (var N = ft.normalizeArray(u.split("/").filter(function(ce) {
                                    return !!ce
                                }), !1), T = b.root, _ = "/", D = 0; D < N.length; D++) {
                                var R = D === N.length - 1;
                                if (R && d.parent) break;
                                if (T = b.lookupNode(T, N[D]), _ = ft.join2(_, N[D]), b.isMountpoint(T) && (!R || R && d.follow_mount) && (T = T.mounted.root), !R || d.follow)
                                    for (var K = 0; b.isLink(T.mode);) {
                                        var ee = b.readlink(_);
                                        _ = Fi.resolve(ft.dirname(_), ee);
                                        var ue = b.lookupPath(_, {
                                            recurse_count: d.recurse_count
                                        });
                                        if (T = ue.node, K++ > 40) throw new b.ErrnoError(32)
                                    }
                            }
                            return {
                                path: _,
                                node: T
                            }
                        },
                        getPath: function(u) {
                            for (var d;;) {
                                if (b.isRoot(u)) {
                                    var p = u.mount.mountpoint;
                                    return d ? p[p.length - 1] !== "/" ? p + "/" + d : p + d : p
                                }
                                d = d ? u.name + "/" + d : u.name, u = u.parent
                            }
                        },
                        hashName: function(u, d) {
                            for (var p = 0, x = 0; x < d.length; x++) p = (p << 5) - p + d.charCodeAt(x) | 0;
                            return (u + p >>> 0) % b.nameTable.length
                        },
                        hashAddNode: function(u) {
                            var d = b.hashName(u.parent.id, u.name);
                            u.name_next = b.nameTable[d], b.nameTable[d] = u
                        },
                        hashRemoveNode: function(u) {
                            var d = b.hashName(u.parent.id, u.name);
                            if (b.nameTable[d] === u) b.nameTable[d] = u.name_next;
                            else
                                for (var p = b.nameTable[d]; p;) {
                                    if (p.name_next === u) {
                                        p.name_next = u.name_next;
                                        break
                                    }
                                    p = p.name_next
                                }
                        },
                        lookupNode: function(u, d) {
                            var p = b.mayLookup(u);
                            if (p) throw new b.ErrnoError(p, u);
                            for (var x = b.hashName(u.id, d), N = b.nameTable[x]; N; N = N.name_next) {
                                var T = N.name;
                                if (N.parent.id === u.id && T === d) return N
                            }
                            return b.lookup(u, d)
                        },
                        createNode: function(u, d, p, x) {
                            var N = new b.FSNode(u, d, p, x);
                            return b.hashAddNode(N), N
                        },
                        destroyNode: function(u) {
                            b.hashRemoveNode(u)
                        },
                        isRoot: function(u) {
                            return u === u.parent
                        },
                        isMountpoint: function(u) {
                            return !!u.mounted
                        },
                        isFile: function(u) {
                            return (u & 61440) == 32768
                        },
                        isDir: function(u) {
                            return (u & 61440) == 16384
                        },
                        isLink: function(u) {
                            return (u & 61440) == 40960
                        },
                        isChrdev: function(u) {
                            return (u & 61440) == 8192
                        },
                        isBlkdev: function(u) {
                            return (u & 61440) == 24576
                        },
                        isFIFO: function(u) {
                            return (u & 61440) == 4096
                        },
                        isSocket: function(u) {
                            return (u & 49152) == 49152
                        },
                        flagModes: {
                            r: 0,
                            "r+": 2,
                            w: 577,
                            "w+": 578,
                            a: 1089,
                            "a+": 1090
                        },
                        modeStringToFlags: function(u) {
                            var d = b.flagModes[u];
                            if (typeof d == "undefined") throw new Error("Unknown file open mode: " + u);
                            return d
                        },
                        flagsToPermissionString: function(u) {
                            var d = ["r", "w", "rw"][u & 3];
                            return u & 512 && (d += "w"), d
                        },
                        nodePermissions: function(u, d) {
                            return b.ignorePermissions ? 0 : d.includes("r") && !(u.mode & 292) || d.includes("w") && !(u.mode & 146) || d.includes("x") && !(u.mode & 73) ? 2 : 0
                        },
                        mayLookup: function(u) {
                            var d = b.nodePermissions(u, "x");
                            return d || (u.node_ops.lookup ? 0 : 2)
                        },
                        mayCreate: function(u, d) {
                            try {
                                var p = b.lookupNode(u, d);
                                return 20
                            } catch (x) {}
                            return b.nodePermissions(u, "wx")
                        },
                        mayDelete: function(u, d, p) {
                            var x;
                            try {
                                x = b.lookupNode(u, d)
                            } catch (T) {
                                return T.errno
                            }
                            var N = b.nodePermissions(u, "wx");
                            if (N) return N;
                            if (p) {
                                if (!b.isDir(x.mode)) return 54;
                                if (b.isRoot(x) || b.getPath(x) === b.cwd()) return 10
                            } else if (b.isDir(x.mode)) return 31;
                            return 0
                        },
                        mayOpen: function(u, d) {
                            return u ? b.isLink(u.mode) ? 32 : b.isDir(u.mode) && (b.flagsToPermissionString(d) !== "r" || d & 512) ? 31 : b.nodePermissions(u, b.flagsToPermissionString(d)) : 44
                        },
                        MAX_OPEN_FDS: 4096,
                        nextfd: function(u, d) {
                            u = u || 0, d = d || b.MAX_OPEN_FDS;
                            for (var p = u; p <= d; p++)
                                if (!b.streams[p]) return p;
                            throw new b.ErrnoError(33)
                        },
                        getStream: function(u) {
                            return b.streams[u]
                        },
                        createStream: function(u, d, p) {
                            b.FSStream || (b.FSStream = function() {}, b.FSStream.prototype = {
                                object: {
                                    get: function() {
                                        return this.node
                                    },
                                    set: function(_) {
                                        this.node = _
                                    }
                                },
                                isRead: {
                                    get: function() {
                                        return (this.flags & 2097155) != 1
                                    }
                                },
                                isWrite: {
                                    get: function() {
                                        return (this.flags & 2097155) != 0
                                    }
                                },
                                isAppend: {
                                    get: function() {
                                        return this.flags & 1024
                                    }
                                }
                            });
                            var x = new b.FSStream;
                            for (var N in u) x[N] = u[N];
                            u = x;
                            var T = b.nextfd(d, p);
                            return u.fd = T, b.streams[T] = u, u
                        },
                        closeStream: function(u) {
                            b.streams[u] = null
                        },
                        chrdev_stream_ops: {
                            open: function(u) {
                                var d = b.getDevice(u.node.rdev);
                                u.stream_ops = d.stream_ops, u.stream_ops.open && u.stream_ops.open(u)
                            },
                            llseek: function() {
                                throw new b.ErrnoError(70)
                            }
                        },
                        major: function(u) {
                            return u >> 8
                        },
                        minor: function(u) {
                            return u & 255
                        },
                        makedev: function(u, d) {
                            return u << 8 | d
                        },
                        registerDevice: function(u, d) {
                            b.devices[u] = {
                                stream_ops: d
                            }
                        },
                        getDevice: function(u) {
                            return b.devices[u]
                        },
                        getMounts: function(u) {
                            for (var d = [], p = [u]; p.length;) {
                                var x = p.pop();
                                d.push(x), p.push.apply(p, x.mounts)
                            }
                            return d
                        },
                        syncfs: function(u, d) {
                            typeof u == "function" && (d = u, u = !1), b.syncFSRequests++, b.syncFSRequests > 1 && C("warning: " + b.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
                            var p = b.getMounts(b.root.mount),
                                x = 0;

                            function N(_) {
                                return b.syncFSRequests--, d(_)
                            }

                            function T(_) {
                                if (_) return T.errored ? void 0 : (T.errored = !0, N(_));
                                ++x >= p.length && N(null)
                            }
                            p.forEach(function(_) {
                                if (!_.type.syncfs) return T(null);
                                _.type.syncfs(_, u, T)
                            })
                        },
                        mount: function(u, d, p) {
                            var x = p === "/",
                                N = !p,
                                T;
                            if (x && b.root) throw new b.ErrnoError(10);
                            if (!x && !N) {
                                var _ = b.lookupPath(p, {
                                    follow_mount: !1
                                });
                                if (p = _.path, T = _.node, b.isMountpoint(T)) throw new b.ErrnoError(10);
                                if (!b.isDir(T.mode)) throw new b.ErrnoError(54)
                            }
                            var D = {
                                    type: u,
                                    opts: d,
                                    mountpoint: p,
                                    mounts: []
                                },
                                R = u.mount(D);
                            return R.mount = D, D.root = R, x ? b.root = R : T && (T.mounted = D, T.mount && T.mount.mounts.push(D)), R
                        },
                        unmount: function(u) {
                            var d = b.lookupPath(u, {
                                follow_mount: !1
                            });
                            if (!b.isMountpoint(d.node)) throw new b.ErrnoError(28);
                            var p = d.node,
                                x = p.mounted,
                                N = b.getMounts(x);
                            Object.keys(b.nameTable).forEach(function(_) {
                                for (var D = b.nameTable[_]; D;) {
                                    var R = D.name_next;
                                    N.includes(D.mount) && b.destroyNode(D), D = R
                                }
                            }), p.mounted = null;
                            var T = p.mount.mounts.indexOf(x);
                            p.mount.mounts.splice(T, 1)
                        },
                        lookup: function(u, d) {
                            return u.node_ops.lookup(u, d)
                        },
                        mknod: function(u, d, p) {
                            var x = b.lookupPath(u, {
                                    parent: !0
                                }),
                                N = x.node,
                                T = ft.basename(u);
                            if (!T || T === "." || T === "..") throw new b.ErrnoError(28);
                            var _ = b.mayCreate(N, T);
                            if (_) throw new b.ErrnoError(_);
                            if (!N.node_ops.mknod) throw new b.ErrnoError(63);
                            return N.node_ops.mknod(N, T, d, p)
                        },
                        create: function(u, d) {
                            return d = d !== void 0 ? d : 438, d &= 4095, d |= 32768, b.mknod(u, d, 0)
                        },
                        mkdir: function(u, d) {
                            return d = d !== void 0 ? d : 511, d &= 511 | 512, d |= 16384, b.mknod(u, d, 0)
                        },
                        mkdirTree: function(u, d) {
                            for (var p = u.split("/"), x = "", N = 0; N < p.length; ++N)
                                if (!!p[N]) {
                                    x += "/" + p[N];
                                    try {
                                        b.mkdir(x, d)
                                    } catch (T) {
                                        if (T.errno != 20) throw T
                                    }
                                }
                        },
                        mkdev: function(u, d, p) {
                            return typeof p == "undefined" && (p = d, d = 438), d |= 8192, b.mknod(u, d, p)
                        },
                        symlink: function(u, d) {
                            if (!Fi.resolve(u)) throw new b.ErrnoError(44);
                            var p = b.lookupPath(d, {
                                    parent: !0
                                }),
                                x = p.node;
                            if (!x) throw new b.ErrnoError(44);
                            var N = ft.basename(d),
                                T = b.mayCreate(x, N);
                            if (T) throw new b.ErrnoError(T);
                            if (!x.node_ops.symlink) throw new b.ErrnoError(63);
                            return x.node_ops.symlink(x, N, u)
                        },
                        rename: function(u, d) {
                            var p = ft.dirname(u),
                                x = ft.dirname(d),
                                N = ft.basename(u),
                                T = ft.basename(d),
                                _, D, R;
                            if (_ = b.lookupPath(u, {
                                    parent: !0
                                }), D = _.node, _ = b.lookupPath(d, {
                                    parent: !0
                                }), R = _.node, !D || !R) throw new b.ErrnoError(44);
                            if (D.mount !== R.mount) throw new b.ErrnoError(75);
                            var K = b.lookupNode(D, N),
                                ee = Fi.relative(u, x);
                            if (ee.charAt(0) !== ".") throw new b.ErrnoError(28);
                            if (ee = Fi.relative(d, p), ee.charAt(0) !== ".") throw new b.ErrnoError(55);
                            var ue;
                            try {
                                ue = b.lookupNode(R, T)
                            } catch (ge) {}
                            if (K !== ue) {
                                var ce = b.isDir(K.mode),
                                    de = b.mayDelete(D, N, ce);
                                if (de) throw new b.ErrnoError(de);
                                if (de = ue ? b.mayDelete(R, T, ce) : b.mayCreate(R, T), de) throw new b.ErrnoError(de);
                                if (!D.node_ops.rename) throw new b.ErrnoError(63);
                                if (b.isMountpoint(K) || ue && b.isMountpoint(ue)) throw new b.ErrnoError(10);
                                if (R !== D && (de = b.nodePermissions(D, "w"), de)) throw new b.ErrnoError(de);
                                try {
                                    b.trackingDelegate.willMovePath && b.trackingDelegate.willMovePath(u, d)
                                } catch (ge) {
                                    C("FS.trackingDelegate['willMovePath']('" + u + "', '" + d + "') threw an exception: " + ge.message)
                                }
                                b.hashRemoveNode(K);
                                try {
                                    D.node_ops.rename(K, R, T)
                                } catch (ge) {
                                    throw ge
                                } finally {
                                    b.hashAddNode(K)
                                }
                                try {
                                    b.trackingDelegate.onMovePath && b.trackingDelegate.onMovePath(u, d)
                                } catch (ge) {
                                    C("FS.trackingDelegate['onMovePath']('" + u + "', '" + d + "') threw an exception: " + ge.message)
                                }
                            }
                        },
                        rmdir: function(u) {
                            var d = b.lookupPath(u, {
                                    parent: !0
                                }),
                                p = d.node,
                                x = ft.basename(u),
                                N = b.lookupNode(p, x),
                                T = b.mayDelete(p, x, !0);
                            if (T) throw new b.ErrnoError(T);
                            if (!p.node_ops.rmdir) throw new b.ErrnoError(63);
                            if (b.isMountpoint(N)) throw new b.ErrnoError(10);
                            try {
                                b.trackingDelegate.willDeletePath && b.trackingDelegate.willDeletePath(u)
                            } catch (_) {
                                C("FS.trackingDelegate['willDeletePath']('" + u + "') threw an exception: " + _.message)
                            }
                            p.node_ops.rmdir(p, x), b.destroyNode(N);
                            try {
                                b.trackingDelegate.onDeletePath && b.trackingDelegate.onDeletePath(u)
                            } catch (_) {
                                C("FS.trackingDelegate['onDeletePath']('" + u + "') threw an exception: " + _.message)
                            }
                        },
                        readdir: function(u) {
                            var d = b.lookupPath(u, {
                                    follow: !0
                                }),
                                p = d.node;
                            if (!p.node_ops.readdir) throw new b.ErrnoError(54);
                            return p.node_ops.readdir(p)
                        },
                        unlink: function(u) {
                            var d = b.lookupPath(u, {
                                    parent: !0
                                }),
                                p = d.node,
                                x = ft.basename(u),
                                N = b.lookupNode(p, x),
                                T = b.mayDelete(p, x, !1);
                            if (T) throw new b.ErrnoError(T);
                            if (!p.node_ops.unlink) throw new b.ErrnoError(63);
                            if (b.isMountpoint(N)) throw new b.ErrnoError(10);
                            try {
                                b.trackingDelegate.willDeletePath && b.trackingDelegate.willDeletePath(u)
                            } catch (_) {
                                C("FS.trackingDelegate['willDeletePath']('" + u + "') threw an exception: " + _.message)
                            }
                            p.node_ops.unlink(p, x), b.destroyNode(N);
                            try {
                                b.trackingDelegate.onDeletePath && b.trackingDelegate.onDeletePath(u)
                            } catch (_) {
                                C("FS.trackingDelegate['onDeletePath']('" + u + "') threw an exception: " + _.message)
                            }
                        },
                        readlink: function(u) {
                            var d = b.lookupPath(u),
                                p = d.node;
                            if (!p) throw new b.ErrnoError(44);
                            if (!p.node_ops.readlink) throw new b.ErrnoError(28);
                            return Fi.resolve(b.getPath(p.parent), p.node_ops.readlink(p))
                        },
                        stat: function(u, d) {
                            var p = b.lookupPath(u, {
                                    follow: !d
                                }),
                                x = p.node;
                            if (!x) throw new b.ErrnoError(44);
                            if (!x.node_ops.getattr) throw new b.ErrnoError(63);
                            return x.node_ops.getattr(x)
                        },
                        lstat: function(u) {
                            return b.stat(u, !0)
                        },
                        chmod: function(u, d, p) {
                            var x;
                            if (typeof u == "string") {
                                var N = b.lookupPath(u, {
                                    follow: !p
                                });
                                x = N.node
                            } else x = u;
                            if (!x.node_ops.setattr) throw new b.ErrnoError(63);
                            x.node_ops.setattr(x, {
                                mode: d & 4095 | x.mode & ~4095,
                                timestamp: Date.now()
                            })
                        },
                        lchmod: function(u, d) {
                            b.chmod(u, d, !0)
                        },
                        fchmod: function(u, d) {
                            var p = b.getStream(u);
                            if (!p) throw new b.ErrnoError(8);
                            b.chmod(p.node, d)
                        },
                        chown: function(u, d, p, x) {
                            var N;
                            if (typeof u == "string") {
                                var T = b.lookupPath(u, {
                                    follow: !x
                                });
                                N = T.node
                            } else N = u;
                            if (!N.node_ops.setattr) throw new b.ErrnoError(63);
                            N.node_ops.setattr(N, {
                                timestamp: Date.now()
                            })
                        },
                        lchown: function(u, d, p) {
                            b.chown(u, d, p, !0)
                        },
                        fchown: function(u, d, p) {
                            var x = b.getStream(u);
                            if (!x) throw new b.ErrnoError(8);
                            b.chown(x.node, d, p)
                        },
                        truncate: function(u, d) {
                            if (d < 0) throw new b.ErrnoError(28);
                            var p;
                            if (typeof u == "string") {
                                var x = b.lookupPath(u, {
                                    follow: !0
                                });
                                p = x.node
                            } else p = u;
                            if (!p.node_ops.setattr) throw new b.ErrnoError(63);
                            if (b.isDir(p.mode)) throw new b.ErrnoError(31);
                            if (!b.isFile(p.mode)) throw new b.ErrnoError(28);
                            var N = b.nodePermissions(p, "w");
                            if (N) throw new b.ErrnoError(N);
                            p.node_ops.setattr(p, {
                                size: d,
                                timestamp: Date.now()
                            })
                        },
                        ftruncate: function(u, d) {
                            var p = b.getStream(u);
                            if (!p) throw new b.ErrnoError(8);
                            if ((p.flags & 2097155) == 0) throw new b.ErrnoError(28);
                            b.truncate(p.node, d)
                        },
                        utime: function(u, d, p) {
                            var x = b.lookupPath(u, {
                                    follow: !0
                                }),
                                N = x.node;
                            N.node_ops.setattr(N, {
                                timestamp: Math.max(d, p)
                            })
                        },
                        open: function(u, d, p, x, N) {
                            if (u === "") throw new b.ErrnoError(44);
                            d = typeof d == "string" ? b.modeStringToFlags(d) : d, p = typeof p == "undefined" ? 438 : p, d & 64 ? p = p & 4095 | 32768 : p = 0;
                            var T;
                            if (typeof u == "object") T = u;
                            else {
                                u = ft.normalize(u);
                                try {
                                    var _ = b.lookupPath(u, {
                                        follow: !(d & 131072)
                                    });
                                    T = _.node
                                } catch (ue) {}
                            }
                            var D = !1;
                            if (d & 64)
                                if (T) {
                                    if (d & 128) throw new b.ErrnoError(20)
                                } else T = b.mknod(u, p, 0), D = !0;
                            if (!T) throw new b.ErrnoError(44);
                            if (b.isChrdev(T.mode) && (d &= ~512), d & 65536 && !b.isDir(T.mode)) throw new b.ErrnoError(54);
                            if (!D) {
                                var R = b.mayOpen(T, d);
                                if (R) throw new b.ErrnoError(R)
                            }
                            d & 512 && b.truncate(T, 0), d &= ~(128 | 512 | 131072);
                            var K = b.createStream({
                                node: T,
                                path: b.getPath(T),
                                flags: d,
                                seekable: !0,
                                position: 0,
                                stream_ops: T.stream_ops,
                                ungotten: [],
                                error: !1
                            }, x, N);
                            K.stream_ops.open && K.stream_ops.open(K), e.logReadFiles && !(d & 1) && (b.readFiles || (b.readFiles = {}), u in b.readFiles || (b.readFiles[u] = 1, C("FS.trackingDelegate error on read file: " + u)));
                            try {
                                if (b.trackingDelegate.onOpenFile) {
                                    var ee = 0;
                                    (d & 2097155) != 1 && (ee |= b.tracking.openFlags.READ), (d & 2097155) != 0 && (ee |= b.tracking.openFlags.WRITE), b.trackingDelegate.onOpenFile(u, ee)
                                }
                            } catch (ue) {
                                C("FS.trackingDelegate['onOpenFile']('" + u + "', flags) threw an exception: " + ue.message)
                            }
                            return K
                        },
                        close: function(u) {
                            if (b.isClosed(u)) throw new b.ErrnoError(8);
                            u.getdents && (u.getdents = null);
                            try {
                                u.stream_ops.close && u.stream_ops.close(u)
                            } catch (d) {
                                throw d
                            } finally {
                                b.closeStream(u.fd)
                            }
                            u.fd = null
                        },
                        isClosed: function(u) {
                            return u.fd === null
                        },
                        llseek: function(u, d, p) {
                            if (b.isClosed(u)) throw new b.ErrnoError(8);
                            if (!u.seekable || !u.stream_ops.llseek) throw new b.ErrnoError(70);
                            if (p != 0 && p != 1 && p != 2) throw new b.ErrnoError(28);
                            return u.position = u.stream_ops.llseek(u, d, p), u.ungotten = [], u.position
                        },
                        read: function(u, d, p, x, N) {
                            if (x < 0 || N < 0) throw new b.ErrnoError(28);
                            if (b.isClosed(u)) throw new b.ErrnoError(8);
                            if ((u.flags & 2097155) == 1) throw new b.ErrnoError(8);
                            if (b.isDir(u.node.mode)) throw new b.ErrnoError(31);
                            if (!u.stream_ops.read) throw new b.ErrnoError(28);
                            var T = typeof N != "undefined";
                            if (!T) N = u.position;
                            else if (!u.seekable) throw new b.ErrnoError(70);
                            var _ = u.stream_ops.read(u, d, p, x, N);
                            return T || (u.position += _), _
                        },
                        write: function(u, d, p, x, N, T) {
                            if (x < 0 || N < 0) throw new b.ErrnoError(28);
                            if (b.isClosed(u)) throw new b.ErrnoError(8);
                            if ((u.flags & 2097155) == 0) throw new b.ErrnoError(8);
                            if (b.isDir(u.node.mode)) throw new b.ErrnoError(31);
                            if (!u.stream_ops.write) throw new b.ErrnoError(28);
                            u.seekable && u.flags & 1024 && b.llseek(u, 0, 2);
                            var _ = typeof N != "undefined";
                            if (!_) N = u.position;
                            else if (!u.seekable) throw new b.ErrnoError(70);
                            var D = u.stream_ops.write(u, d, p, x, N, T);
                            _ || (u.position += D);
                            try {
                                u.path && b.trackingDelegate.onWriteToFile && b.trackingDelegate.onWriteToFile(u.path)
                            } catch (R) {
                                C("FS.trackingDelegate['onWriteToFile']('" + u.path + "') threw an exception: " + R.message)
                            }
                            return D
                        },
                        allocate: function(u, d, p) {
                            if (b.isClosed(u)) throw new b.ErrnoError(8);
                            if (d < 0 || p <= 0) throw new b.ErrnoError(28);
                            if ((u.flags & 2097155) == 0) throw new b.ErrnoError(8);
                            if (!b.isFile(u.node.mode) && !b.isDir(u.node.mode)) throw new b.ErrnoError(43);
                            if (!u.stream_ops.allocate) throw new b.ErrnoError(138);
                            u.stream_ops.allocate(u, d, p)
                        },
                        mmap: function(u, d, p, x, N, T) {
                            if ((N & 2) != 0 && (T & 2) == 0 && (u.flags & 2097155) != 2) throw new b.ErrnoError(2);
                            if ((u.flags & 2097155) == 1) throw new b.ErrnoError(2);
                            if (!u.stream_ops.mmap) throw new b.ErrnoError(43);
                            return u.stream_ops.mmap(u, d, p, x, N, T)
                        },
                        msync: function(u, d, p, x, N) {
                            return !u || !u.stream_ops.msync ? 0 : u.stream_ops.msync(u, d, p, x, N)
                        },
                        munmap: function(u) {
                            return 0
                        },
                        ioctl: function(u, d, p) {
                            if (!u.stream_ops.ioctl) throw new b.ErrnoError(59);
                            return u.stream_ops.ioctl(u, d, p)
                        },
                        readFile: function(u, d) {
                            if (d = d || {}, d.flags = d.flags || 0, d.encoding = d.encoding || "binary", d.encoding !== "utf8" && d.encoding !== "binary") throw new Error('Invalid encoding type "' + d.encoding + '"');
                            var p, x = b.open(u, d.flags),
                                N = b.stat(u),
                                T = N.size,
                                _ = new Uint8Array(T);
                            return b.read(x, _, 0, T, 0), d.encoding === "utf8" ? p = Z(_, 0) : d.encoding === "binary" && (p = _), b.close(x), p
                        },
                        writeFile: function(u, d, p) {
                            p = p || {}, p.flags = p.flags || 577;
                            var x = b.open(u, p.flags, p.mode);
                            if (typeof d == "string") {
                                var N = new Uint8Array(G(d) + 1),
                                    T = B(d, N, 0, N.length);
                                b.write(x, N, 0, T, void 0, p.canOwn)
                            } else if (ArrayBuffer.isView(d)) b.write(x, d, 0, d.byteLength, void 0, p.canOwn);
                            else throw new Error("Unsupported data type");
                            b.close(x)
                        },
                        cwd: function() {
                            return b.currentPath
                        },
                        chdir: function(u) {
                            var d = b.lookupPath(u, {
                                follow: !0
                            });
                            if (d.node === null) throw new b.ErrnoError(44);
                            if (!b.isDir(d.node.mode)) throw new b.ErrnoError(54);
                            var p = b.nodePermissions(d.node, "x");
                            if (p) throw new b.ErrnoError(p);
                            b.currentPath = d.path
                        },
                        createDefaultDirectories: function() {
                            b.mkdir("/tmp"), b.mkdir("/home"), b.mkdir("/home/web_user")
                        },
                        createDefaultDevices: function() {
                            b.mkdir("/dev"), b.registerDevice(b.makedev(1, 3), {
                                read: function() {
                                    return 0
                                },
                                write: function(d, p, x, N, T) {
                                    return N
                                }
                            }), b.mkdev("/dev/null", b.makedev(1, 3)), rn.register(b.makedev(5, 0), rn.default_tty_ops), rn.register(b.makedev(6, 0), rn.default_tty1_ops), b.mkdev("/dev/tty", b.makedev(5, 0)), b.mkdev("/dev/tty1", b.makedev(6, 0));
                            var u = ux();
                            b.createDevice("/dev", "random", u), b.createDevice("/dev", "urandom", u), b.mkdir("/dev/shm"), b.mkdir("/dev/shm/tmp")
                        },
                        createSpecialDirectories: function() {
                            b.mkdir("/proc");
                            var u = b.mkdir("/proc/self");
                            b.mkdir("/proc/self/fd"), b.mount({
                                mount: function() {
                                    var d = b.createNode(u, "fd", 16384 | 511, 73);
                                    return d.node_ops = {
                                        lookup: function(p, x) {
                                            var N = +x,
                                                T = b.getStream(N);
                                            if (!T) throw new b.ErrnoError(8);
                                            var _ = {
                                                parent: null,
                                                mount: {
                                                    mountpoint: "fake"
                                                },
                                                node_ops: {
                                                    readlink: function() {
                                                        return T.path
                                                    }
                                                }
                                            };
                                            return _.parent = _, _
                                        }
                                    }, d
                                }
                            }, {}, "/proc/self/fd")
                        },
                        createStandardStreams: function() {
                            e.stdin ? b.createDevice("/dev", "stdin", e.stdin) : b.symlink("/dev/tty", "/dev/stdin"), e.stdout ? b.createDevice("/dev", "stdout", null, e.stdout) : b.symlink("/dev/tty", "/dev/stdout"), e.stderr ? b.createDevice("/dev", "stderr", null, e.stderr) : b.symlink("/dev/tty1", "/dev/stderr");
                            var u = b.open("/dev/stdin", 0),
                                d = b.open("/dev/stdout", 1),
                                p = b.open("/dev/stderr", 1)
                        },
                        ensureErrnoError: function() {
                            b.ErrnoError || (b.ErrnoError = function(d, p) {
                                this.node = p, this.setErrno = function(x) {
                                    this.errno = x
                                }, this.setErrno(d), this.message = "FS error"
                            }, b.ErrnoError.prototype = new Error, b.ErrnoError.prototype.constructor = b.ErrnoError, [44].forEach(function(u) {
                                b.genericErrors[u] = new b.ErrnoError(u), b.genericErrors[u].stack = "<generic error, no stack>"
                            }))
                        },
                        staticInit: function() {
                            b.ensureErrnoError(), b.nameTable = new Array(4096), b.mount(Ue, {}, "/"), b.createDefaultDirectories(), b.createDefaultDevices(), b.createSpecialDirectories(), b.filesystems = {
                                MEMFS: Ue
                            }
                        },
                        init: function(u, d, p) {
                            b.init.initialized = !0, b.ensureErrnoError(), e.stdin = u || e.stdin, e.stdout = d || e.stdout, e.stderr = p || e.stderr, b.createStandardStreams()
                        },
                        quit: function() {
                            b.init.initialized = !1;
                            var u = e._fflush;
                            u && u(0);
                            for (var d = 0; d < b.streams.length; d++) {
                                var p = b.streams[d];
                                !p || b.close(p)
                            }
                        },
                        getMode: function(u, d) {
                            var p = 0;
                            return u && (p |= 292 | 73), d && (p |= 146), p
                        },
                        findObject: function(u, d) {
                            var p = b.analyzePath(u, d);
                            return p.exists ? p.object : null
                        },
                        analyzePath: function(u, d) {
                            try {
                                var p = b.lookupPath(u, {
                                    follow: !d
                                });
                                u = p.path
                            } catch (N) {}
                            var x = {
                                isRoot: !1,
                                exists: !1,
                                error: 0,
                                name: null,
                                path: null,
                                object: null,
                                parentExists: !1,
                                parentPath: null,
                                parentObject: null
                            };
                            try {
                                var p = b.lookupPath(u, {
                                    parent: !0
                                });
                                x.parentExists = !0, x.parentPath = p.path, x.parentObject = p.node, x.name = ft.basename(u), p = b.lookupPath(u, {
                                    follow: !d
                                }), x.exists = !0, x.path = p.path, x.object = p.node, x.name = p.node.name, x.isRoot = p.path === "/"
                            } catch (N) {
                                x.error = N.errno
                            }
                            return x
                        },
                        createPath: function(u, d, p, x) {
                            u = typeof u == "string" ? u : b.getPath(u);
                            for (var N = d.split("/").reverse(); N.length;) {
                                var T = N.pop();
                                if (!!T) {
                                    var _ = ft.join2(u, T);
                                    try {
                                        b.mkdir(_)
                                    } catch (D) {}
                                    u = _
                                }
                            }
                            return _
                        },
                        createFile: function(u, d, p, x, N) {
                            var T = ft.join2(typeof u == "string" ? u : b.getPath(u), d),
                                _ = b.getMode(x, N);
                            return b.create(T, _)
                        },
                        createDataFile: function(u, d, p, x, N, T) {
                            var _ = d ? ft.join2(typeof u == "string" ? u : b.getPath(u), d) : u,
                                D = b.getMode(x, N),
                                R = b.create(_, D);
                            if (p) {
                                if (typeof p == "string") {
                                    for (var K = new Array(p.length), ee = 0, ue = p.length; ee < ue; ++ee) K[ee] = p.charCodeAt(ee);
                                    p = K
                                }
                                b.chmod(R, D | 146);
                                var ce = b.open(R, 577);
                                b.write(ce, p, 0, p.length, 0, T), b.close(ce), b.chmod(R, D)
                            }
                            return R
                        },
                        createDevice: function(u, d, p, x) {
                            var N = ft.join2(typeof u == "string" ? u : b.getPath(u), d),
                                T = b.getMode(!!p, !!x);
                            b.createDevice.major || (b.createDevice.major = 64);
                            var _ = b.makedev(b.createDevice.major++, 0);
                            return b.registerDevice(_, {
                                open: function(D) {
                                    D.seekable = !1
                                },
                                close: function(D) {
                                    x && x.buffer && x.buffer.length && x(10)
                                },
                                read: function(D, R, K, ee, ue) {
                                    for (var ce = 0, de = 0; de < ee; de++) {
                                        var ge;
                                        try {
                                            ge = p()
                                        } catch (ze) {
                                            throw new b.ErrnoError(29)
                                        }
                                        if (ge === void 0 && ce === 0) throw new b.ErrnoError(6);
                                        if (ge == null) break;
                                        ce++, R[K + de] = ge
                                    }
                                    return ce && (D.node.timestamp = Date.now()), ce
                                },
                                write: function(D, R, K, ee, ue) {
                                    for (var ce = 0; ce < ee; ce++) try {
                                        x(R[K + ce])
                                    } catch (de) {
                                        throw new b.ErrnoError(29)
                                    }
                                    return ee && (D.node.timestamp = Date.now()), ce
                                }
                            }), b.mkdev(N, T, _)
                        },
                        forceLoadFile: function(u) {
                            if (u.isDevice || u.isFolder || u.link || u.contents) return !0;
                            if (typeof XMLHttpRequest != "undefined") throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
                            if (v) try {
                                u.contents = Za(v(u.url), !0), u.usedBytes = u.contents.length
                            } catch (d) {
                                throw new b.ErrnoError(29)
                            } else throw new Error("Cannot load without read() or XMLHttpRequest.")
                        },
                        createLazyFile: function(u, d, p, x, N) {
                            function T() {
                                this.lengthKnown = !1, this.chunks = []
                            }
                            if (T.prototype.get = function(ce) {
                                    if (!(ce > this.length - 1 || ce < 0)) {
                                        var de = ce % this.chunkSize,
                                            ge = ce / this.chunkSize | 0;
                                        return this.getter(ge)[de]
                                    }
                                }, T.prototype.setDataGetter = function(ce) {
                                    this.getter = ce
                                }, T.prototype.cacheLength = function() {
                                    var ce = new XMLHttpRequest;
                                    if (ce.open("HEAD", p, !1), ce.send(null), !(ce.status >= 200 && ce.status < 300 || ce.status === 304)) throw new Error("Couldn't load " + p + ". Status: " + ce.status);
                                    var de = Number(ce.getResponseHeader("Content-length")),
                                        ge, ze = (ge = ce.getResponseHeader("Accept-Ranges")) && ge === "bytes",
                                        Ke = (ge = ce.getResponseHeader("Content-Encoding")) && ge === "gzip",
                                        st = 1024 * 1024;
                                    ze || (st = de);
                                    var ae = function(ct, Xe) {
                                            if (ct > Xe) throw new Error("invalid range (" + ct + ", " + Xe + ") or no bytes requested!");
                                            if (Xe > de - 1) throw new Error("only " + de + " bytes available! programmer error!");
                                            var dt = new XMLHttpRequest;
                                            if (dt.open("GET", p, !1), de !== st && dt.setRequestHeader("Range", "bytes=" + ct + "-" + Xe), typeof Uint8Array != "undefined" && (dt.responseType = "arraybuffer"), dt.overrideMimeType && dt.overrideMimeType("text/plain; charset=x-user-defined"), dt.send(null), !(dt.status >= 200 && dt.status < 300 || dt.status === 304)) throw new Error("Couldn't load " + p + ". Status: " + dt.status);
                                            return dt.response !== void 0 ? new Uint8Array(dt.response || []) : Za(dt.responseText || "", !0)
                                        },
                                        me = this;
                                    me.setDataGetter(function(ct) {
                                        var Xe = ct * st,
                                            dt = (ct + 1) * st - 1;
                                        if (dt = Math.min(dt, de - 1), typeof me.chunks[ct] == "undefined" && (me.chunks[ct] = ae(Xe, dt)), typeof me.chunks[ct] == "undefined") throw new Error("doXHR failed!");
                                        return me.chunks[ct]
                                    }), (Ke || !de) && (st = de = 1, de = this.getter(0).length, st = de, w("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = de, this._chunkSize = st, this.lengthKnown = !0
                                }, typeof XMLHttpRequest != "undefined") {
                                if (!f) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
                                var _ = new T;
                                Object.defineProperties(_, {
                                    length: {
                                        get: function() {
                                            return this.lengthKnown || this.cacheLength(), this._length
                                        }
                                    },
                                    chunkSize: {
                                        get: function() {
                                            return this.lengthKnown || this.cacheLength(), this._chunkSize
                                        }
                                    }
                                });
                                var D = {
                                    isDevice: !1,
                                    contents: _
                                }
                            } else var D = {
                                isDevice: !1,
                                url: p
                            };
                            var R = b.createFile(u, d, D, x, N);
                            D.contents ? R.contents = D.contents : D.url && (R.contents = null, R.url = D.url), Object.defineProperties(R, {
                                usedBytes: {
                                    get: function() {
                                        return this.contents.length
                                    }
                                }
                            });
                            var K = {},
                                ee = Object.keys(R.stream_ops);
                            return ee.forEach(function(ue) {
                                var ce = R.stream_ops[ue];
                                K[ue] = function() {
                                    return b.forceLoadFile(R), ce.apply(null, arguments)
                                }
                            }), K.read = function(ce, de, ge, ze, Ke) {
                                b.forceLoadFile(R);
                                var st = ce.node.contents;
                                if (Ke >= st.length) return 0;
                                var ae = Math.min(st.length - Ke, ze);
                                if (st.slice)
                                    for (var me = 0; me < ae; me++) de[ge + me] = st[Ke + me];
                                else
                                    for (var me = 0; me < ae; me++) de[ge + me] = st.get(Ke + me);
                                return ae
                            }, R.stream_ops = K, R
                        },
                        createPreloadedFile: function(u, d, p, x, N, T, _, D, R, K) {
                            Browser.init();
                            var ee = d ? Fi.resolve(ft.join2(u, d)) : u,
                                ue = ho("cp " + ee);

                            function ce(de) {
                                function ge(Ke) {
                                    K && K(), D || b.createDataFile(u, d, Ke, x, N, R), T && T(), Sn(ue)
                                }
                                var ze = !1;
                                e.preloadPlugins.forEach(function(Ke) {
                                    ze || Ke.canHandle(ee) && (Ke.handle(de, ee, ge, function() {
                                        _ && _(), Sn(ue)
                                    }), ze = !0)
                                }), ze || ge(de)
                            }
                            ns(ue), typeof p == "string" ? dx(p, function(de) {
                                ce(de)
                            }, _) : ce(p)
                        },
                        indexedDB: function() {
                            return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB
                        },
                        DB_NAME: function() {
                            return "EM_FS_" + window.location.pathname
                        },
                        DB_VERSION: 20,
                        DB_STORE_NAME: "FILE_DATA",
                        saveFilesToDB: function(u, d, p) {
                            d = d || function() {}, p = p || function() {};
                            var x = b.indexedDB();
                            try {
                                var N = x.open(b.DB_NAME(), b.DB_VERSION)
                            } catch (T) {
                                return p(T)
                            }
                            N.onupgradeneeded = function() {
                                w("creating db");
                                var _ = N.result;
                                _.createObjectStore(b.DB_STORE_NAME)
                            }, N.onsuccess = function() {
                                var _ = N.result,
                                    D = _.transaction([b.DB_STORE_NAME], "readwrite"),
                                    R = D.objectStore(b.DB_STORE_NAME),
                                    K = 0,
                                    ee = 0,
                                    ue = u.length;

                                function ce() {
                                    ee == 0 ? d() : p()
                                }
                                u.forEach(function(de) {
                                    var ge = R.put(b.analyzePath(de).object.contents, de);
                                    ge.onsuccess = function() {
                                        K++, K + ee == ue && ce()
                                    }, ge.onerror = function() {
                                        ee++, K + ee == ue && ce()
                                    }
                                }), D.onerror = p
                            }, N.onerror = p
                        },
                        loadFilesFromDB: function(u, d, p) {
                            d = d || function() {}, p = p || function() {};
                            var x = b.indexedDB();
                            try {
                                var N = x.open(b.DB_NAME(), b.DB_VERSION)
                            } catch (T) {
                                return p(T)
                            }
                            N.onupgradeneeded = p, N.onsuccess = function() {
                                var _ = N.result;
                                try {
                                    var D = _.transaction([b.DB_STORE_NAME], "readonly")
                                } catch (de) {
                                    p(de);
                                    return
                                }
                                var R = D.objectStore(b.DB_STORE_NAME),
                                    K = 0,
                                    ee = 0,
                                    ue = u.length;

                                function ce() {
                                    ee == 0 ? d() : p()
                                }
                                u.forEach(function(de) {
                                    var ge = R.get(de);
                                    ge.onsuccess = function() {
                                        b.analyzePath(de).exists && b.unlink(de), b.createDataFile(ft.dirname(de), ft.basename(de), ge.result, !0, !0, !0), K++, K + ee == ue && ce()
                                    }, ge.onerror = function() {
                                        ee++, K + ee == ue && ce()
                                    }
                                }), D.onerror = p
                            }, N.onerror = p
                        }
                    },
                    nn = {
                        mappings: {},
                        DEFAULT_POLLMASK: 5,
                        umask: 511,
                        calculateAt: function(u, d, p) {
                            if (d[0] === "/") return d;
                            var x;
                            if (u === -100) x = b.cwd();
                            else {
                                var N = b.getStream(u);
                                if (!N) throw new b.ErrnoError(8);
                                x = N.path
                            }
                            if (d.length == 0) {
                                if (!p) throw new b.ErrnoError(44);
                                return x
                            }
                            return ft.join2(x, d)
                        },
                        doStat: function(u, d, p) {
                            try {
                                var x = u(d)
                            } catch (N) {
                                if (N && N.node && ft.normalize(d) !== ft.normalize(b.getPath(N.node))) return -54;
                                throw N
                            }
                            return q[p >> 2] = x.dev, q[p + 4 >> 2] = 0, q[p + 8 >> 2] = x.ino, q[p + 12 >> 2] = x.mode, q[p + 16 >> 2] = x.nlink, q[p + 20 >> 2] = x.uid, q[p + 24 >> 2] = x.gid, q[p + 28 >> 2] = x.rdev, q[p + 32 >> 2] = 0, Zt = [x.size >>> 0, (tt = x.size, +Math.abs(tt) >= 1 ? tt > 0 ? (Math.min(+Math.floor(tt / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tt - +(~~tt >>> 0)) / 4294967296) >>> 0 : 0)], q[p + 40 >> 2] = Zt[0], q[p + 44 >> 2] = Zt[1], q[p + 48 >> 2] = 4096, q[p + 52 >> 2] = x.blocks, q[p + 56 >> 2] = x.atime.getTime() / 1e3 | 0, q[p + 60 >> 2] = 0, q[p + 64 >> 2] = x.mtime.getTime() / 1e3 | 0, q[p + 68 >> 2] = 0, q[p + 72 >> 2] = x.ctime.getTime() / 1e3 | 0, q[p + 76 >> 2] = 0, Zt = [x.ino >>> 0, (tt = x.ino, +Math.abs(tt) >= 1 ? tt > 0 ? (Math.min(+Math.floor(tt / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tt - +(~~tt >>> 0)) / 4294967296) >>> 0 : 0)], q[p + 80 >> 2] = Zt[0], q[p + 84 >> 2] = Zt[1], 0
                        },
                        doMsync: function(u, d, p, x, N) {
                            var T = oe.slice(u, u + p);
                            b.msync(d, T, N, p, x)
                        },
                        doMkdir: function(u, d) {
                            return u = ft.normalize(u), u[u.length - 1] === "/" && (u = u.substr(0, u.length - 1)), b.mkdir(u, d, 0), 0
                        },
                        doMknod: function(u, d, p) {
                            switch (d & 61440) {
                                case 32768:
                                case 8192:
                                case 24576:
                                case 4096:
                                case 49152:
                                    break;
                                default:
                                    return -28
                            }
                            return b.mknod(u, d, p), 0
                        },
                        doReadlink: function(u, d, p) {
                            if (p <= 0) return -28;
                            var x = b.readlink(u),
                                N = Math.min(p, G(x)),
                                T = ie[d + N];
                            return U(x, d, p + 1), ie[d + N] = T, N
                        },
                        doAccess: function(u, d) {
                            if (d & ~7) return -28;
                            var p, x = b.lookupPath(u, {
                                follow: !0
                            });
                            if (p = x.node, !p) return -44;
                            var N = "";
                            return d & 4 && (N += "r"), d & 2 && (N += "w"), d & 1 && (N += "x"), N && b.nodePermissions(p, N) ? -2 : 0
                        },
                        doDup: function(u, d, p) {
                            var x = b.getStream(p);
                            return x && b.close(x), b.open(u, d, 0, p, p).fd
                        },
                        doReadv: function(u, d, p, x) {
                            for (var N = 0, T = 0; T < p; T++) {
                                var _ = q[d + T * 8 >> 2],
                                    D = q[d + (T * 8 + 4) >> 2],
                                    R = b.read(u, ie, _, D, x);
                                if (R < 0) return -1;
                                if (N += R, R < D) break
                            }
                            return N
                        },
                        doWritev: function(u, d, p, x) {
                            for (var N = 0, T = 0; T < p; T++) {
                                var _ = q[d + T * 8 >> 2],
                                    D = q[d + (T * 8 + 4) >> 2],
                                    R = b.write(u, ie, _, D, x);
                                if (R < 0) return -1;
                                N += R
                            }
                            return N
                        },
                        varargs: void 0,
                        get: function() {
                            nn.varargs += 4;
                            var u = q[nn.varargs - 4 >> 2];
                            return u
                        },
                        getStr: function(u) {
                            var d = le(u);
                            return d
                        },
                        getStreamFromFD: function(u) {
                            var d = b.getStream(u);
                            if (!d) throw new b.ErrnoError(8);
                            return d
                        },
                        get64: function(u, d) {
                            return u
                        }
                    };

                function hx(u, d) {
                    var p = 0;
                    return xo().forEach(function(x, N) {
                        var T = d + p;
                        q[u + N * 4 >> 2] = T, ye(x, T), p += x.length + 1
                    }), 0
                }

                function mx(u, d) {
                    var p = xo();
                    q[u >> 2] = p.length;
                    var x = 0;
                    return p.forEach(function(N) {
                        x += N.length + 1
                    }), q[d >> 2] = x, 0
                }

                function px(u) {
                    try {
                        var d = nn.getStreamFromFD(u);
                        return b.close(d), 0
                    } catch (p) {
                        return (typeof b == "undefined" || !(p instanceof b.ErrnoError)) && hr(p), p.errno
                    }
                }

                function gx(u, d, p, x) {
                    try {
                        var N = nn.getStreamFromFD(u),
                            T = nn.doReadv(N, d, p);
                        return q[x >> 2] = T, 0
                    } catch (_) {
                        return (typeof b == "undefined" || !(_ instanceof b.ErrnoError)) && hr(_), _.errno
                    }
                }

                function vx(u, d, p, x, N) {
                    try {
                        var T = nn.getStreamFromFD(u),
                            _ = 4294967296,
                            D = p * _ + (d >>> 0),
                            R = 9007199254740992;
                        return D <= -R || D >= R ? -61 : (b.llseek(T, D, x), Zt = [T.position >>> 0, (tt = T.position, +Math.abs(tt) >= 1 ? tt > 0 ? (Math.min(+Math.floor(tt / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tt - +(~~tt >>> 0)) / 4294967296) >>> 0 : 0)], q[N >> 2] = Zt[0], q[N + 4 >> 2] = Zt[1], T.getdents && D === 0 && x === 0 && (T.getdents = null), 0)
                    } catch (K) {
                        return (typeof b == "undefined" || !(K instanceof b.ErrnoError)) && hr(K), K.errno
                    }
                }

                function yx(u, d, p, x) {
                    try {
                        var N = nn.getStreamFromFD(u),
                            T = nn.doWritev(N, d, p);
                        return q[x >> 2] = T, 0
                    } catch (_) {
                        return (typeof b == "undefined" || !(_ instanceof b.ErrnoError)) && hr(_), _.errno
                    }
                }

                function xx(u) {
                    E(u)
                }

                function Ja(u) {
                    return u % 4 == 0 && (u % 100 != 0 || u % 400 == 0)
                }

                function Fc(u, d) {
                    for (var p = 0, x = 0; x <= d; p += u[x++]);
                    return p
                }
                var Qa = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                    Ya = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                function Ka(u, d) {
                    for (var p = new Date(u.getTime()); d > 0;) {
                        var x = Ja(p.getFullYear()),
                            N = p.getMonth(),
                            T = (x ? Qa : Ya)[N];
                        if (d > T - p.getDate()) d -= T - p.getDate() + 1, p.setDate(1), N < 11 ? p.setMonth(N + 1) : (p.setMonth(0), p.setFullYear(p.getFullYear() + 1));
                        else return p.setDate(p.getDate() + d), p
                    }
                    return p
                }

                function Ax(u, d, p, x) {
                    var N = q[x + 40 >> 2],
                        T = {
                            tm_sec: q[x >> 2],
                            tm_min: q[x + 4 >> 2],
                            tm_hour: q[x + 8 >> 2],
                            tm_mday: q[x + 12 >> 2],
                            tm_mon: q[x + 16 >> 2],
                            tm_year: q[x + 20 >> 2],
                            tm_wday: q[x + 24 >> 2],
                            tm_yday: q[x + 28 >> 2],
                            tm_isdst: q[x + 32 >> 2],
                            tm_gmtoff: q[x + 36 >> 2],
                            tm_zone: N ? le(N) : ""
                        },
                        _ = le(p),
                        D = {
                            "%c": "%a %b %d %H:%M:%S %Y",
                            "%D": "%m/%d/%y",
                            "%F": "%Y-%m-%d",
                            "%h": "%b",
                            "%r": "%I:%M:%S %p",
                            "%R": "%H:%M",
                            "%T": "%H:%M:%S",
                            "%x": "%m/%d/%y",
                            "%X": "%H:%M:%S",
                            "%Ec": "%c",
                            "%EC": "%C",
                            "%Ex": "%m/%d/%y",
                            "%EX": "%H:%M:%S",
                            "%Ey": "%y",
                            "%EY": "%Y",
                            "%Od": "%d",
                            "%Oe": "%e",
                            "%OH": "%H",
                            "%OI": "%I",
                            "%Om": "%m",
                            "%OM": "%M",
                            "%OS": "%S",
                            "%Ou": "%u",
                            "%OU": "%U",
                            "%OV": "%V",
                            "%Ow": "%w",
                            "%OW": "%W",
                            "%Oy": "%y"
                        };
                    for (var R in D) _ = _.replace(new RegExp(R, "g"), D[R]);
                    var K = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                        ee = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

                    function ue(ae, me, ct) {
                        for (var Xe = typeof ae == "number" ? ae.toString() : ae || ""; Xe.length < me;) Xe = ct[0] + Xe;
                        return Xe
                    }

                    function ce(ae, me) {
                        return ue(ae, me, "0")
                    }

                    function de(ae, me) {
                        function ct(dt) {
                            return dt < 0 ? -1 : dt > 0 ? 1 : 0
                        }
                        var Xe;
                        return (Xe = ct(ae.getFullYear() - me.getFullYear())) === 0 && (Xe = ct(ae.getMonth() - me.getMonth())) === 0 && (Xe = ct(ae.getDate() - me.getDate())), Xe
                    }

                    function ge(ae) {
                        switch (ae.getDay()) {
                            case 0:
                                return new Date(ae.getFullYear() - 1, 11, 29);
                            case 1:
                                return ae;
                            case 2:
                                return new Date(ae.getFullYear(), 0, 3);
                            case 3:
                                return new Date(ae.getFullYear(), 0, 2);
                            case 4:
                                return new Date(ae.getFullYear(), 0, 1);
                            case 5:
                                return new Date(ae.getFullYear() - 1, 11, 31);
                            case 6:
                                return new Date(ae.getFullYear() - 1, 11, 30)
                        }
                    }

                    function ze(ae) {
                        var me = Ka(new Date(ae.tm_year + 1900, 0, 1), ae.tm_yday),
                            ct = new Date(me.getFullYear(), 0, 4),
                            Xe = new Date(me.getFullYear() + 1, 0, 4),
                            dt = ge(ct),
                            $r = ge(Xe);
                        return de(dt, me) <= 0 ? de($r, me) <= 0 ? me.getFullYear() + 1 : me.getFullYear() : me.getFullYear() - 1
                    }
                    var Ke = {
                        "%a": function(ae) {
                            return K[ae.tm_wday].substring(0, 3)
                        },
                        "%A": function(ae) {
                            return K[ae.tm_wday]
                        },
                        "%b": function(ae) {
                            return ee[ae.tm_mon].substring(0, 3)
                        },
                        "%B": function(ae) {
                            return ee[ae.tm_mon]
                        },
                        "%C": function(ae) {
                            var me = ae.tm_year + 1900;
                            return ce(me / 100 | 0, 2)
                        },
                        "%d": function(ae) {
                            return ce(ae.tm_mday, 2)
                        },
                        "%e": function(ae) {
                            return ue(ae.tm_mday, 2, " ")
                        },
                        "%g": function(ae) {
                            return ze(ae).toString().substring(2)
                        },
                        "%G": function(ae) {
                            return ze(ae)
                        },
                        "%H": function(ae) {
                            return ce(ae.tm_hour, 2)
                        },
                        "%I": function(ae) {
                            var me = ae.tm_hour;
                            return me == 0 ? me = 12 : me > 12 && (me -= 12), ce(me, 2)
                        },
                        "%j": function(ae) {
                            return ce(ae.tm_mday + Fc(Ja(ae.tm_year + 1900) ? Qa : Ya, ae.tm_mon - 1), 3)
                        },
                        "%m": function(ae) {
                            return ce(ae.tm_mon + 1, 2)
                        },
                        "%M": function(ae) {
                            return ce(ae.tm_min, 2)
                        },
                        "%n": function() {
                            return `
`
                        },
                        "%p": function(ae) {
                            return ae.tm_hour >= 0 && ae.tm_hour < 12 ? "AM" : "PM"
                        },
                        "%S": function(ae) {
                            return ce(ae.tm_sec, 2)
                        },
                        "%t": function() {
                            return "	"
                        },
                        "%u": function(ae) {
                            return ae.tm_wday || 7
                        },
                        "%U": function(ae) {
                            var me = new Date(ae.tm_year + 1900, 0, 1),
                                ct = me.getDay() === 0 ? me : Ka(me, 7 - me.getDay()),
                                Xe = new Date(ae.tm_year + 1900, ae.tm_mon, ae.tm_mday);
                            if (de(ct, Xe) < 0) {
                                var dt = Fc(Ja(Xe.getFullYear()) ? Qa : Ya, Xe.getMonth() - 1) - 31,
                                    $r = 31 - ct.getDate(),
                                    Cn = $r + dt + Xe.getDate();
                                return ce(Math.ceil(Cn / 7), 2)
                            }
                            return de(ct, me) === 0 ? "01" : "00"
                        },
                        "%V": function(ae) {
                            var me = new Date(ae.tm_year + 1900, 0, 4),
                                ct = new Date(ae.tm_year + 1901, 0, 4),
                                Xe = ge(me),
                                dt = ge(ct),
                                $r = Ka(new Date(ae.tm_year + 1900, 0, 1), ae.tm_yday);
                            if (de($r, Xe) < 0) return "53";
                            if (de(dt, $r) <= 0) return "01";
                            var Cn;
                            return Xe.getFullYear() < ae.tm_year + 1900 ? Cn = ae.tm_yday + 32 - Xe.getDate() : Cn = ae.tm_yday + 1 - Xe.getDate(), ce(Math.ceil(Cn / 7), 2)
                        },
                        "%w": function(ae) {
                            return ae.tm_wday
                        },
                        "%W": function(ae) {
                            var me = new Date(ae.tm_year, 0, 1),
                                ct = me.getDay() === 1 ? me : Ka(me, me.getDay() === 0 ? 1 : 7 - me.getDay() + 1),
                                Xe = new Date(ae.tm_year + 1900, ae.tm_mon, ae.tm_mday);
                            if (de(ct, Xe) < 0) {
                                var dt = Fc(Ja(Xe.getFullYear()) ? Qa : Ya, Xe.getMonth() - 1) - 31,
                                    $r = 31 - ct.getDate(),
                                    Cn = $r + dt + Xe.getDate();
                                return ce(Math.ceil(Cn / 7), 2)
                            }
                            return de(ct, me) === 0 ? "01" : "00"
                        },
                        "%y": function(ae) {
                            return (ae.tm_year + 1900).toString().substring(2)
                        },
                        "%Y": function(ae) {
                            return ae.tm_year + 1900
                        },
                        "%z": function(ae) {
                            var me = ae.tm_gmtoff,
                                ct = me >= 0;
                            return me = Math.abs(me) / 60, me = me / 60 * 100 + me % 60, (ct ? "+" : "-") + String("0000" + me).slice(-4)
                        },
                        "%Z": function(ae) {
                            return ae.tm_zone
                        },
                        "%%": function() {
                            return "%"
                        }
                    };
                    for (var R in Ke) _.includes(R) && (_ = _.replace(new RegExp(R, "g"), Ke[R](T)));
                    var st = Za(_, !1);
                    return st.length > d ? 0 : (fe(st, u), st.length - 1)
                }

                function bx(u, d, p, x) {
                    return Ax(u, d, p, x)
                }
                jf = e.InternalError = Ec(Error, "InternalError"), ny(), ls = e.BindingError = Ec(Error, "BindingError"), hy(), My(), Ny(), Xf = e.UnboundTypeError = Ec(Error, "UnboundTypeError"), zy();
                var td = function(u, d, p, x) {
                        u || (u = this), this.parent = u, this.mount = u.mount, this.mounted = null, this.id = b.nextInode++, this.name = d, this.mode = p, this.node_ops = {}, this.stream_ops = {}, this.rdev = x
                    },
                    Xa = 292 | 73,
                    qa = 146;
                Object.defineProperties(td.prototype, {
                    read: {
                        get: function() {
                            return (this.mode & Xa) === Xa
                        },
                        set: function(u) {
                            u ? this.mode |= Xa : this.mode &= ~Xa
                        }
                    },
                    write: {
                        get: function() {
                            return (this.mode & qa) === qa
                        },
                        set: function(u) {
                            u ? this.mode |= qa : this.mode &= ~qa
                        }
                    },
                    isFolder: {
                        get: function() {
                            return b.isDir(this.mode)
                        }
                    },
                    isDevice: {
                        get: function() {
                            return b.isChrdev(this.mode)
                        }
                    }
                }), b.FSNode = td, b.staticInit();

                function Za(u, d, p) {
                    var x = p > 0 ? p : G(u) + 1,
                        N = new Array(x),
                        T = B(u, N, 0, N.length);
                    return d && (N.length = T), N
                }
                var wx = {
                        c: ss,
                        d: Zv,
                        m: ty,
                        t: ry,
                        y: iy,
                        I: sy,
                        h: Dy,
                        g: Py,
                        b: Oy,
                        p: Ry,
                        H: ky,
                        s: jy,
                        l: Vy,
                        v: Wy,
                        a: Jy,
                        i: Yy,
                        f: Ky,
                        w: Xy,
                        r: qy,
                        n: Zy,
                        e: $y,
                        o: ex,
                        j: tx,
                        J: rx,
                        K: $f,
                        L: ix,
                        k: nx,
                        u: sx,
                        A: ox,
                        q: lx,
                        C: hx,
                        D: mx,
                        G: px,
                        E: gx,
                        x: vx,
                        F: yx,
                        z: xx,
                        B: bx
                    },
                    pC = wt(),
                    Sx = e.___wasm_call_ctors = function() {
                        return (Sx = e.___wasm_call_ctors = e.asm.N).apply(null, arguments)
                    },
                    $a = e._malloc = function() {
                        return ($a = e._malloc = e.asm.P).apply(null, arguments)
                    },
                    Gi = e._free = function() {
                        return (Gi = e._free = e.asm.Q).apply(null, arguments)
                    },
                    rd = e.___getTypeName = function() {
                        return (rd = e.___getTypeName = e.asm.R).apply(null, arguments)
                    },
                    Nx = e.___embind_register_native_and_builtin_types = function() {
                        return (Nx = e.___embind_register_native_and_builtin_types = e.asm.S).apply(null, arguments)
                    },
                    id = e.stackSave = function() {
                        return (id = e.stackSave = e.asm.T).apply(null, arguments)
                    },
                    nd = e.stackRestore = function() {
                        return (nd = e.stackRestore = e.asm.U).apply(null, arguments)
                    },
                    Gc = e.stackAlloc = function() {
                        return (Gc = e.stackAlloc = e.asm.V).apply(null, arguments)
                    },
                    Cx = e.dynCall_jiji = function() {
                        return (Cx = e.dynCall_jiji = e.asm.W).apply(null, arguments)
                    },
                    Tx = e.dynCall_iiiiij = function() {
                        return (Tx = e.dynCall_iiiiij = e.asm.X).apply(null, arguments)
                    },
                    Ex = e.dynCall_iiiiijj = function() {
                        return (Ex = e.dynCall_iiiiijj = e.asm.Y).apply(null, arguments)
                    },
                    Mx = e.dynCall_iiiiiijj = function() {
                        return (Mx = e.dynCall_iiiiiijj = e.asm.Z).apply(null, arguments)
                    },
                    _x = e.dynCall_viijii = function() {
                        return (_x = e.dynCall_viijii = e.asm._).apply(null, arguments)
                    };
                e.ccall = Q;
                var el;
                en = function u() {
                    el || zc(), el || (en = u)
                };

                function zc(u) {
                    if (u = u || o, Kr > 0 || (tr(), Kr > 0)) return;

                    function d() {
                        el || (el = !0, e.calledRun = !0, !z && (rr(), t(e), e.onRuntimeInitialized && e.onRuntimeInitialized(), dr()))
                    }
                    e.setStatus ? (e.setStatus("Running..."), setTimeout(function() {
                        setTimeout(function() {
                            e.setStatus("")
                        }, 1), d()
                    }, 1)) : d()
                }
                if (e.run = zc, e.preInit)
                    for (typeof e.preInit == "function" && (e.preInit = [e.preInit]); e.preInit.length > 0;) e.preInit.pop()();
                return zc(), e.ready
            }
        }(),
        Ah = y0;
    var x0 = Ah(),
        We;
    x0.then(n => We = n, () => {});
    var Gn = new Lt.Vector3,
        Fs = new Lt.Matrix4;

    function bh(n, ...e) {
        let t = 0;
        for (let s of e) t += s.length;
        let r = new n(t),
            i = 0;
        for (let s of e) r.set(s, i), i += s.length;
        return r
    }
    var Yo, Si = (Yo = class {
        static create(n) {
            return this.build(this.normalizeInputs(n))
        }
        static normalizeInputs(n, e) {
            let t = n.geometry ?? e?.geometry,
                {
                    width: r,
                    height: i,
                    depth: s
                } = t.userData.parameters,
                o = Ne(Ne({}, e?.parameters ?? {
                    width: r,
                    height: i,
                    depth: s,
                    subdivisions: 1
                }), n.parameters);
            return {
                parameters: je(Ne({}, o), {
                    width: Math.abs(o.width),
                    height: Math.abs(o.height),
                    depth: Math.abs(o.depth)
                }),
                geometry: t,
                subdivPointer: e?.subdivPointer,
                smoothShading: e?.smoothShading
            }
        }
        static build(n) {
            let e = n.geometry,
                t = n.geometry.originalGeometry,
                {
                    width: r,
                    height: i,
                    depth: s,
                    subdivisions: o
                } = n.parameters,
                l = e.userData.parameters;
            if (Gn.set(l.width, l.height, l.depth), r !== Gn.x || i !== Gn.y || s !== Gn.z) {
                let f = [r / Gn.x, i / Gn.y, s / Gn.z];
                Fs.makeScale(f[0], f[1], f[2]);
                let h = t?.boundingSphere ?? e.boundingSphere;
                h.center.applyMatrix4(Fs), e.boundingSphere = null, e.applyMatrix4(Fs), e.boundingSphere = h, t ? (t.boundingSphere = null, t.applyMatrix4(Fs), t.getAttribute("positionWASM").applyMatrix4(Fs), t.boundingSphere = h) : e.getAttribute("positionWASM").applyMatrix4(Fs)
            }
            let a, c;
            return t !== void 0 ? (c = e, a = t) : a = e, n.subdivPointer === void 0 && (this.allocate(a), a?.dispose(), a = this.buildLevel(!0, n.smoothShading), a.computeBoundingSphere(), n.subdivPointer = this.activeSubdivPtr, this.getTopologicalMesh(a)), o > 0 ? ((o !== l?.subdivisions || t === void 0) && (n.subdivPointer !== this.activeSubdivPtr && (this.activeSubdivPtr = n.subdivPointer), c?.dispose(), We.set_destination_refinement_level(n.subdivPointer, o), c = this.buildLevel(!1, n.smoothShading), c.boundingSphere = a.boundingSphere), e = c, t = a, delete t.userData.parameters) : (e = a, c?.dispose(), t = void 0), Object.assign(e, {
                originalGeometry: t,
                subdivPointer: this.activeSubdivPtr,
                userData: {
                    parameters: n.parameters,
                    type: "SubdivGeometry"
                }
            })
        }
        static allocate(n) {
            let e, t, r, i = [],
                s = [];
            if (n.userData.type !== "SubdivGeometry") {
                let S = Rs.mergeVertices(n, 1.1);
                e = S.attributes.position.array;
                let E = S.getIndex().array,
                    M = E.length;
                switch (n.userData.type) {
                    case "TorusGeometry":
                    case "CubeGeometry":
                        t = new Uint32Array(M / 3 * 2), r = new Uint8Array(M / 6).fill(4);
                        for (let k = 0, Q = 0; k < M; k += 6) t[Q++] = E[k], t[Q++] = E[k + 1], t[Q++] = E[k + 4], t[Q++] = E[k + 5];
                        break;
                    case "SphereGeometry":
                    case "CylinderGeometry":
                    case "ConeGeometry":
                        let L, I;
                        n.userData.type === "SphereGeometry" ? (I = n.parameters.heightSegments, L = n.parameters.widthSegments) : n.userData.type === "CylinderGeometry" ? (I = n.parameters.heightSegments + 2, L = n.parameters.radialSegments) : (I = n.parameters.heightSegments + 1, L = n.parameters.radialSegments), t = new Uint32Array(2 * L * 3 + (I - 2) * L * 4), r = new Uint8Array(2 * L + (I - 2) * L);
                        let z = 0,
                            O = 0,
                            X = 0;
                        if (n.userData.type === "SphereGeometry") {
                            for (; O < 3 * L;) t[O++] = E[z++], t[O++] = E[z++], t[O++] = E[z++], r[X++] = 3;
                            for (; O < 3 * L + 4 * (I - 2) * L; z += 6) t[O++] = E[z], t[O++] = E[z + 1], t[O++] = E[z + 4], t[O++] = E[z + 5], r[X++] = 4
                        } else
                            for (; O < 4 * (I - 2) * L; z += 6) t[O++] = E[z], t[O++] = E[z + 1], t[O++] = E[z + 4], t[O++] = E[z + 5], r[X++] = 4;
                        for (; O < t.length;) t[O++] = E[z++], t[O++] = E[z++], t[O++] = E[z++], r[X++] = 3;
                        break;
                    default:
                        t = E, r = new Uint8Array(M / 3).fill(3);
                        break
                }
            } else if (n.getAttribute("positionWASM") !== void 0) e = n.getAttribute("positionWASM").array, t = n.getAttribute("indexWASM").array, r = n.getAttribute("verticesPerFaceWASM").array;
            else {
                let S = n.getAttribute("faceMap");
                n.deleteAttribute("faceMap");
                let E = Rs.mergeVertices(n, 2);
                n.setAttribute("faceMap", S), e = E.attributes.position.array;
                let M = [],
                    L = S.array;
                r = new Uint8Array(L[L.length - 1] + 1).fill(3);
                let I = E.getIndex().array;
                for (let z = 0, O = L.length; z < O;) L[z] === L[z + 1] ? (r[L[z]]++, M.push(...new Set(I.slice(3 * z, 3 * z + 6))), z += 2) : (M.push(...I.slice(3 * z, 3 * z + 3)), z++);
                t = new Uint32Array(M)
            }
            let o = e.length,
                l = t.length,
                a = r.length,
                c = e.length + i.length + s.length,
                f = t.length + r.length,
                h = c * Float32Array.BYTES_PER_ELEMENT + f * Uint32Array.BYTES_PER_ELEMENT,
                m = c * Float32Array.BYTES_PER_ELEMENT,
                v = f * Uint32Array.BYTES_PER_ELEMENT,
                g = We._malloc(h),
                y = new Float32Array(We.HEAPF32.buffer, g, c),
                A = new Uint32Array(We.HEAPU32.buffer, g + m, f),
                w = bh(Float32Array, e, i, s),
                C = bh(Uint32Array, t, r);
            y.set(w, 0), A.set(C, 0), this.activeSubdivPtr = We.alloc_subdivision_surface(g, o, g + m, l, g + m + t.length * Uint32Array.BYTES_PER_ELEMENT, a), We._free(g)
        }
        static buildLevel(n, e, t) {
            let r = We.get_mesh_data(this.activeSubdivPtr, n ? We.Level.CONTROL : We.Level.REFINED, e ?? !n),
                i = 8,
                s = We.HEAPU32.subarray(r >> 2, (r >> 2) + i),
                o = s.subarray(4, 4 + 4),
                l = 0,
                a = We.HEAPU32[s[l] >> 2],
                c = We.HEAPF32.subarray(a >> 2, (a >> 2) + o[l]);
            l++;
            let f = We.HEAPU32[s[l] >> 2],
                h = We.HEAPF32.subarray(f >> 2, (f >> 2) + o[l]);
            l++;
            let m = We.HEAPU32[s[l] >> 2],
                v = We.HEAPU32.subarray(m >> 2, (m >> 2) + o[l]);
            l++;
            let g = We.HEAPU32[s[l] >> 2],
                y = We.HEAPU32.subarray(g >> 2, (g >> 2) + o[l]);
            if (l++, t === void 0) {
                let A = new Lt.BufferGeometry;
                if (A.setIndex(new Lt.Uint32BufferAttribute(y, 1)), A.setAttribute("position", new Lt.Float32BufferAttribute(c, 3)), A.setAttribute("normal", new Lt.Float32BufferAttribute(h, 3)), n) {
                    A.setAttribute("faceMap", new Lt.Uint32BufferAttribute(v, 1));
                    let w = new Float32Array(h.length / 3 * 4).fill(0);
                    A.setAttribute("color", new Lt.BufferAttribute(w, 4))
                }
                return We.free_mesh_data(r), A.userData.type = "SubdivGeometry", A
            }
            t.getAttribute("position").copyArray(c), t.getAttribute("normal").copyArray(h), t.attributes.position.needsUpdate = !0, t.attributes.normal.needsUpdate = !0, We.free_mesh_data(r)
        }
        static buildControlCageWireframe(n, e) {
            let t = We.get_wireframe_data_for_base_level(this.activeSubdivPtr),
                r = 4,
                i = We.HEAPU32.subarray(t >> 2, (t >> 2) + r),
                s = i.subarray(2, 2 + 2),
                o = 0,
                l = We.HEAPU32[i[o] >> 2],
                a = We.HEAPF32.subarray(l >> 2, (l >> 2) + s[o]);
            o++;
            let c = We.HEAPU32[i[o] >> 2],
                f = We.HEAPU32.subarray(c >> 2, (c >> 2) + s[o]);
            if (n === void 0) {
                let h = new Lt.BufferGeometry;
                h.setAttribute("position", new Lt.Float32BufferAttribute(a, 3));
                let m = new Float32Array(a.length);
                for (let v = 0, g = a.length; v < g;) m[v++] = e.r, m[v++] = e.g, m[v++] = e.b;
                return h.setAttribute("color", new Lt.BufferAttribute(m, 3)), h.setIndex(new Lt.Uint32BufferAttribute(f, 1)), We.free_wireframe_data_for_base_level(t), h
            }
            n.getAttribute("position").copyArray(a), n.attributes.position.needsUpdate = !0, We.free_wireframe_data_for_base_level(t)
        }
        static clone(n, e, t) {
            this.activeSubdivPtr = We.copy_subdivision_surface(e), We.set_destination_refinement_level(this.activeSubdivPtr, n.subdivisions);
            let r = this.buildLevel(!0, t);
            Si.getTopologicalMesh(r);
            let i, s, o;
            return n.subdivisions > 0 ? (o = this.buildLevel(!1, t), i = o, s = r, delete s.userData.parameters) : (i = r, s = void 0), Object.assign(i, {
                originalGeometry: s,
                userData: {
                    parameters: n,
                    type: "SubdivGeometry"
                }
            })
        }
        static getTopologicalMesh(n) {
            let e = We.get_topological_data(this.activeSubdivPtr),
                t = 6,
                r = We.HEAPU32.subarray(e >> 2, (e >> 2) + t),
                i = r.subarray(3, 3 + 3),
                s = 0,
                o = We.HEAPU32[r[s] >> 2],
                l = We.HEAPF32.subarray(o >> 2, (o >> 2) + i[s]);
            s++;
            let a = We.HEAPU32[r[s] >> 2],
                c = We.HEAPU32.subarray(a >> 2, (a >> 2) + i[s]);
            s++;
            let f = We.HEAPU32[r[s] >> 2],
                h = We.HEAPU32.subarray(f >> 2, (f >> 2) + i[s]);
            n.setAttribute("positionWASM", new Lt.Float32BufferAttribute(l, 3)), n.setAttribute("indexWASM", new Lt.Uint32BufferAttribute(c, 1)), n.setAttribute("verticesPerFaceWASM", new Lt.Uint8BufferAttribute(h, 1)), We.free_topological_data(e)
        }
    }, Yo.checkpoints = [], Yo.checkpointCurrentIndex = -1, Yo.maxCheckpoints = 30, Yo);
    var Ko = {};
    ud(Ko, {
        addBarycentricAttribute: () => w0,
        fixUvs: () => N0,
        loadFromUrl: () => S0,
        resizeGeometry: () => b0,
        roundShapePolygon: () => A0
    });
    var ln = W(J()),
        wh = function(n, e) {
            let t = e.x - n.x,
                r = e.y - n.y,
                i = Math.sqrt(t * t + r * r),
                s = t / i,
                o = r / i,
                l = Math.atan2(o, s);
            return {
                x: t,
                y: r,
                len: i,
                nx: s,
                ny: o,
                ang: l
            }
        },
        A0 = (n, e, t) => {
            let r, i, s, o, l, a, c, f, h, m, v, g, y, A, w = e.length;
            for (o = e[w - 2], n.curves = [], r = 1; r < w - 1; r++) {
                l = e[r % w], a = e[(r + 1) % w];
                let C = wh(l, o),
                    S = wh(l, a);
                c = C.nx * S.ny - C.ny * S.nx, f = C.nx * S.nx - C.ny * -S.ny, v = Math.asin(c), h = 1, m = !1, f < 0 ? v < 0 ? v = Math.PI + v : (v = Math.PI - v, h = -1, m = !0) : v > 0 && (h = -1, m = !0), g = v / 2, A = Math.abs(Math.cos(g) * t / Math.sin(g)), A > Math.min(C.len / 2, S.len / 2) ? (A = Math.min(C.len / 2, S.len / 2), y = Math.abs(A * Math.sin(g) / Math.cos(g))) : y = t, i = l.x + S.nx * A, s = l.y + S.ny * A, i += -S.ny * y * h, s += S.nx * y * h, n.absarc(i, s, y, C.ang + Math.PI / 2 * h, S.ang - Math.PI / 2 * h, m), o = l, l = a
            }
            n.closePath()
        },
        b0 = (n, {
            width: e,
            height: t,
            depth: r
        }) => {
            e = Math.abs(e), t = Math.abs(t), r = Math.abs(r);
            let i = n.userData.parameters,
                s, o, l;
            e === 0 ? (e = i.width, s = 1) : s = e / i.width, t === 0 ? (t = i.height, o = 1) : o = t / i.height, r === 0 ? (r = i.depth, l = 1) : l = r / i.depth, n.scale(s, o, l), i.width = e, i.height = t, i.depth = r
        },
        w0 = (n, e) => {
            let t = [new ln.Vector3(1, 0, 0), new ln.Vector3(0, 1, 0), new ln.Vector3(0, 0, 1)],
                r = n.attributes.position,
                i = new Float32Array(r.count * 3);
            for (let s = 0, o = r.count; s < o; s++) t[s % 3].toArray(i, s * 3);
            n.setAttribute(e, new ln.Float32BufferAttribute(i, 3))
        },
        S0 = n => new Promise(e => {
            new ln.BufferGeometryLoader().load(n, r => e(r))
        }),
        N0 = (n, e, t) => {
            let r = n.getAttribute("uv");
            if (r)
                for (let i = 0; i < r.count; i++) {
                    let s = r.getX(i),
                        o = r.getY(i);
                    r.setXY(i, (s + e / 2) / e, 1 - (o - t / 2) / t * -1)
                }
        };
    var Xo = {
            ConeGeometry: Id,
            CubeGeometry: Ld,
            CylinderGeometry: Md,
            DodecahedronGeometry: Bd,
            EllipseGeometry: Zd,
            HelixGeometry: ih,
            IcosahedronGeometry: sh,
            LatheGeometry: oh,
            NonParametricGeometry: Fn,
            PolygonGeometry: lh,
            PyramidGeometry: ch,
            RectangleGeometry: xl,
            SphereGeometry: dh,
            StarGeometry: hh,
            TextFrameGeometry: ph,
            TorusGeometry: gh,
            TorusKnotGeometry: yh,
            TriangleGeometry: xh,
            VectorGeometry: lr,
            SubdivGeometry: Si
        },
        qo = n => Xo[n.type].create(n);
    var Ll = W(J());
    var Oe = W(J());
    var Al = n => "isEntity" in n,
        br = n => "isAbstractMesh" in n;
    var bl = n => "objectHelper" in n;
    var Gs = new Oe.Box3,
        er = new Oe.Vector3,
        Me = new Oe.Vector3,
        Ht = new Oe.Matrix4;

    function C0(n, e, t = 0, r = e.count) {
        let i = 1 / 0,
            s = 1 / 0,
            o = 1 / 0,
            l = -1 / 0,
            a = -1 / 0,
            c = -1 / 0;
        for (let f = t; f < r; f++) {
            let h = e.getX(f),
                m = e.getY(f),
                v = e.getZ(f);
            h < i && (i = h), m < s && (s = m), v < o && (o = v), h > l && (l = h), m > a && (a = m), v > c && (c = v)
        }
        return n.min.set(i, s, o), n.max.set(l, a, c), n
    }
    var Sh = (n, e, t, r) => {
            if (br(n)) {
                let i = n.geometry.userData.parameters,
                    s = n.geometry.getAttribute("position");
                n.geometry.userData.type === "SubdivGeometry" ? er.copy((n.geometry.originalGeometry ?? n.geometry).boundingSphere.center) : (C0(Gs, s, n.geometry.drawRange.start, n.geometry.drawRange.count < 1 / 0 ? n.geometry.drawRange.count : s.count), Gs.getCenter(er)), n.forceComputeSize ? Gs.getSize(Me).multiplyScalar(.5) : Me.set(i.width, i.height, i.depth ?? 0).multiplyScalar(.5)
            } else if (bl(n) && r === !0) {
                let i = n.geometryHelper.getAttribute("position");
                Gs.setFromArray(i.array), Gs.getCenter(er), Gs.getSize(Me).multiplyScalar(.5)
            } else er.setScalar(0), Me.setScalar(0);
            Ht.copy(e).multiply(n.matrixWorld), Me.x === 0 && Me.y === 0 && Me.z === 0 ? t.push(new Oe.Vector3(er.x, er.y, er.z).applyMatrix4(Ht)) : t.push(new Oe.Vector3(-Me.x, Me.y, Me.z).add(er).applyMatrix4(Ht), new Oe.Vector3(-Me.x, -Me.y, Me.z).add(er).applyMatrix4(Ht), new Oe.Vector3(Me.x, -Me.y, Me.z).add(er).applyMatrix4(Ht), new Oe.Vector3(Me.x, Me.y, Me.z).add(er).applyMatrix4(Ht), new Oe.Vector3(-Me.x, Me.y, -Me.z).add(er).applyMatrix4(Ht), new Oe.Vector3(-Me.x, -Me.y, -Me.z).add(er).applyMatrix4(Ht), new Oe.Vector3(Me.x, -Me.y, -Me.z).add(er).applyMatrix4(Ht), new Oe.Vector3(Me.x, Me.y, -Me.z).add(er).applyMatrix4(Ht))
        },
        wl = class extends Oe.Box3 {
            constructor(e, t) {
                super(e, t);
                this.transform = new Oe.Matrix4;
                this.vertices = [];
                this.faces = [];
                this.edges = [];
                this.centerEdges = []
            }
            setFromObjectSize(e, t = !1) {
                e.updateWorldMatrix(!1, !1), this.makeEmpty(), this.transform = e.matrixWorld;
                let r = new Oe.Matrix4().copy(e.matrixWorld).invert();
                return this.expandByObjectSize(e, r, t)
            }
            expandByObjectSize(e, t, r = !1) {
                let i = [];
                return r === !0 ? e.traverseEntity(s => Sh(s, t, i, "enableHelper" in e && e.enableHelper)) : Sh(e, t, i, "enableHelper" in e && e.enableHelper), this.setFromPoints(i)
            }
            getCenter(e) {
                return e = super.getCenter(e), e.applyMatrix4(this.transform), e
            }
            getPositionToCenter(e) {
                return e = super.getCenter(e), e
            }
            computeVertices() {
                this.getSize(Me).multiplyScalar(.5), this.getCenter(er), Ht.copy(this.transform).setPosition(er), this.vertices = [new Oe.Vector3(-Me.x, Me.y, Me.z).applyMatrix4(Ht), new Oe.Vector3(-Me.x, -Me.y, Me.z).applyMatrix4(Ht), new Oe.Vector3(Me.x, -Me.y, Me.z).applyMatrix4(Ht), new Oe.Vector3(Me.x, Me.y, Me.z).applyMatrix4(Ht), new Oe.Vector3(-Me.x, Me.y, -Me.z).applyMatrix4(Ht), new Oe.Vector3(-Me.x, -Me.y, -Me.z).applyMatrix4(Ht), new Oe.Vector3(Me.x, -Me.y, -Me.z).applyMatrix4(Ht), new Oe.Vector3(Me.x, Me.y, -Me.z).applyMatrix4(Ht)]
            }
            computeEdges() {
                this.vertices.length > 0 && this.computeVertices(), this.edges = [new Oe.Line3(this.vertices[0], this.vertices[3]), new Oe.Line3(this.vertices[1], this.vertices[2]), new Oe.Line3(this.vertices[5], this.vertices[6]), new Oe.Line3(this.vertices[4], this.vertices[7]), new Oe.Line3(this.vertices[0], this.vertices[1]), new Oe.Line3(this.vertices[3], this.vertices[2]), new Oe.Line3(this.vertices[7], this.vertices[6]), new Oe.Line3(this.vertices[4], this.vertices[5]), new Oe.Line3(this.vertices[0], this.vertices[4]), new Oe.Line3(this.vertices[1], this.vertices[5]), new Oe.Line3(this.vertices[2], this.vertices[6]), new Oe.Line3(this.vertices[3], this.vertices[7])], this.centerEdges = this.edges.map(e => e.getCenter(new Oe.Vector3))
            }
            computeFaces() {
                this.vertices.length > 0 && this.computeVertices(), this.faces = [new Oe.Vector3().copy(this.vertices[0]).sub(this.vertices[2]).multiplyScalar(.5).add(this.vertices[2]), new Oe.Vector3().copy(this.vertices[7]).sub(this.vertices[5]).multiplyScalar(.5).add(this.vertices[5]), new Oe.Vector3().copy(this.vertices[4]).sub(this.vertices[1]).multiplyScalar(.5).add(this.vertices[1]), new Oe.Vector3().copy(this.vertices[3]).sub(this.vertices[6]).multiplyScalar(.5).add(this.vertices[6]), new Oe.Vector3().copy(this.vertices[4]).sub(this.vertices[3]).multiplyScalar(.5).add(this.vertices[3]), new Oe.Vector3().copy(this.vertices[1]).sub(this.vertices[6]).multiplyScalar(.5).add(this.vertices[6])]
            }
        };

    function Nh(n, e, t, r) {
        if (r === 0) return t.copy(n);
        if (r === 1) return t.copy(e);
        let i = n.w * e.w + n.x * e.x + n.y * e.y + n.z * e.z;
        if (i >= 1) return t.copy(n);
        let s = 1 - i * i;
        if (s <= Number.EPSILON) {
            let f = 1 - r;
            return t.w = f * n.w + r * e.w, t.x = f * n.x + r * e.x, t.y = f * n.y + r * e.y, t.z = f * n.z + r * e.z, t.normalize(), t
        }
        let o = Math.sqrt(s),
            l = Math.atan2(o, i),
            a = Math.sin((1 - r) * l) / o,
            c = Math.sin(r * l) / o;
        return t.w = n.w * a + e.w * c, t.x = n.x * a + e.x * c, t.y = n.y * a + e.y * c, t.z = n.z * a + e.z * c, t
    }
    var Wt = W(J());
    var zn = new Set;
    var ii;
    (function(l) {
        l[l.LINEAR = 0] = "LINEAR", l[l.EASE = 1] = "EASE", l[l.EASE_IN = 2] = "EASE_IN", l[l.EASE_OUT = 3] = "EASE_OUT", l[l.EASE_IN_OUT = 4] = "EASE_IN_OUT", l[l.CUBIC = 5] = "CUBIC", l[l.SPRING = 6] = "SPRING"
    })(ii || (ii = {}));
    var zs = class {
        constructor() {
            this.easing = 4;
            this.duration = 1e3;
            this.delay = 0;
            this.cubicControls = [.5, .05, .1, .3];
            this.springParameters = {
                mass: 1,
                stiffness: 80,
                damping: 10,
                velocity: 0
            };
            this.repeat = !1;
            this.cycle = !1;
            this.rewind = !1
        }
        get sp_mass() {
            return this.springParameters.mass
        }
        set sp_mass(e) {
            this.springParameters.mass = e
        }
        get sp_stiffness() {
            return this.springParameters.stiffness
        }
        set sp_stiffness(e) {
            this.springParameters.stiffness = e
        }
        get sp_damping() {
            return this.springParameters.damping
        }
        set sp_damping(e) {
            this.springParameters.damping = e
        }
        get sp_velocity() {
            return this.springParameters.velocity
        }
        set sp_velocity(e) {
            this.springParameters.velocity = e
        }
        copy(e) {
            return this.easing = e.easing, this.duration = e.duration, this.delay = e.delay, this.cubicControls = [...e.cubicControls], this.springParameters = Ne({}, e.springParameters), this.repeat = e.repeat, this.cycle = e.cycle, this.rewind = e.rewind, this
        }
        clone() {
            return new zs().copy(this)
        }
        toJSON() {
            let e = {
                easing: this.easing,
                duration: this.duration,
                delay: this.delay,
                cubicControls: this.cubicControls,
                springParameters: Ne({}, this.springParameters)
            };
            return this.repeat === !0 && (e.repeat = !0), this.cycle === !0 && (e.cycle = !0), this.rewind === !0 && (e.rewind = !0), this.object !== void 0 && (e.object = this.object.uuid), this.state !== void 0 && (e.state = this.state.uuid), e
        }
        fromJSON(e, t, r) {
            return this.easing = e.easing, this.duration = e.duration, this.delay = e.delay, this.cubicControls = [...e.cubicControls], this.springParameters.mass = e.springParameters.mass, this.springParameters.stiffness = e.springParameters.stiffness, this.springParameters.damping = e.springParameters.damping, this.springParameters.velocity = e.springParameters.velocity, e.repeat !== void 0 && (this.repeat = e.repeat), e.cycle !== void 0 && (this.cycle = e.cycle), e.rewind !== void 0 && (this.rewind = e.rewind), e.object !== void 0 && (this.object = t[e.object]), e.state !== void 0 && (this.state = r[e.state]), this
        }
    };

    function T0() {
        return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document
    }
    var Re;
    (function(h) {
        h[h.MOUSE_DOWN = 0] = "MOUSE_DOWN", h[h.MOUSE_UP = 1] = "MOUSE_UP", h[h.MOUSE_HOVER = 2] = "MOUSE_HOVER", h[h.MOUSE_ENTER = 3] = "MOUSE_ENTER", h[h.MOUSE_LEAVE = 4] = "MOUSE_LEAVE", h[h.KEY_DOWN = 5] = "KEY_DOWN", h[h.KEY_UP = 6] = "KEY_UP", h[h.START = 7] = "START", h[h.OPEN_LINK = 8] = "OPEN_LINK", h[h.LOOK_AT = 9] = "LOOK_AT", h[h.FOLLOW = 10] = "FOLLOW"
    })(Re || (Re = {}));
    var ks = class {
        constructor(e, t) {
            this.targets = [];
            this.ui = {
                isCollapsed: !1
            };
            this._type = e, this.key = t
        }
        get type() {
            return this._type
        }
        set type(e) {
            this._type = e, e === 9 ? this.distance = 1e3 : this.distance = void 0, e !== 5 && e !== 6 && (this.key = void 0)
        }
        newTarget(e) {
            let t = new zs;
            if (t.object = e, e !== void 0) {
                let r = e.interaction.states;
                r.length > 0 && (t.state = r[r.length - 1])
            }
            return this.targets.push(t), zn.add(t), t
        }
        addTarget(e, t = 0) {
            this.targets.splice(t, 0, e), zn.add(e)
        }
        removeTarget(e) {
            zn.delete(this.targets[e]), this.targets.splice(e, 1)
        }
        dispatchReverse() {
            for (let e = 0, t = this.targets.length; e < t; ++e) {
                let r = this.targets[e];
                r.state !== void 0 && r.object !== void 0 && r.object.interaction.reverse(r)
            }
        }
        dispatch() {
            if (this.url !== void 0 && (this._type === 8 || this._type === 0 || this._type === 1 || this._type === 5 || this._type === 6)) T0() ? window.location.assign(this.url) : window.open(this.url, "_blank");
            else
                for (let e = 0, t = this.targets.length; e < t; ++e) {
                    let r = this.targets[e];
                    r.state !== void 0 && r.object !== void 0 && r.object.interaction.play(r)
                }
        }
        copy(e) {
            return this._type = e.type, this.key = e.key, this.url = e.url, this.distance = e.distance, this.ui.isCollapsed = e.ui.isCollapsed, this
        }
        clone() {
            return new ks().copy(this)
        }
        toJSON() {
            let e = {
                type: this._type,
                key: this.key,
                ui: {
                    isCollapsed: this.ui.isCollapsed
                }
            };
            if (this.url !== void 0 && (e.url = this.url), this.distance !== void 0 && (e.distance = this.distance), this.targets.length > 0) {
                e.targets = [];
                for (let t = 0, r = this.targets.length; t < r; ++t) e.targets.push(this.targets[t].toJSON())
            }
            return e
        }
        fromJSON(e, t, r) {
            if (this._type = e.type, this.key = e.key, this.targets = [], this.ui = {
                    isCollapsed: e.ui.isCollapsed
                }, this.url = e.url, e.distance !== void 0 && (this.distance = e.distance), e.targets !== void 0)
                for (let i = 0, s = e.targets.length; i < s; ++i) this.addTarget(new zs().fromJSON(e.targets[i], t, r), i);
            return this
        }
    };
    var ji = W(J());
    var cn = class {
        constructor() {
            this.uuid = ji.MathUtils.generateUUID();
            this.name = "";
            this.position = new ji.Vector3;
            this.rotation = new ji.Euler;
            this.scale = new ji.Vector3;
            this.hiddenMatrix = new ji.Matrix4
        }
        update(e) {
            this.updateMatrix(e), "geometry" in e && this.updateGeometry(e), "material" in e && this.updateMaterial(e), e.objectType === "CombinedCamera" && this.updateCamera(e)
        }
        updateCamera(e) {
            this.camera = {
                zoomPersp: e.perspCamera.zoom,
                zoomOrtho: e.orthoCamera.zoom
            }
        }
        updateMatrix(e) {
            this.position.copy(e.position), this.rotation.copy(e.rotation), this.scale.copy(e.scale), "hiddenMatrix" in e && this.hiddenMatrix.copy(e.hiddenMatrix)
        }
        updateGeometry(e) {
            if ("geometry" in e) {
                let {
                    width: t,
                    height: r,
                    depth: i
                } = e.geometry.userData.parameters;
                this.geometry = {
                    width: t,
                    height: r,
                    depth: i
                }
            }
        }
        updateMaterial(e) {
            if ("material" in e)
                if (e.material instanceof Array) {
                    this.material = [];
                    for (let t = 0, r = e.material.length; t < r; ++t) {
                        let i = e.material[t],
                            s = [],
                            o = i.layersList.head;
                        for (; o;) s.push(o.clone()), o = o.next;
                        this.material.push({
                            layersList: s
                        })
                    }
                } else {
                    let t = e.material,
                        r = [],
                        i = t.layersList.head;
                    for (; i;) r.push(i.clone()), i = i.next;
                    this.material = {
                        layersList: r
                    }
                }
        }
        execute(e) {
            if (e.position.copy(this.position), e.rotation.copy(this.rotation), e.scale.copy(this.scale), "hiddenMatrix" in e && e.hiddenMatrix.copy(this.hiddenMatrix), "geometry" in e && this.geometry !== void 0) {
                let r = e.geometry.userData.parameters,
                    i = this.geometry;
                (i.width !== r.width || i.height !== r.height || i.depth !== r.depth) && e.updateGeometry({
                    parameters: {
                        width: i.width,
                        height: i.height,
                        depth: i.depth
                    }
                })
            }
            if ("material" in e) {
                let t = e.material;
                if (t instanceof Array) {
                    let r = this.material;
                    for (let i = 0, s = r.length; i < s; ++i) {
                        let o = t[i].layersList.head,
                            l = r[i].layersList,
                            a = 0;
                        for (; o;) o.copy(l[a++]), o = o.next;
                        t[i].dispose()
                    }
                } else {
                    if (t.userData.isAsset) return;
                    let r = 0,
                        i = t.layersList.head,
                        o = this.material.layersList;
                    for (; i;) i.copyUniforms(o[r++]), i = i.next;
                    t.dispose()
                }
            }
            this.camera && e.objectType === "CombinedCamera" && (e.zoom = e.cameraType === "OrthographicCamera" ? this.camera.zoomOrtho : this.camera.zoomPersp, e.updateProjectionMatrix())
        }
        copy(e) {
            if (this.name = e.name, this.position.copy(e.position), this.rotation.copy(e.rotation), this.scale.copy(e.scale), this.hiddenMatrix.copy(e.hiddenMatrix), e.geometry !== void 0 && (this.geometry = {
                    width: e.geometry.width,
                    height: e.geometry.height,
                    depth: e.geometry.depth
                }), e.material !== void 0)
                if (e.material instanceof Array) {
                    this.material = [];
                    for (let t = 0, r = e.material.length; t < r; ++t) this.material.push({
                        layersList: e.material[t].layersList.map(i => i.clone())
                    })
                } else this.material = {
                    layersList: e.material.layersList.map(t => t.clone())
                };
            return e.camera !== void 0 && (this.camera = {
                zoomPersp: e.camera.zoomPersp,
                zoomOrtho: e.camera.zoomOrtho
            }), this
        }
        clone() {
            return new cn().copy(this)
        }
        toJSON(e) {
            let t = {
                uuid: this.uuid,
                name: this.name,
                position: this.position.toArray(),
                rotation: this.rotation.toArray(),
                scale: this.scale.toArray(),
                hiddenMatrix: this.hiddenMatrix.toArray()
            };
            if (this.geometry !== void 0 && (t.geometry = {
                    width: this.geometry.width,
                    height: this.geometry.height,
                    depth: this.geometry.depth
                }), this.material !== void 0)
                if (this.material instanceof Array) {
                    t.material = [];
                    for (let r = 0, i = this.material.length; r < i; ++r) t.material.push({
                        layersList: this.material[r].layersList.map(s => s.toJSON(e))
                    })
                } else t.material = {
                    layersList: this.material.layersList.map(r => r.toJSON(e))
                };
            return this.camera !== void 0 && (t.camera = {
                zoomPersp: this.camera.zoomPersp,
                zoomOrtho: this.camera.zoomOrtho
            }), t
        }
        fromJSON(e, t) {
            if (this.uuid = e.uuid, this.name = e.name, this.position.fromArray(e.position), this.rotation.fromArray(e.rotation), this.scale.fromArray(e.scale), this.hiddenMatrix.fromArray(e.hiddenMatrix), e.geometry !== void 0 && (this.geometry = {
                    width: e.geometry.width,
                    height: e.geometry.height,
                    depth: e.geometry.depth
                }), e.material !== void 0)
                if (e.material instanceof Array) {
                    this.material = [];
                    for (let r = 0, i = e.material.length; r < i; ++r) this.material.push({
                        layersList: e.material[r].layersList.map(s => Jc(s, t))
                    })
                } else this.material = {
                    layersList: e.material.layersList.map(r => Jc(r, t))
                };
            return e.camera !== void 0 && (this.camera = {
                zoomPersp: e.camera.zoomPersp,
                zoomOrtho: e.camera.zoomOrtho
            }), this
        }
    };
    "use strict";
    var Ch = {
            update: null,
            begin: null,
            loopBegin: null,
            changeBegin: null,
            change: null,
            changeComplete: null,
            loopComplete: null,
            complete: null,
            loop: 1,
            direction: "normal",
            autoplay: !0,
            timelineOffset: 0,
            rewind: !0
        },
        Mu = {
            duration: 1e3,
            delay: 0,
            endDelay: 0,
            easing: "easeOutElastic(1, .5)",
            round: 0
        },
        E0 = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"],
        Sl = {
            CSS: {},
            springs: {}
        };

    function Ni(n, e, t) {
        return Math.min(Math.max(n, e), t)
    }

    function Zo(n, e) {
        return n.indexOf(e) > -1
    }

    function _u(n, e) {
        return n.apply(null, e)
    }
    var Le = {
        arr: function(n) {
            return Array.isArray(n)
        },
        obj: function(n) {
            return Zo(Object.prototype.toString.call(n), "Object")
        },
        pth: function(n) {
            return Le.obj(n) && n.hasOwnProperty("totalLength")
        },
        svg: function(n) {
            return n instanceof SVGElement
        },
        inp: function(n) {
            return n instanceof HTMLInputElement
        },
        dom: function(n) {
            return !("isNode" in n) && (n.nodeType || Le.svg(n))
        },
        str: function(n) {
            return typeof n == "string"
        },
        fnc: function(n) {
            return typeof n == "function"
        },
        und: function(n) {
            return typeof n == "undefined"
        },
        hex: function(n) {
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(n)
        },
        rgb: function(n) {
            return /^rgb/.test(n)
        },
        hsl: function(n) {
            return /^hsl/.test(n)
        },
        col: function(n) {
            return Le.hex(n) || Le.rgb(n) || Le.hsl(n)
        },
        key: function(n) {
            return !Ch.hasOwnProperty(n) && !Mu.hasOwnProperty(n) && n !== "targets" && n !== "keyframes"
        }
    };

    function Th(n) {
        var e = /\(([^)]+)\)/.exec(n);
        return e ? e[1].split(",").map(function(t) {
            return parseFloat(t)
        }) : []
    }

    function Eh(n, e) {
        var t = Th(n),
            r = Ni(Le.und(t[0]) ? 1 : t[0], .1, 100),
            i = Ni(Le.und(t[1]) ? 100 : t[1], .1, 100),
            s = Ni(Le.und(t[2]) ? 10 : t[2], .1, 100),
            o = Ni(Le.und(t[3]) ? 0 : t[3], .1, 100),
            l = Math.sqrt(i / r),
            a = s / (2 * Math.sqrt(i * r)),
            c = a < 1 ? l * Math.sqrt(1 - a * a) : 0,
            f = 1,
            h = a < 1 ? (a * l + -o) / c : -o + l;

        function m(g) {
            var y = e ? e * g / 1e3 : g;
            return a < 1 ? y = Math.exp(-y * a * l) * (f * Math.cos(c * y) + h * Math.sin(c * y)) : y = (f + h * y) * Math.exp(-y * l), g === 0 || g === 1 ? g : 1 - y
        }

        function v() {
            var g = Sl.springs[n];
            if (g) return g;
            for (var y = 1 / 6, A = 0, w = 0;;)
                if (A += y, m(A) === 1) {
                    if (w++, w >= 16) break
                } else w = 0;
            var C = A * y * 1e3;
            return Sl.springs[n] = C, C
        }
        return e ? m : v
    }

    function M0(n) {
        return n === void 0 && (n = 10),
            function(e) {
                return Math.ceil(Ni(e, 1e-6, 1) * n) * (1 / n)
            }
    }
    var _0 = function() {
            var n = 11,
                e = 1 / (n - 1);

            function t(f, h) {
                return 1 - 3 * h + 3 * f
            }

            function r(f, h) {
                return 3 * h - 6 * f
            }

            function i(f) {
                return 3 * f
            }

            function s(f, h, m) {
                return ((t(h, m) * f + r(h, m)) * f + i(h)) * f
            }

            function o(f, h, m) {
                return 3 * t(h, m) * f * f + 2 * r(h, m) * f + i(h)
            }

            function l(f, h, m, v, g) {
                var y, A, w = 0;
                do A = h + (m - h) / 2, y = s(A, v, g) - f, y > 0 ? m = A : h = A; while (Math.abs(y) > 1e-7 && ++w < 10);
                return A
            }

            function a(f, h, m, v) {
                for (var g = 0; g < 4; ++g) {
                    var y = o(h, m, v);
                    if (y === 0) return h;
                    var A = s(h, m, v) - f;
                    h -= A / y
                }
                return h
            }

            function c(f, h, m, v) {
                if (!(0 <= f && f <= 1 && 0 <= m && m <= 1)) return;
                var g = new Float32Array(n);
                if (f !== h || m !== v)
                    for (var y = 0; y < n; ++y) g[y] = s(y * e, f, m);

                function A(w) {
                    for (var C = 0, S = 1, E = n - 1; S !== E && g[S] <= w; ++S) C += e;
                    --S;
                    var M = (w - g[S]) / (g[S + 1] - g[S]),
                        L = C + M * e,
                        I = o(L, f, m);
                    return I >= .001 ? a(w, L, f, m) : I === 0 ? L : l(w, C, C + e, f, m)
                }
                return function(w) {
                    return f === h && m === v || w === 0 || w === 1 ? w : s(A(w), h, v)
                }
            }
            return c
        }(),
        Mh = function() {
            var n = {
                    linear: function() {
                        return function(r) {
                            return r
                        }
                    }
                },
                e = {
                    Sine: function() {
                        return function(r) {
                            return 1 - Math.cos(r * Math.PI / 2)
                        }
                    },
                    Circ: function() {
                        return function(r) {
                            return 1 - Math.sqrt(1 - r * r)
                        }
                    },
                    Back: function() {
                        return function(r) {
                            return r * r * (3 * r - 2)
                        }
                    },
                    Bounce: function() {
                        return function(r) {
                            for (var i, s = 4; r < ((i = Math.pow(2, --s)) - 1) / 11;);
                            return 1 / Math.pow(4, 3 - s) - 7.5625 * Math.pow((i * 3 - 2) / 22 - r, 2)
                        }
                    },
                    Elastic: function(r, i) {
                        r === void 0 && (r = 1), i === void 0 && (i = .5);
                        var s = Ni(r, 1, 10),
                            o = Ni(i, .1, 2);
                        return function(l) {
                            return l === 0 || l === 1 ? l : -s * Math.pow(2, 10 * (l - 1)) * Math.sin((l - 1 - o / (Math.PI * 2) * Math.asin(1 / s)) * (Math.PI * 2) / o)
                        }
                    }
                },
                t = ["Quad", "Cubic", "Quart", "Quint", "Expo"];
            return t.forEach(function(r, i) {
                e[r] = function() {
                    return function(s) {
                        return Math.pow(s, i + 2)
                    }
                }
            }), Object.keys(e).forEach(function(r) {
                var i = e[r];
                n["easeIn" + r] = i, n["easeOut" + r] = function(s, o) {
                    return function(l) {
                        return 1 - i(s, o)(1 - l)
                    }
                }, n["easeInOut" + r] = function(s, o) {
                    return function(l) {
                        return l < .5 ? i(s, o)(l * 2) / 2 : 1 - i(s, o)(l * -2 + 2) / 2
                    }
                }
            }), n
        }();

    function Iu(n, e) {
        if (Le.fnc(n)) return n;
        var t = n.split("(")[0],
            r = Mh[t],
            i = Th(n);
        switch (t) {
            case "spring":
                return Eh(n, e);
            case "cubicBezier":
                return _u(_0, i);
            case "steps":
                return _u(M0, i);
            default:
                return _u(r, i)
        }
    }

    function _h(n) {
        try {
            var e = document.querySelectorAll(n);
            return e
        } catch (t) {
            return
        }
    }

    function Nl(n, e) {
        for (var t = n.length, r = arguments.length >= 2 ? arguments[1] : void 0, i = [], s = 0; s < t; s++)
            if (s in n) {
                var o = n[s];
                e.call(r, o, s, n) && i.push(o)
            } return i
    }

    function Cl(n) {
        return n.reduce(function(e, t) {
            return e.concat(Le.arr(t) ? Cl(t) : t)
        }, [])
    }

    function Ih(n) {
        return Le.arr(n) ? n : (Le.str(n) && (n = _h(n) || n), n instanceof NodeList || n instanceof HTMLCollection ? [].slice.call(n) : [n])
    }

    function Lu(n, e) {
        return n.some(function(t) {
            return t === e
        })
    }

    function Du(n) {
        var e = {};
        for (var t in n) e[t] = n[t];
        return e
    }

    function Pu(n, e) {
        var t = Du(n);
        for (var r in n) t[r] = e.hasOwnProperty(r) ? e[r] : n[r];
        return t
    }

    function Tl(n, e) {
        var t = Du(n);
        for (var r in e) t[r] = Le.und(n[r]) ? e[r] : n[r];
        return t
    }

    function I0(n) {
        var e = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(n);
        return e ? "rgba(" + e[1] + ",1)" : n
    }

    function L0(n) {
        var e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
            t = n.replace(e, function(l, a, c, f) {
                return a + a + c + c + f + f
            }),
            r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t),
            i = parseInt(r[1], 16),
            s = parseInt(r[2], 16),
            o = parseInt(r[3], 16);
        return "rgba(" + i + "," + s + "," + o + ",1)"
    }

    function D0(n) {
        var e = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(n) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(n),
            t = parseInt(e[1], 10) / 360,
            r = parseInt(e[2], 10) / 100,
            i = parseInt(e[3], 10) / 100,
            s = e[4] || 1;

        function o(m, v, g) {
            return g < 0 && (g += 1), g > 1 && (g -= 1), g < 1 / 6 ? m + (v - m) * 6 * g : g < 1 / 2 ? v : g < 2 / 3 ? m + (v - m) * (2 / 3 - g) * 6 : m
        }
        var l, a, c;
        if (r == 0) l = a = c = i;
        else {
            var f = i < .5 ? i * (1 + r) : i + r - i * r,
                h = 2 * i - f;
            l = o(h, f, t + 1 / 3), a = o(h, f, t), c = o(h, f, t - 1 / 3)
        }
        return "rgba(" + l * 255 + "," + a * 255 + "," + c * 255 + "," + s + ")"
    }

    function P0(n) {
        if (Le.rgb(n)) return I0(n);
        if (Le.hex(n)) return L0(n);
        if (Le.hsl(n)) return D0(n)
    }

    function Vi(n) {
        var e = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(n);
        if (e) return e[1]
    }

    function B0(n) {
        if (Zo(n, "translate") || n === "perspective") return "px";
        if (Zo(n, "rotate") || Zo(n, "skew")) return "deg"
    }

    function Bu(n, e) {
        return Le.fnc(n) ? n(e.target, e.id, e.total) : n
    }

    function Ci(n, e) {
        return n.getAttribute(e)
    }

    function Ou(n, e, t) {
        var r = Vi(e);
        if (Lu([t, "deg", "rad", "turn"], r)) return e;
        var i = Sl.CSS[e + t];
        if (!Le.und(i)) return i;
        var s = 100,
            o = document.createElement(n.tagName),
            l = n.parentNode && n.parentNode !== document ? n.parentNode : document.body;
        l.appendChild(o), o.style.position = "absolute", o.style.width = s + t;
        var a = s / o.offsetWidth;
        l.removeChild(o);
        var c = a * parseFloat(e);
        return Sl.CSS[e + t] = c, c
    }

    function Lh(n, e, t) {
        if (e in n.style) {
            var r = e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
                i = n.style[e] || getComputedStyle(n).getPropertyValue(r) || "0";
            return t ? Ou(n, i, t) : i
        }
    }

    function Ru(n, e) {
        if (Le.dom(n) && !Le.inp(n) && (Ci(n, e) || Le.svg(n) && n[e])) return "attribute";
        if (Le.dom(n) && Lu(E0, e)) return "transform";
        if (Le.dom(n) && e !== "transform" && Lh(n, e)) return "css";
        if (n[e] != null) return "object"
    }

    function Dh(n) {
        if (!!Le.dom(n)) {
            for (var e = n.style.transform || "", t = /(\w+)\(([^)]*)\)/g, r = new Map, i; i = t.exec(e);) r.set(i[1], i[2]);
            return r
        }
    }

    function O0(n, e, t, r) {
        var i = Zo(e, "scale") ? 1 : 0 + B0(e),
            s = Dh(n).get(e) || i;
        return t && (t.transforms.list.set(e, s), t.transforms.last = e), r ? Ou(n, s, r) : s
    }

    function Fu(n, e, t, r) {
        switch (Ru(n, e)) {
            case "transform":
                return O0(n, e, r, t);
            case "css":
                return Lh(n, e, t);
            case "attribute":
                return Ci(n, e);
            default:
                return n[e] || 0
        }
    }

    function Gu(n, e) {
        var t = /^(\*=|\+=|-=)/.exec(n);
        if (!t) return n;
        var r = Vi(n) || 0,
            i = parseFloat(e),
            s = parseFloat(n.replace(t[0], ""));
        switch (t[0][0]) {
            case "+":
                return i + s + r;
            case "-":
                return i - s + r;
            case "*":
                return i * s + r
        }
    }

    function Ph(n, e) {
        if (Le.col(n)) return P0(n);
        if (/\s/g.test(n)) return n;
        var t = Vi(n),
            r = t ? n.substr(0, n.length - t.length) : n;
        return e ? r + e : r
    }

    function zu(n, e) {
        return Math.sqrt(Math.pow(e.x - n.x, 2) + Math.pow(e.y - n.y, 2))
    }

    function R0(n) {
        return Math.PI * 2 * Ci(n, "r")
    }

    function F0(n) {
        return Ci(n, "width") * 2 + Ci(n, "height") * 2
    }

    function G0(n) {
        return zu({
            x: Ci(n, "x1"),
            y: Ci(n, "y1")
        }, {
            x: Ci(n, "x2"),
            y: Ci(n, "y2")
        })
    }

    function Bh(n) {
        for (var e = n.points, t = 0, r, i = 0; i < e.numberOfItems; i++) {
            var s = e.getItem(i);
            i > 0 && (t += zu(r, s)), r = s
        }
        return t
    }

    function z0(n) {
        var e = n.points;
        return Bh(n) + zu(e.getItem(e.numberOfItems - 1), e.getItem(0))
    }

    function Oh(n) {
        if (n.getTotalLength) return n.getTotalLength();
        switch (n.tagName.toLowerCase()) {
            case "circle":
                return R0(n);
            case "rect":
                return F0(n);
            case "line":
                return G0(n);
            case "polyline":
                return Bh(n);
            case "polygon":
                return z0(n)
        }
    }

    function k0(n) {
        var e = Oh(n);
        return n.setAttribute("stroke-dasharray", e), e
    }

    function U0(n) {
        for (var e = n.parentNode; Le.svg(e) && Le.svg(e.parentNode);) e = e.parentNode;
        return e
    }

    function Rh(n, e) {
        var t = e || {},
            r = t.el || U0(n),
            i = r.getBoundingClientRect(),
            s = Ci(r, "viewBox"),
            o = i.width,
            l = i.height,
            a = t.viewBox || (s ? s.split(" ") : [0, 0, o, l]);
        return {
            el: r,
            viewBox: a,
            x: a[0] / 1,
            y: a[1] / 1,
            w: o / a[2],
            h: l / a[3]
        }
    }

    function j0(n, e) {
        var t = Le.str(n) ? _h(n)[0] : n,
            r = e || 100;
        return function(i) {
            return {
                property: i,
                el: t,
                svg: Rh(t),
                totalLength: Oh(t) * (r / 100)
            }
        }
    }

    function V0(n, e) {
        function t(l) {
            l === void 0 && (l = 0);
            var a = e + l >= 1 ? e + l : 0;
            return n.el.getPointAtLength(a)
        }
        var r = Rh(n.el, n.svg),
            i = t(),
            s = t(-1),
            o = t(1);
        switch (n.property) {
            case "x":
                return (i.x - r.x) * r.w;
            case "y":
                return (i.y - r.y) * r.h;
            case "angle":
                return Math.atan2(o.y - s.y, o.x - s.x) * 180 / Math.PI
        }
    }

    function Fh(n, e) {
        var t = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
            r = Ph(Le.pth(n) ? n.totalLength : n, e) + "";
        return {
            original: r,
            numbers: r.match(t) ? r.match(t).map(Number) : [0],
            strings: Le.str(n) || e ? r.split(t) : []
        }
    }

    function Gh(n) {
        var e = n ? Cl(Le.arr(n) ? n.map(Ih) : Ih(n)) : [];
        return Nl(e, function(t, r, i) {
            return i.indexOf(t) === r
        })
    }

    function zh(n) {
        var e = Gh(n);
        return e.map(function(t, r) {
            return {
                target: t,
                id: r,
                total: e.length,
                transforms: {
                    list: Dh(t)
                }
            }
        })
    }

    function H0(n, e) {
        var t = Du(e);
        if (/^spring/.test(t.easing) && (t.duration = Eh(t.easing)), Le.arr(n)) {
            var r = n.length,
                i = r === 2 && !Le.obj(n[0]);
            i ? n = {
                value: n
            } : Le.fnc(e.duration) || (t.duration = e.duration / r)
        }
        var s = Le.arr(n) ? n : [n];
        return s.map(function(o, l) {
            var a = Le.obj(o) && !Le.pth(o) ? o : {
                value: o
            };
            return Le.und(a.delay) && (a.delay = l ? 0 : e.delay), Le.und(a.endDelay) && (a.endDelay = l === s.length - 1 ? e.endDelay : 0), a
        }).map(function(o) {
            return Tl(o, t)
        })
    }

    function W0(n) {
        for (var e = Nl(Cl(n.map(function(s) {
                return Object.keys(s)
            })), function(s) {
                return Le.key(s)
            }).reduce(function(s, o) {
                return s.indexOf(o) < 0 && s.push(o), s
            }, []), t = {}, r = function(s) {
                var o = e[s];
                t[o] = n.map(function(l) {
                    var a = {};
                    for (var c in l) Le.key(c) ? c == o && (a.value = l[c]) : a[c] = l[c];
                    return a
                })
            }, i = 0; i < e.length; i++) r(i);
        return t
    }

    function J0(n, e) {
        var t = [],
            r = e.keyframes;
        r && (e = Tl(W0(r), e));
        for (var i in e) Le.key(i) && t.push({
            name: i,
            tweens: H0(e[i], n)
        });
        return t
    }

    function Q0(n, e) {
        var t = {};
        for (var r in n) {
            var i = Bu(n[r], e);
            Le.arr(i) && (i = i.map(function(s) {
                return Bu(s, e)
            }), i.length === 1 && (i = i[0])), t[r] = i
        }
        return t.duration = parseFloat(t.duration), t.delay = parseFloat(t.delay), t
    }

    function Y0(n, e) {
        var t;
        return n.tweens.map(function(r) {
            var i = Q0(r, e),
                s = i.value,
                o = Le.arr(s) ? s[1] : s,
                l = Vi(o),
                a = Fu(e.target, n.name, l, e),
                c = t ? t.to.original : a,
                f = Le.arr(s) ? s[0] : c,
                h = Vi(f) || Vi(a),
                m = l || h;
            return Le.und(o) && (o = c), i.from = Fh(f, m), i.to = Fh(Gu(o, f), m), i.start = t ? t.end : 0, i.end = i.start + i.delay + i.duration + i.endDelay, i.easing = Iu(i.easing, i.duration), i.isPath = Le.pth(s), i.isColor = Le.col(i.from.original), i.isColor && (i.round = 1), t = i, i
        })
    }
    var kh = {
        css: function(n, e, t) {
            return n.style[e] = t
        },
        attribute: function(n, e, t) {
            return n.setAttribute(e, t)
        },
        object: function(n, e, t) {
            return n[e] = t
        },
        transform: function(n, e, t, r, i) {
            if (r.list.set(e, t), e === r.last || i) {
                var s = "";
                r.list.forEach(function(o, l) {
                    s += l + "(" + o + ") "
                }), n.style.transform = s
            }
        }
    };

    function Uh(n, e) {
        var t = zh(n);
        t.forEach(function(r) {
            for (var i in e) {
                var s = Bu(e[i], r),
                    o = r.target,
                    l = Vi(s),
                    a = Fu(o, i, l, r),
                    c = l || Vi(a),
                    f = Gu(Ph(s, c), a),
                    h = Ru(o, i);
                kh[h](o, i, f, r.transforms, !0)
            }
        })
    }

    function K0(n, e) {
        var t = Ru(n.target, e.name);
        if (t) {
            var r = Y0(e, n),
                i = r[r.length - 1];
            return {
                type: t,
                property: e.name,
                animatable: n,
                tweens: r,
                duration: i.end,
                delay: r[0].delay,
                endDelay: i.endDelay
            }
        }
    }

    function X0(n, e) {
        return Nl(Cl(n.map(function(t) {
            return e.map(function(r) {
                return K0(t, r)
            })
        })), function(t) {
            return !Le.und(t)
        })
    }

    function jh(n, e) {
        var t = n.length,
            r = function(s) {
                return s.timelineOffset ? s.timelineOffset : 0
            },
            i = {};
        return i.duration = t ? Math.max.apply(Math, n.map(function(s) {
            return r(s) + s.duration
        })) : e.duration, i.delay = t ? Math.min.apply(Math, n.map(function(s) {
            return r(s) + s.delay
        })) : e.delay, i.endDelay = t ? i.duration - Math.max.apply(Math, n.map(function(s) {
            return r(s) + s.duration - s.endDelay
        })) : e.endDelay, i
    }
    var Vh = 0;

    function q0(n) {
        var e = Pu(Ch, n),
            t = Pu(Mu, n),
            r = J0(t, n),
            i = zh(n.targets),
            s = X0(i, r),
            o = jh(s, t),
            l = Vh;
        return Vh++, Tl(e, {
            id: l,
            children: [],
            animatables: i,
            animations: s,
            duration: o.duration,
            delay: o.delay,
            endDelay: o.endDelay
        })
    }
    var wr = [],
        Hh = [],
        El, Z0 = function() {
            function n() {
                El = requestAnimationFrame(e)
            }

            function e(t) {
                var r = wr.length;
                if (r) {
                    for (var i = 0; i < r;) {
                        var s = wr[i];
                        if (!s.paused) s.tick(t);
                        else {
                            var o = wr.indexOf(s);
                            o > -1 && (wr.splice(o, 1), r = wr.length)
                        }
                        i++
                    }
                    n()
                } else El = cancelAnimationFrame(El)
            }
            return n
        }();

    function $0() {
        document.hidden ? (wr.forEach(function(n) {
            return n.pause()
        }), Hh = wr.slice(0), Rt.running = wr = []) : Hh.forEach(function(n) {
            return n.play()
        })
    }
    typeof document != "undefined" && document.addEventListener("visibilitychange", $0);

    function Rt(n) {
        n === void 0 && (n = {});
        var e = 0,
            t = 0,
            r = 0,
            i, s = 0,
            o = null;

        function l(S) {
            var E = window.Promise && new Promise(function(M) {
                return o = M
            });
            return S.finished = E, E
        }
        var a = q0(n),
            c = l(a);

        function f() {
            var S = a.direction;
            S !== "alternate" && (a.direction = S !== "normal" ? "normal" : "reverse"), a.reversed = !a.reversed, i.forEach(function(E) {
                return E.reversed = a.reversed
            })
        }

        function h(S) {
            return a.reversed ? a.duration - S : S
        }

        function m() {
            e = 0, t = h(a.currentTime) * (1 / Rt.speed)
        }

        function v(S, E) {
            E && E.seek(S - E.timelineOffset)
        }

        function g(S) {
            if (a.reversePlayback)
                for (var M = s; M--;) v(S, i[M]);
            else
                for (var E = 0; E < s; E++) v(S, i[E])
        }

        function y(S) {
            var E = 0,
                M = a.animations,
                L = M.length;
            for (a.reversePlayback === !0 && a.rewind === !1 && (S = a.duration - S); E < L;) {
                var I = M[E],
                    z = I.animatable,
                    O = I.tweens,
                    X = O.length - 1,
                    k = O[X];
                X && (k = Nl(O, function(Se) {
                    return S < Se.end
                })[0] || k);
                for (var Q = Ni(S - k.start - k.delay, 0, k.duration) / k.duration, te = isNaN(Q) ? 1 : k.easing(Q), Z = k.to.strings, le = k.round, B = [], U = k.to.numbers.length, G = void 0, V = 0; V < U; V++) {
                    var j = void 0;
                    if (a.reversePlayback === !0 && a.rewind === !1) var ne = k.to.numbers[V],
                        F = k.from.numbers[V] || 0;
                    else var F = k.to.numbers[V],
                        ne = k.from.numbers[V] || 0;
                    k.isPath ? j = V0(k.value, te * F) : j = ne + te * (F - ne), le && (k.isColor && V > 2 || (j = Math.round(j * le) / le)), B.push(j)
                }
                var Y = Z.length;
                if (!Y) G = B[0];
                else {
                    G = Z[0];
                    for (var $ = 0; $ < Y; $++) {
                        var re = Z[$],
                            fe = Z[$ + 1],
                            ye = B[$];
                        isNaN(ye) || (fe ? G += ye + fe : G += ye + " ")
                    }
                }
                kh[I.type](z.target, I.property, G, z.transforms), I.currentValue = G, E++
            }
        }

        function A(S) {
            a[S] && !a.passThrough && a[S](a)
        }

        function w() {
            a.remaining && a.remaining !== !0 && a.remaining--
        }

        function C(S) {
            var E = a.duration,
                M = a.delay,
                L = E - a.endDelay,
                I = h(S);
            a.progress = Ni(I / E * 100, 0, 100), a.reversePlayback = I < a.currentTime, i && g(I), !a.began && a.currentTime > 0 && (a.began = !0, A("begin")), !a.loopBegan && a.currentTime > 0 && (a.loopBegan = !0, A("loopBegin")), I <= M && a.currentTime !== 0 && y(0), (I >= L && a.currentTime !== E || !E) && y(E), I > M && I < L ? (a.changeBegan || (a.changeBegan = !0, a.changeCompleted = !1, A("changeBegin")), A("change"), y(I)) : a.changeBegan && (a.changeCompleted = !0, a.changeBegan = !1, A("changeComplete")), a.currentTime = Ni(I, 0, E), a.began && A("update"), S >= E && (t = 0, w(), a.remaining ? (e = r, A("loopComplete"), a.loopBegan = !1, a.direction === "alternate" && f()) : (a.paused = !0, a.completed || (a.completed = !0, A("loopComplete"), A("complete"), !a.passThrough && "Promise" in window && (o(), c = l(a)))))
        }
        return a.reset = function() {
            var S = a.direction;
            a.passThrough = !1, a.currentTime = 0, a.progress = 0, a.paused = !0, a.began = !1, a.loopBegan = !1, a.changeBegan = !1, a.completed = !1, a.changeCompleted = !1, a.reversePlayback = !1, a.reversed = S === "reverse", a.remaining = a.loop, i = a.children, s = i.length;
            for (var E = s; E--;) a.children[E].reset();
            (a.reversed && a.loop !== !0 || S === "alternate" && a.loop === 1) && a.remaining++, y(a.reversed ? a.duration : 0)
        }, a.set = function(S, E) {
            return Uh(S, E), a
        }, a.tick = function(S) {
            r = S, e || (e = r), C((r + (t - e)) * Rt.speed)
        }, a.seek = function(S) {
            C(h(S))
        }, a.pause = function() {
            a.paused = !0, m()
        }, a.play = function() {
            !a.paused || (a.completed && a.reset(), a.paused = !1, wr.push(a), m(), El || Z0())
        }, a.reverse = function() {
            f(), a.completed = !a.reversed, m()
        }, a.restart = function() {
            a.reset(), a.play()
        }, a.reset(), a.autoplay && a.play(), a
    }

    function Wh(n, e) {
        for (var t = e.length; t--;) Lu(n, e[t].animatable.target) && e.splice(t, 1)
    }

    function eA(n) {
        for (var e = Gh(n), t = wr.length; t--;) {
            var r = wr[t],
                i = r.animations,
                s = r.children;
            Wh(e, i);
            for (var o = s.length; o--;) {
                var l = s[o],
                    a = l.animations;
                Wh(e, a), !a.length && !l.children.length && s.splice(o, 1)
            }!i.length && !s.length && r.pause()
        }
    }

    function tA(n, e) {
        e === void 0 && (e = {});
        var t = e.direction || "normal",
            r = e.easing ? Iu(e.easing) : null,
            i = e.grid,
            s = e.axis,
            o = e.from || 0,
            l = o === "first",
            a = o === "center",
            c = o === "last",
            f = Le.arr(n),
            h = parseFloat(f ? n[0] : n),
            m = f ? parseFloat(n[1]) : 0,
            v = Vi(f ? n[1] : n) || 0,
            g = e.start || 0 + (f ? h : 0),
            y = [],
            A = 0;
        return function(w, C, S) {
            if (l && (o = 0), a && (o = (S - 1) / 2), c && (o = S - 1), !y.length) {
                for (var E = 0; E < S; E++) {
                    if (!i) y.push(Math.abs(o - E));
                    else {
                        var M = a ? (i[0] - 1) / 2 : o % i[0],
                            L = a ? (i[1] - 1) / 2 : Math.floor(o / i[0]),
                            I = E % i[0],
                            z = Math.floor(E / i[0]),
                            O = M - I,
                            X = L - z,
                            k = Math.sqrt(O * O + X * X);
                        s === "x" && (k = -O), s === "y" && (k = -X), y.push(k)
                    }
                    A = Math.max.apply(Math, y)
                }
                r && (y = y.map(function(te) {
                    return r(te / A) * A
                })), t === "reverse" && (y = y.map(function(te) {
                    return s ? te < 0 ? te * -1 : -te : Math.abs(A - te)
                }))
            }
            var Q = f ? (m - h) / A : h;
            return g + Q * (Math.round(y[C] * 100) / 100) + v
        }
    }

    function rA(n) {
        n === void 0 && (n = {});
        var e = Rt(n);
        return e.duration = 0, e.add = function(t, r) {
            var i = wr.indexOf(e),
                s = e.children;
            i > -1 && wr.splice(i, 1);

            function o(m) {
                m.passThrough = !0
            }
            for (var l = 0; l < s.length; l++) o(s[l]);
            var a = Tl(t, Pu(Mu, n));
            a.targets = a.targets || n.targets;
            var c = e.duration;
            a.autoplay = !1, a.direction = e.direction, a.timelineOffset = Le.und(r) ? c : Gu(r, c), o(e), a.rewind = e.rewind, e.seek(a.timelineOffset);
            var f = Rt(a);
            o(f), s.push(f);
            var h = jh(s, n);
            return e.delay = h.delay, e.endDelay = h.endDelay, e.duration = h.duration, e.seek(0), e.reset(), e.autoplay && e.play(), e
        }, e
    }
    Rt.version = "3.2.0";
    Rt.speed = 1;
    Rt.running = wr;
    Rt.remove = eA;
    Rt.get = Fu;
    Rt.set = Uh;
    Rt.convertPx = Ou;
    Rt.path = j0;
    Rt.setDashoffset = k0;
    Rt.stagger = tA;
    Rt.timeline = rA;
    Rt.easing = Iu;
    Rt.penner = Mh;
    Rt.random = function(n, e) {
        return Math.floor(Math.random() * (e - n + 1)) + n
    };
    var $o = Rt;
    var ku = W(J());
    var Uu = class {
        constructor(e) {
            this.i = e
        }
        updateObject() {
            this.i.selectedState !== void 0 && this.i.states[this.i.selectedState].updateMatrix(this.i.object)
        }
        updateCamera() {
            this.i.selectedState === void 0 || this.i.object.objectType !== "CombinedCamera" || (this.i.states[this.i.selectedState].updateMatrix(this.i.object), this.i.states[this.i.selectedState].updateCamera(this.i.object))
        }
        updateGeometry() {
            this.i.selectedState === void 0 || br(this.i.object) === !1 || (this.i.states[this.i.selectedState].updateMatrix(this.i.object), this.i.states[this.i.selectedState].updateGeometry(this.i.object))
        }
        updateSceneGraph(e, t) {
            let r = new ku.Matrix4,
                i = new ku.Matrix4;
            e.updateWorldMatrix(!0, !1), i.copy(e.matrixWorld).invert();
            for (let s = 0, o = this.i.states.length; s < o; ++s) {
                let l = this.i.states[s];
                r.copy(i), this.i.object.parent !== null && (this.i.object.parent.updateWorldMatrix(!0, !1), r.multiply(this.i.object.parent.matrixWorld)), l.hiddenMatrix.premultiply(r)
            }
        }
        updateMaterialLayer(e) {
            if (this.i.selectedState === void 0 || br(this.i.object) === !1) return;
            let r = this.i.object.selectedMaterial,
                i = this.i.states[this.i.selectedState];
            (r !== void 0 ? i.material[r] : i.material).layersList.find(l => l.id === e.id)?.copy(e)
        }
        pushMaterialLayer(e) {
            if (this.i.states.length === 0 || br(this.i.object) === !1) return;
            let t = this.i.object;
            if (t.material instanceof Array) {
                let r = t.selectedMaterial;
                if (r !== void 0)
                    for (let i = 0, s = this.i.states.length; i < s; ++i) {
                        let o = e.clone();
                        this.i.selectedState !== i && (o.uniforms[`f${o.id}_alpha`].value = 0), this.i.states[i].material[r].layersList.push(o)
                    }
            } else
                for (let r = 0, i = this.i.states.length; r < i; ++r) {
                    let s = e.clone();
                    this.i.selectedState !== r && (s.uniforms[`f${s.id}_alpha`].value = 0), this.i.states[r].material.layersList.push(s)
                }
        }
        popMaterialLayer() {
            if (this.i.states.length === 0 || br(this.i.object) === !1) return;
            let e = this.i.object;
            if (e.material instanceof Array) {
                let t = e.selectedMaterial;
                if (t !== void 0)
                    for (let r = 0, i = this.i.states.length; r < i; ++r) this.i.states[r].material[t].layersList.pop()
            } else
                for (let t = 0, r = this.i.states.length; t < r; ++t) this.i.states[t].material.layersList.pop()
        }
        removeMaterialLayer(e) {
            if (this.i.states.length === 0 || br(this.i.object) === !1) return null;
            let t = this.i.object,
                r = [];
            if (t.material instanceof Array)
                for (let i = 0, s = this.i.states.length; i < s; ++i) {
                    let o = t.selectedMaterial;
                    if (o !== void 0) {
                        let a = this.i.states[i].material[o];
                        r.push({
                            layer: a.layersList[e]
                        }), a.layersList.splice(e, 1)
                    }
                } else
                    for (let i = 0, s = this.i.states.length; i < s; ++i) {
                        let l = this.i.states[i].material;
                        r.push({
                            layer: l.layersList[e]
                        }), l.layersList.splice(e, 1)
                    }
            return {
                states: r,
                pos: e
            }
        }
        restoreMaterialLayerRemoved(e) {
            if (this.i.states.length === 0 || br(this.i.object) === !1) return;
            let t = this.i.object;
            if (t.material instanceof Array)
                for (let r = 0, i = this.i.states.length; r < i; ++r) {
                    let s = t.selectedMaterial;
                    s !== void 0 && this.i.states[r].material[s].layersList.splice(e.pos, 0, e.states[r].layer)
                } else
                    for (let r = 0, i = this.i.states.length; r < i; ++r) this.i.states[r].material.layersList.splice(e.pos, 0, e.states[r].layer)
        }
        changeMaterialLayer(e) {
            if (this.i.states.length === 0 || br(this.i.object) === !1) return null;
            let t = this.i.object,
                r = [],
                i = 0;
            if (t.material instanceof Array) {
                let s = t.selectedMaterial;
                if (s !== void 0) {
                    let a = this.i.states[Number(this.i.selectedState)].material[s].layersList;
                    for (let c = 0, f = a.length; c < f; ++c)
                        if (a[c].id === e.id) {
                            i = c;
                            break
                        } for (let c = 0, f = this.i.states.length; c < f; ++c) {
                        let h = this.i.states[c].material[s].layersList[i],
                            m = e.clone();
                        this.i.selectedState !== c && (m.uniforms[`f${m.id}_alpha`].value = Number(h.uniforms[`f${h.id}_alpha`].value)), this.i.states[c].material[s].layersList[i] = m, r.push({
                            layer: h
                        })
                    }
                }
            } else {
                let s = this.i.states[Number(this.i.selectedState)].material.layersList;
                for (let o = 0, l = s.length; o < l; ++o)
                    if (s[o].id === e.id) {
                        i = o;
                        break
                    } for (let o = 0, l = this.i.states.length; o < l; ++o) {
                    let a = this.i.states[o].material.layersList[i],
                        c = e.clone();
                    this.i.selectedState !== o && (c.uniforms[`f${c.id}_alpha`].value = Number(a.uniforms[`f${a.id}_alpha`].value)), this.i.states[o].material.layersList[i] = c, r.push({
                        layer: a
                    })
                }
            }
            return {
                states: r,
                pos: i
            }
        }
        restoreMaterialLayerChanged(e) {
            if (this.i.states.length === 0 || br(this.i.object) === !1) return;
            let t = this.i.object;
            if (t.material instanceof Array) {
                let r = t.selectedMaterial;
                if (r !== void 0)
                    for (let i = 0, s = this.i.states.length; i < s; ++i) this.i.states[i].material[r].layersList[e.pos] = e.states[i].layer
            } else
                for (let r = 0, i = this.i.states.length; r < i; ++r) this.i.states[r].material.layersList[e.pos] = e.states[r].layer
        }
        moveMaterialLayer(e, t) {
            if (this.i.states.length === 0 || br(this.i.object) === !1) return;
            let r = this.i.object;
            if (r.material instanceof Array) {
                let i = r.selectedMaterial;
                if (i !== void 0)
                    for (let s = 0, o = this.i.states.length; s < o; ++s) {
                        let l = this.i.states[s].material[i].layersList,
                            a = l.splice(t, 1)[0];
                        l.splice(e, 0, a)
                    }
            } else
                for (let i = 0, s = this.i.states.length; i < s; ++i) {
                    let o = this.i.states[i].material.layersList,
                        l = o.splice(t, 1)[0];
                    o.splice(e, 0, l)
                }
        }
        restoreMaterialLayerMoved(e, t) {
            this.moveMaterialLayer(e, t)
        }
        setMaterialLayers(e) {
            let t = this.i.object,
                r = [];
            if (t.material instanceof Array) {
                let i = t.selectedMaterial;
                if (i !== void 0)
                    for (let s = 0, o = this.i.states.length; s < o; ++s) {
                        let l = this.i.states[s].material[i];
                        r.push({
                            layersList: l.layersList
                        });
                        let a = e.head;
                        for (l.layersList = []; a !== void 0;) l.layersList.push(a.clone()), a = a.next
                    }
            } else
                for (let i = 0, s = this.i.states.length; i < s; ++i) {
                    let o = this.i.states[i].material;
                    r.push({
                        layersList: o.layersList
                    });
                    let l = e.head;
                    for (o.layersList = []; l !== void 0;) o.layersList.push(l.clone()), l = l.next
                }
            return {
                states: r
            }
        }
        restoreMaterialLayersSet(e) {
            let t = this.i.object;
            if (t.material instanceof Array) {
                let r = t.selectedMaterial;
                if (r !== void 0)
                    for (let i = 0, s = this.i.states.length; i < s; ++i) this.i.states[i].material[r].layersList = e.states[i].layersList
            } else
                for (let r = 0, i = this.i.states.length; r < i; ++r) this.i.states[r].material.layersList = e.states[r].layersList
        }
    };
    var un = W(J());
    var Us = W(J());

    function Jh(n) {
        let e = [],
            t = n.groups,
            r = n.getAttribute("position").array,
            i = n.getAttribute("normal").array,
            s = n.getAttribute("uv")?.array;
        return t.forEach(o => {
            let l = o.count,
                a = new Us.BufferGeometry,
                c = new Float32Array(l * 3),
                f = new Float32Array(l * 3),
                h = new Float32Array(l * 2);
            for (let m = 0; m < l; m++) {
                let v = 3 * (o.start + m),
                    g = 3 * m;
                if (c[g] = r[v], c[g + 1] = r[v + 1], c[g + 2] = r[v + 2], f[g] = i[v], f[g + 1] = i[v + 1], f[g + 2] = i[v + 2], s) {
                    let y = 2 * (o.start + m),
                        A = 2 * m;
                    h[A] = s[y], h[A + 1] = s[y + 1]
                }
            }
            a.setAttribute("position", new Us.Float32BufferAttribute(c, 3)), a.setAttribute("normal", new Us.Float32BufferAttribute(f, 3)), s && a.setAttribute("uv", new Us.Float32BufferAttribute(h, 2)), e.push(a)
        }), e
    }
    var Qh = W(J()),
        cr = class {
            constructor() {
                this.encoderPath = "", this.encoderConfig = {}, this.encoderPending = null
            }
            setEncoderPath(e) {
                return this.encoderPath = e, this
            }
            setEncoderConfig(e) {
                return this.encoderConfig = e, this
            }
            _loadLibrary(e, t) {
                let r = new Qh.FileLoader;
                return r.setPath(this.encoderPath), r.setResponseType(t), r.setWithCredentials(this.withCredentials), new Promise((i, s) => {
                    r.load(e, i, void 0, s)
                })
            }
            _loadScript(e) {
                return new Promise((t, r) => {
                    let i = document.createElement("script");
                    i.onload = t, i.onerror = r, i.src = this.encoderPath + e, document.head.appendChild(i)
                })
            }
            preload() {
                return this._initEncoder().then(() => this)
            }
            _initEncoder() {
                if (this.encoderPending) return this.encoderPending;
                let e = typeof WebAssembly != "object" || this.encoderConfig.type === "js",
                    t = [];
                return e ? t.push(this._loadScript("draco_encoder.js")) : (t.push(this._loadScript("draco_encoder_wrapper.js")), t.push(this._loadLibrary("draco_encoder.wasm", "arraybuffer"))), this.encoderPending = Promise.all(t).then(r => {
                    e || (this.encoderConfig.wasmBinary = r[1])
                }), this.encoderPending
            }
            async parse(e, t = {
                decodeSpeed: 5,
                encodeSpeed: 5,
                encoderMethod: cr.MESH_EDGEBREAKER_ENCODING,
                quantization: [16, 8, 8, 8, 8],
                exportUvs: !0,
                exportNormals: !0,
                exportColor: !1
            }) {
                if (e.isBufferGeometry === !0) throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");
                if (await this._initEncoder(), DracoEncoderModule === void 0) throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");
                let r = e.geometry,
                    i = await DracoEncoderModule(this.encoderConfig),
                    s = new i.Encoder,
                    o, l, a = {};
                if (r.isBufferGeometry !== !0) throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");
                if (e.isMesh === !0) {
                    o = new i.MeshBuilder, l = new i.Mesh;
                    let g = r.getAttribute("position");
                    a.POSITION = o.AddFloatAttributeToMesh(l, i.POSITION, g.count, g.itemSize, g.array);
                    let y = r.getIndex();
                    if (y !== null) o.AddFacesToMesh(l, y.count / 3, y.array);
                    else {
                        let A = new(g.count > 65535 ? Uint32Array : Uint16Array)(g.count);
                        for (let w = 0; w < A.length; w++) A[w] = w;
                        o.AddFacesToMesh(l, g.count, A)
                    }
                    if (t.exportNormals === !0) {
                        let A = r.getAttribute("normal");
                        A !== void 0 && (a.NORMAL = o.AddFloatAttributeToMesh(l, i.NORMAL, A.count, A.itemSize, A.array))
                    }
                    if (t.exportUvs === !0) {
                        let A = r.getAttribute("uv");
                        A !== void 0 && (a.TEXCOORD_0 = o.AddFloatAttributeToMesh(l, i.TEX_COORD, A.count, A.itemSize, A.array))
                    }
                    if (t.exportColor === !0) {
                        let A = r.getAttribute("color");
                        A !== void 0 && (a.COLOR_0 = o.AddFloatAttributeToMesh(l, i.COLOR, A.count, A.itemSize, A.array))
                    }
                } else if (e.isPoints === !0) {
                    o = new i.PointCloudBuilder, l = new i.PointCloud;
                    let g = r.getAttribute("position");
                    if (o.AddFloatAttribute(l, i.POSITION, g.count, g.itemSize, g.array), t.exportColor === !0) {
                        let y = r.getAttribute("color");
                        y !== void 0 && o.AddFloatAttribute(l, i.COLOR, y.count, y.itemSize, y.array)
                    }
                } else throw new Error("DRACOExporter: Unsupported object type: " + e.type);
                let c = new i.DracoInt8Array,
                    f = t.encodeSpeed !== void 0 ? t.encodeSpeed : 5,
                    h = t.decodeSpeed !== void 0 ? t.decodeSpeed : 5;
                if (s.SetSpeedOptions(f, h), t.encoderMethod !== void 0 && s.SetEncodingMethod(t.encoderMethod), t.quantization !== void 0)
                    for (let g = 0; g < 5; g++) t.quantization[g] !== void 0 && s.SetAttributeQuantization(g, t.quantization[g]);
                let m;
                if (e.isMesh === !0 ? m = s.EncodeMeshToDracoBuffer(l, c) : m = s.EncodePointCloudToDracoBuffer(l, !0, c), i.destroy(l), m === 0) throw new Error("THREE.DRACOExporter: Draco encoding failed.");
                let v = new Int8Array(new ArrayBuffer(m));
                for (let g = 0; g < m; g++) v[g] = c.GetValue(g);
                return i.destroy(c), i.destroy(s), i.destroy(o), {
                    buffer: v,
                    attributeIDs: a
                }
            }
        };
    cr.MESH_EDGEBREAKER_ENCODING = 1;
    cr.MESH_SEQUENTIAL_ENCODING = 0;
    cr.POINT_CLOUD = 0;
    cr.TRIANGULAR_MESH = 1;
    cr.INVALID = -1;
    cr.POSITION = 0;
    cr.NORMAL = 1;
    cr.COLOR = 2;
    cr.TEX_COORD = 3;
    cr.GENERIC = 4;
    var Be = W(J()),
        ea = class {
            constructor() {
                this.dracoExporter = null, this.pluginCallbacks = [], this.register(function(e) {
                    return new em(e)
                }), this.register(function(e) {
                    return new tm(e)
                }), this.register(function(e) {
                    return new rm(e)
                })
            }
            register(e) {
                return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
            }
            unregister(e) {
                return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
            }
            setDRACOExporter(e) {
                return this.dracoExporter = e, this
            }
            parse(e, t, r, i) {
                let s = new $h,
                    o = [];
                for (let l = 0, a = this.pluginCallbacks.length; l < a; l++) o.push(this.pluginCallbacks[l](s));
                i && i.draco && (s.dracoExporter = this.dracoExporter), s.setPlugins(o), s.write(e, t, i).catch(l => r(l))
            }
        },
        vt = {
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123,
            FLOAT: 5126,
            UNSIGNED_INT: 5125,
            ARRAY_BUFFER: 34962,
            ELEMENT_ARRAY_BUFFER: 34963,
            NEAREST: 9728,
            LINEAR: 9729,
            NEAREST_MIPMAP_NEAREST: 9984,
            LINEAR_MIPMAP_NEAREST: 9985,
            NEAREST_MIPMAP_LINEAR: 9986,
            LINEAR_MIPMAP_LINEAR: 9987,
            CLAMP_TO_EDGE: 33071,
            MIRRORED_REPEAT: 33648,
            REPEAT: 10497
        },
        Br = {};
    Br[Be.NearestFilter] = vt.NEAREST;
    Br[Be.NearestMipmapNearestFilter] = vt.NEAREST_MIPMAP_NEAREST;
    Br[Be.NearestMipmapLinearFilter] = vt.NEAREST_MIPMAP_LINEAR;
    Br[Be.LinearFilter] = vt.LINEAR;
    Br[Be.LinearMipmapNearestFilter] = vt.LINEAR_MIPMAP_NEAREST;
    Br[Be.LinearMipmapLinearFilter] = vt.LINEAR_MIPMAP_LINEAR;
    Br[Be.ClampToEdgeWrapping] = vt.CLAMP_TO_EDGE;
    Br[Be.RepeatWrapping] = vt.REPEAT;
    Br[Be.MirroredRepeatWrapping] = vt.MIRRORED_REPEAT;
    var Yh = {
            scale: "scale",
            position: "translation",
            quaternion: "rotation",
            morphTargetInfluences: "weights"
        },
        Kh = 12,
        iA = 1179937895,
        nA = 2,
        Xh = 8,
        sA = 1313821514,
        oA = 5130562;

    function ta(n, e) {
        return n.length === e.length && n.every(function(t, r) {
            return t === e[r]
        })
    }

    function aA(n) {
        if (window.TextEncoder !== void 0) return new TextEncoder().encode(n).buffer;
        let e = new Uint8Array(new ArrayBuffer(n.length));
        for (let t = 0, r = n.length; t < r; t++) {
            let i = n.charCodeAt(t);
            e[t] = i > 255 ? 32 : i
        }
        return e.buffer
    }

    function lA(n) {
        return ta(n.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }

    function cA(n, e, t) {
        let r = {
            min: new Array(n.itemSize).fill(Number.POSITIVE_INFINITY),
            max: new Array(n.itemSize).fill(Number.NEGATIVE_INFINITY)
        };
        for (let i = e; i < e + t; i++)
            for (let s = 0; s < n.itemSize; s++) {
                let o;
                n.itemSize > 4 ? o = n.array[i * n.itemSize + s] : s === 0 ? o = n.getX(i) : s === 1 ? o = n.getY(i) : s === 2 ? o = n.getZ(i) : s === 3 && (o = n.getW(i)), r.min[s] = Math.min(r.min[s], o), r.max[s] = Math.max(r.max[s], o)
            }
        return r
    }

    function qh(n) {
        return Math.ceil(n / 4) * 4
    }

    function ju(n, e = 0) {
        let t = qh(n.byteLength);
        if (t !== n.byteLength) {
            let r = new Uint8Array(t);
            if (r.set(new Uint8Array(n)), e !== 0)
                for (let i = n.byteLength; i < t; i++) r[i] = e;
            return r.buffer
        }
        return n
    }
    var Zh = null,
        $h = class {
            constructor() {
                this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map, this.skins = [], this.extensionsUsed = {}, this.uids = new Map, this.uid = 0, this.json = {
                    asset: {
                        version: "2.0",
                        generator: "THREE.GLTFExporter"
                    }
                }, this.cache = {
                    meshes: new Map,
                    attributes: new Map,
                    attributesNormalized: new Map,
                    materials: new Map,
                    textures: new Map,
                    images: new Map
                }
            }
            setPlugins(e) {
                this.plugins = e
            }
            async write(e, t, r) {
                this.options = Object.assign({}, {
                    binary: !1,
                    draco: !1,
                    trs: !1,
                    onlyVisible: !0,
                    truncateDrawRange: !0,
                    embedImages: !0,
                    maxTextureSize: 1 / 0,
                    animations: [],
                    includeCustomExtensions: !1
                }, r), this.options.animations.length > 0 && (this.options.trs = !0), await this.processInput(e);
                let i = this;
                Promise.all(this.pending).then(function() {
                    let s = i.buffers,
                        o = i.json,
                        l = i.options,
                        a = i.extensionsUsed,
                        c = new Blob(s, {
                            type: "application/octet-stream"
                        }),
                        f = Object.keys(a);
                    if (f.length > 0 && (o.extensionsUsed = f), o.buffers && o.buffers.length > 0 && (o.buffers[0].byteLength = c.size), l.binary === !0) {
                        let h = new window.FileReader;
                        h.readAsArrayBuffer(c), h.onloadend = function() {
                            let m = ju(h.result),
                                v = new DataView(new ArrayBuffer(Xh));
                            v.setUint32(0, m.byteLength, !0), v.setUint32(4, oA, !0);
                            let g = ju(aA(JSON.stringify(o)), 32),
                                y = new DataView(new ArrayBuffer(Xh));
                            y.setUint32(0, g.byteLength, !0), y.setUint32(4, sA, !0);
                            let A = new ArrayBuffer(Kh),
                                w = new DataView(A);
                            w.setUint32(0, iA, !0), w.setUint32(4, nA, !0);
                            let C = Kh + y.byteLength + g.byteLength + v.byteLength + m.byteLength;
                            w.setUint32(8, C, !0);
                            let S = new Blob([A, y, g, v, m], {
                                    type: "application/octet-stream"
                                }),
                                E = new window.FileReader;
                            E.readAsArrayBuffer(S), E.onloadend = function() {
                                t(E.result)
                            }
                        }
                    } else if (o.buffers && o.buffers.length > 0) {
                        let h = new window.FileReader;
                        h.readAsDataURL(c), h.onloadend = function() {
                            let m = h.result;
                            o.buffers[0].uri = m, t(o)
                        }
                    } else t(o)
                })
            }
            serializeUserData(e, t) {
                if (Object.keys(e.userData).length === 0) return;
                let r = this.options,
                    i = this.extensionsUsed;
                try {
                    let s = JSON.parse(JSON.stringify(e.userData));
                    if (r.includeCustomExtensions && s.gltfExtensions) {
                        t.extensions === void 0 && (t.extensions = {});
                        for (let o in s.gltfExtensions) t.extensions[o] = s.gltfExtensions[o], i[o] = !0;
                        delete s.gltfExtensions
                    }
                    Object.keys(s).length > 0 && (t.extras = s)
                } catch (s) {
                    console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + s.message)
                }
            }
            getUID(e) {
                return this.uids.has(e) || this.uids.set(e, this.uid++), this.uids.get(e)
            }
            isNormalizedNormalAttribute(e) {
                if (this.cache.attributesNormalized.has(e)) return !1;
                let r = new Be.Vector3;
                for (let i = 0, s = e.count; i < s; i++)
                    if (Math.abs(r.fromBufferAttribute(e, i).length() - 1) > 5e-4) return !1;
                return !0
            }
            createNormalizedNormalAttribute(e) {
                let t = this.cache;
                if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
                let r = e.clone(),
                    i = new Be.Vector3;
                for (let s = 0, o = r.count; s < o; s++) i.fromBufferAttribute(r, s), i.x === 0 && i.y === 0 && i.z === 0 ? i.setX(1) : i.normalize(), r.setXYZ(s, i.x, i.y, i.z);
                return t.attributesNormalized.set(e, r), r
            }
            applyTextureTransform(e, t) {
                let r = !1,
                    i = {};
                (t.offset.x !== 0 || t.offset.y !== 0) && (i.offset = t.offset.toArray(), r = !0), t.rotation !== 0 && (i.rotation = t.rotation, r = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (i.scale = t.repeat.toArray(), r = !0), r && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = i, this.extensionsUsed.KHR_texture_transform = !0)
            }
            processBuffer(e) {
                let t = this.json,
                    r = this.buffers;
                return t.buffers || (t.buffers = [{
                    byteLength: 0
                }]), r.push(e), 0
            }
            processBufferView(e, t, r, i, s) {
                let o = this.json;
                o.bufferViews || (o.bufferViews = []);
                let l;
                t === vt.UNSIGNED_BYTE ? l = 1 : t === vt.UNSIGNED_SHORT ? l = 2 : l = 4;
                let a = qh(i * e.itemSize * l),
                    c = new DataView(new ArrayBuffer(a)),
                    f = 0;
                for (let v = r; v < r + i; v++)
                    for (let g = 0; g < e.itemSize; g++) {
                        let y;
                        e.itemSize > 4 ? y = e.array[v * e.itemSize + g] : g === 0 ? y = e.getX(v) : g === 1 ? y = e.getY(v) : g === 2 ? y = e.getZ(v) : g === 3 && (y = e.getW(v)), t === vt.FLOAT ? c.setFloat32(f, y, !0) : t === vt.UNSIGNED_INT ? c.setUint32(f, y, !0) : t === vt.UNSIGNED_SHORT ? c.setUint16(f, y, !0) : t === vt.UNSIGNED_BYTE && c.setUint8(f, y), f += l
                    }
                let h = {
                    buffer: this.processBuffer(c.buffer),
                    byteOffset: this.byteOffset,
                    byteLength: a
                };
                return s !== void 0 && (h.target = s), s === vt.ARRAY_BUFFER && (h.byteStride = e.itemSize * l), this.byteOffset += a, o.bufferViews.push(h), {
                    id: o.bufferViews.length - 1,
                    byteLength: 0
                }
            }
            processBufferViewImage(e) {
                let t = this,
                    r = t.json;
                return r.bufferViews || (r.bufferViews = []), new Promise(function(i) {
                    let s = new window.FileReader;
                    s.readAsArrayBuffer(e), s.onloadend = function() {
                        let o = ju(s.result),
                            l = {
                                buffer: t.processBuffer(o),
                                byteOffset: t.byteOffset,
                                byteLength: o.byteLength
                            };
                        t.byteOffset += o.byteLength, i(r.bufferViews.push(l) - 1)
                    }
                })
            }
            processAccessor(e, t, r, i) {
                let s = this.options,
                    o = this.json,
                    l = {
                        1: "SCALAR",
                        2: "VEC2",
                        3: "VEC3",
                        4: "VEC4",
                        16: "MAT4"
                    },
                    a;
                if (e.array.constructor === Float32Array) a = vt.FLOAT;
                else if (e.array.constructor === Uint32Array) a = vt.UNSIGNED_INT;
                else if (e.array.constructor === Uint16Array) a = vt.UNSIGNED_SHORT;
                else if (e.array.constructor === Uint8Array) a = vt.UNSIGNED_BYTE;
                else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
                if (r === void 0 && (r = 0), i === void 0 && (i = e.count), s.truncateDrawRange && t !== void 0 && t.index === null) {
                    let h = r + i,
                        m = t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count;
                    r = Math.max(r, t.drawRange.start), i = Math.min(h, m) - r, i < 0 && (i = 0)
                }
                if (i === 0) return null;
                let c = cA(e, r, i),
                    f = {
                        componentType: a,
                        count: i,
                        max: c.max,
                        min: c.min,
                        type: l[e.itemSize]
                    };
                if (!this.options.draco) {
                    let h;
                    t !== void 0 && (h = e === t.index ? vt.ELEMENT_ARRAY_BUFFER : vt.ARRAY_BUFFER);
                    let m = this.processBufferView(e, a, r, i, h);
                    f.bufferView = m.id, f.byteOffset = m.byteOffset
                }
                return e.normalized === !0 && (f.normalized = !0), o.accessors || (o.accessors = []), o.accessors.push(f) - 1
            }
            processImage(e, t, r) {
                let i = this,
                    s = i.cache,
                    o = i.json,
                    l = i.options,
                    a = i.pending;
                s.images.has(e) || s.images.set(e, {});
                let c = s.images.get(e),
                    f = t === Be.RGBAFormat ? "image/png" : "image/jpeg",
                    h = f + ":flipY/" + r.toString();
                if (c[h] !== void 0) return c[h];
                o.images || (o.images = []);
                let m = {
                    mimeType: f
                };
                if (l.embedImages) {
                    let g = Zh = Zh || document.createElement("canvas");
                    g.width = Math.min(e.width, l.maxTextureSize), g.height = Math.min(e.height, l.maxTextureSize);
                    let y = g.getContext("2d");
                    if (r === !0 && (y.translate(0, g.height), y.scale(1, -1)), typeof HTMLImageElement != "undefined" && e instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && e instanceof HTMLCanvasElement || typeof OffscreenCanvas != "undefined" && e instanceof OffscreenCanvas || typeof ImageBitmap != "undefined" && e instanceof ImageBitmap) y.drawImage(e, 0, 0, g.width, g.height);
                    else {
                        t !== Be.RGBAFormat && t !== Be.RGBFormat && console.error("GLTFExporter: Only RGB and RGBA formats are supported."), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
                        let A = new Uint8ClampedArray(e.height * e.width * 4);
                        if (t === Be.RGBAFormat)
                            for (let w = 0; w < A.length; w += 4) A[w + 0] = e.data[w + 0], A[w + 1] = e.data[w + 1], A[w + 2] = e.data[w + 2], A[w + 3] = e.data[w + 3];
                        else
                            for (let w = 0, C = 0; w < A.length; w += 4, C += 3) A[w + 0] = e.data[C + 0], A[w + 1] = e.data[C + 1], A[w + 2] = e.data[C + 2], A[w + 3] = 255;
                        y.putImageData(new ImageData(A, e.width, e.height), 0, 0)
                    }
                    l.binary === !0 ? a.push(new Promise(function(A) {
                        g.toBlob(function(w) {
                            i.processBufferViewImage(w).then(function(C) {
                                m.bufferView = C, A()
                            })
                        }, f)
                    })) : m.uri = g.toDataURL(f)
                } else m.uri = e.src;
                let v = o.images.push(m) - 1;
                return c[h] = v, v
            }
            processSampler(e) {
                let t = this.json;
                t.samplers || (t.samplers = []);
                let r = {
                    magFilter: Br[e.magFilter],
                    minFilter: Br[e.minFilter],
                    wrapS: Br[e.wrapS],
                    wrapT: Br[e.wrapT]
                };
                return t.samplers.push(r) - 1
            }
            processTexture(e) {
                let t = this.cache,
                    r = this.json;
                if (t.textures.has(e)) return t.textures.get(e);
                r.textures || (r.textures = []);
                let i = {
                    sampler: this.processSampler(e),
                    source: this.processImage(e.image, e.format, e.flipY)
                };
                e.name && (i.name = e.name), this._invokeAll(function(o) {
                    o.writeTexture && o.writeTexture(e, i)
                });
                let s = r.textures.push(i) - 1;
                return t.textures.set(e, s), s
            }
            processMaterial(e) {
                let t = this.cache,
                    r = this.json;
                if (t.materials.has(e)) return t.materials.get(e);
                if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
                r.materials || (r.materials = []);
                let i = {
                    pbrMetallicRoughness: {}
                };
                e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
                let s = e.color.toArray().concat([e.opacity]);
                if (ta(s, [1, 1, 1, 1]) || (i.pbrMetallicRoughness.baseColorFactor = s), e.isMeshStandardMaterial ? (i.pbrMetallicRoughness.metallicFactor = e.metalness, i.pbrMetallicRoughness.roughnessFactor = e.roughness) : (i.pbrMetallicRoughness.metallicFactor = .5, i.pbrMetallicRoughness.roughnessFactor = .5), e.metalnessMap || e.roughnessMap)
                    if (e.metalnessMap === e.roughnessMap) {
                        let l = {
                            index: this.processTexture(e.metalnessMap)
                        };
                        this.applyTextureTransform(l, e.metalnessMap), i.pbrMetallicRoughness.metallicRoughnessTexture = l
                    } else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");
                if (e.map) {
                    let l = {
                        index: this.processTexture(e.map)
                    };
                    this.applyTextureTransform(l, e.map), i.pbrMetallicRoughness.baseColorTexture = l
                }
                if (e.emissive) {
                    let l = e.emissive.clone().multiplyScalar(e.emissiveIntensity),
                        a = Math.max(l.r, l.g, l.b);
                    if (a > 1 && (l.multiplyScalar(1 / a), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), a > 0 && (i.emissiveFactor = l.toArray()), e.emissiveMap) {
                        let c = {
                            index: this.processTexture(e.emissiveMap)
                        };
                        this.applyTextureTransform(c, e.emissiveMap), i.emissiveTexture = c
                    }
                }
                if (e.normalMap) {
                    let l = {
                        index: this.processTexture(e.normalMap)
                    };
                    e.normalScale && e.normalScale.x !== -1 && (e.normalScale.x !== e.normalScale.y && console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."), l.scale = e.normalScale.x), this.applyTextureTransform(l, e.normalMap), i.normalTexture = l
                }
                if (e.aoMap) {
                    let l = {
                        index: this.processTexture(e.aoMap),
                        texCoord: 1
                    };
                    e.aoMapIntensity !== 1 && (l.strength = e.aoMapIntensity), this.applyTextureTransform(l, e.aoMap), i.occlusionTexture = l
                }
                e.transparent ? i.alphaMode = "BLEND" : e.alphaTest > 0 && (i.alphaMode = "MASK", i.alphaCutoff = e.alphaTest), e.side === Be.DoubleSide && (i.doubleSided = !0), e.name !== "" && (i.name = e.name), this.serializeUserData(e, i), this._invokeAll(function(l) {
                    l.writeMaterial && l.writeMaterial(e, i)
                });
                let o = r.materials.push(i) - 1;
                return t.materials.set(e, o), o
            }
            async processMesh(e) {
                let t = this.cache,
                    r = this.json,
                    i = [e.geometry.uuid];
                if (Array.isArray(e.material))
                    for (let S = 0, E = e.material.length; S < E; S++) i.push(e.material[S].uuid);
                else i.push(e.material.uuid);
                let s = i.join(":");
                if (t.meshes.has(s)) return t.meshes.get(s);
                let o = e.geometry,
                    l;
                if (e.isLineSegments ? l = vt.LINES : e.isLineLoop ? l = vt.LINE_LOOP : e.isLine ? l = vt.LINE_STRIP : e.isPoints ? l = vt.POINTS : l = e.material.wireframe ? vt.LINES : vt.TRIANGLES, o.isBufferGeometry !== !0) throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
                let a = {},
                    c = {},
                    f = [],
                    h = [],
                    m = {
                        uv: "TEXCOORD_0",
                        uv2: "TEXCOORD_1",
                        color: "COLOR_0",
                        skinWeight: "WEIGHTS_0",
                        skinIndex: "JOINTS_0"
                    },
                    v = o.getAttribute("normal");
                v !== void 0 && !this.isNormalizedNormalAttribute(v) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), o.setAttribute("normal", this.createNormalizedNormalAttribute(v)));
                let g = null;
                for (let S in o.attributes) {
                    if (S.substr(0, 5) === "morph") continue;
                    let E = o.attributes[S];
                    if (S = m[S] || S.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(S) || (S = "_" + S), t.attributes.has(this.getUID(E))) {
                        c[S] = t.attributes.get(this.getUID(E));
                        continue
                    }
                    g = null;
                    let L = E.array;
                    S === "JOINTS_0" && !(L instanceof Uint16Array) && !(L instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), g = new Be.BufferAttribute(new Uint16Array(L), E.itemSize, E.normalized));
                    let I = this.processAccessor(g || E, o);
                    I !== null && (c[S] = I, t.attributes.set(this.getUID(E), I))
                }
                if (v !== void 0 && o.setAttribute("normal", v), Object.keys(c).length === 0) return null;
                if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
                    let S = [],
                        E = [],
                        M = {};
                    if (e.morphTargetDictionary !== void 0)
                        for (let L in e.morphTargetDictionary) M[e.morphTargetDictionary[L]] = L;
                    for (let L = 0; L < e.morphTargetInfluences.length; ++L) {
                        let I = {},
                            z = !1;
                        for (let O in o.morphAttributes) {
                            if (O !== "position" && O !== "normal") {
                                z || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), z = !0);
                                continue
                            }
                            let X = o.morphAttributes[O][L],
                                k = O.toUpperCase(),
                                Q = o.attributes[O];
                            if (t.attributes.has(this.getUID(X))) {
                                I[k] = t.attributes.get(this.getUID(X));
                                continue
                            }
                            let te = X.clone();
                            if (!o.morphTargetsRelative)
                                for (let Z = 0, le = X.count; Z < le; Z++) te.setXYZ(Z, X.getX(Z) - Q.getX(Z), X.getY(Z) - Q.getY(Z), X.getZ(Z) - Q.getZ(Z));
                            I[k] = this.processAccessor(te, o), t.attributes.set(this.getUID(Q), I[k])
                        }
                        h.push(I), S.push(e.morphTargetInfluences[L]), e.morphTargetDictionary !== void 0 && E.push(M[L])
                    }
                    a.weights = S, E.length > 0 && (a.extras = {}, a.extras.targetNames = E)
                }
                let y = Array.isArray(e.material);
                if (y && o.groups.length === 0) return null;
                let A = y ? e.material : [e.material],
                    w = y ? o.groups : [{
                        materialIndex: 0,
                        start: void 0,
                        count: void 0
                    }];
                for (let S = 0, E = w.length; S < E; S++) {
                    let M = {
                        mode: l,
                        attributes: c
                    };
                    if (this.serializeUserData(o, M), h.length > 0 && (M.targets = h), o.index !== null) {
                        let I = this.getUID(o.index);
                        (w[S].start !== void 0 || w[S].count !== void 0) && (I += ":" + w[S].start + ":" + w[S].count), t.attributes.has(I) ? M.indices = t.attributes.get(I) : (M.indices = this.processAccessor(o.index, o, w[S].start, w[S].count), t.attributes.set(I, M.indices)), M.indices === null && delete M.indices
                    }
                    let L = this.processMaterial(A[w[S].materialIndex]);
                    L !== null && (M.material = L), f.push(M)
                }
                if (a.primitives = f, this.options.draco) {
                    let S = await this.dracoExporter.parse(e);
                    this.processBuffer(S.buffer);
                    let E = {
                        buffer: 0,
                        byteOffset: this.byteOffset,
                        byteLength: S.buffer.length
                    };
                    this.byteOffset += E.byteLength, r.bufferViews || (r.bufferViews = []), r.bufferViews.push(E), f.forEach(M => {
                        M.extensions || (M.extensions = {}), M.extensions.KHR_draco_mesh_compression = {
                            bufferView: r.bufferViews.length - 1,
                            attributes: S.attributeIDs
                        }
                    }), r.extensionsRequired || (r.extensionsRequired = []), r.extensionsRequired.includes("KHR_draco_mesh_compression") || r.extensionsRequired.push("KHR_draco_mesh_compression"), this.extensionsUsed.KHR_draco_mesh_compression = !0
                }
                r.meshes || (r.meshes = []), this._invokeAll(function(S) {
                    S.writeMesh && S.writeMesh(e, a)
                });
                let C = r.meshes.push(a) - 1;
                return t.meshes.set(s, C), C
            }
            processCamera(e) {
                let t = this.json;
                t.cameras || (t.cameras = []);
                let r = e.isOrthographicCamera,
                    i = {
                        type: r ? "orthographic" : "perspective"
                    };
                return r ? i.orthographic = {
                    xmag: e.right * 2,
                    ymag: e.top * 2,
                    zfar: e.far <= 0 ? .001 : e.far,
                    znear: e.near < 0 ? 0 : e.near
                } : i.perspective = {
                    aspectRatio: e.aspect,
                    yfov: Be.MathUtils.degToRad(e.fov),
                    zfar: e.far <= 0 ? .001 : e.far,
                    znear: e.near < 0 ? 0 : e.near
                }, e.name !== "" && (i.name = e.type), t.cameras.push(i) - 1
            }
            processAnimation(e, t) {
                let r = this.json,
                    i = this.nodeMap;
                r.animations || (r.animations = []), e = ea.Utils.mergeMorphTargetTracks(e.clone(), t);
                let s = e.tracks,
                    o = [],
                    l = [];
                for (let a = 0; a < s.length; ++a) {
                    let c = s[a],
                        f = Be.PropertyBinding.parseTrackName(c.name),
                        h = Be.PropertyBinding.findNode(t, f.nodeName),
                        m = Yh[f.propertyName];
                    if (f.objectName === "bones" && (h.isSkinnedMesh === !0 ? h = h.skeleton.getBoneByName(f.objectIndex) : h = void 0), !h || !m) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name), null;
                    let v = 1,
                        g = c.values.length / c.times.length;
                    m === Yh.morphTargetInfluences && (g /= h.morphTargetInfluences.length);
                    let y;
                    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (y = "CUBICSPLINE", g /= 3) : c.getInterpolation() === Be.InterpolateDiscrete ? y = "STEP" : y = "LINEAR", l.push({
                        input: this.processAccessor(new Be.BufferAttribute(c.times, v)),
                        output: this.processAccessor(new Be.BufferAttribute(c.values, g)),
                        interpolation: y
                    }), o.push({
                        sampler: l.length - 1,
                        target: {
                            node: i.get(h),
                            path: m
                        }
                    })
                }
                return r.animations.push({
                    name: e.name || "clip_" + r.animations.length,
                    samplers: l,
                    channels: o
                }), r.animations.length - 1
            }
            processSkin(e) {
                let t = this.json,
                    r = this.nodeMap,
                    i = t.nodes[r.get(e)],
                    s = e.skeleton;
                if (s === void 0) return null;
                let o = e.skeleton.bones[0];
                if (o === void 0) return null;
                let l = [],
                    a = new Float32Array(s.bones.length * 16),
                    c = new Be.Matrix4;
                for (let h = 0; h < s.bones.length; ++h) l.push(r.get(s.bones[h])), c.copy(s.boneInverses[h]), c.multiply(e.bindMatrix).toArray(a, h * 16);
                return t.skins === void 0 && (t.skins = []), t.skins.push({
                    inverseBindMatrices: this.processAccessor(new Be.BufferAttribute(a, 16)),
                    joints: l,
                    skeleton: r.get(o)
                }), i.skin = t.skins.length - 1
            }
            async processNode(e) {
                let t = this.json,
                    r = this.options,
                    i = this.nodeMap;
                t.nodes || (t.nodes = []);
                let s = {};
                if (r.trs) {
                    let l = e.quaternion.toArray(),
                        a = e.position.toArray(),
                        c = e.scale.toArray();
                    ta(l, [0, 0, 0, 1]) || (s.rotation = l), ta(a, [0, 0, 0]) || (s.translation = a), ta(c, [1, 1, 1]) || (s.scale = c)
                } else e.matrixAutoUpdate && e.updateMatrix(), lA(e.matrix) === !1 && (s.matrix = e.matrix.elements);
                if (e.name !== "" && (s.name = String(e.name)), this.serializeUserData(e, s), e.isMesh || e.isLine || e.isPoints) {
                    let l = await this.processMesh(e);
                    l !== null && (s.mesh = l)
                } else e.isCamera && (s.camera = this.processCamera(e));
                if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
                    let l = [];
                    for (let a = 0, c = e.children.length; a < c; a++) {
                        let f = e.children[a];
                        if (f.visible || r.onlyVisible === !1) {
                            let h = await this.processNode(f);
                            h !== null && l.push(h)
                        }
                    }
                    l.length > 0 && (s.children = l)
                }
                this._invokeAll(function(l) {
                    l.writeNode && l.writeNode(e, s)
                });
                let o = t.nodes.push(s) - 1;
                return i.set(e, o), o
            }
            async processScene(e) {
                let t = this.json,
                    r = this.options;
                t.scenes || (t.scenes = [], t.scene = 0);
                let i = {};
                e.name !== "" && (i.name = e.name), t.scenes.push(i);
                let s = [];
                for (let o = 0, l = e.children.length; o < l; o++) {
                    let a = e.children[o];
                    if (a.visible || r.onlyVisible === !1) {
                        let c = await this.processNode(a);
                        c !== null && s.push(c)
                    }
                }
                s.length > 0 && (i.nodes = s), this.serializeUserData(e, i)
            }
            async processObjects(e) {
                let t = new Be.Scene;
                t.name = "AuxScene";
                for (let r = 0; r < e.length; r++) t.children.push(e[r]);
                await this.processScene(t)
            }
            async processInput(e) {
                let t = this.options;
                e = e instanceof Array ? e : [e], this._invokeAll(function(i) {
                    i.beforeParse && i.beforeParse(e)
                });
                let r = [];
                for (let i = 0; i < e.length; i++) e[i] instanceof Be.Scene ? await this.processScene(e[i]) : r.push(e[i]);
                r.length > 0 && await this.processObjects(r);
                for (let i = 0; i < this.skins.length; ++i) this.processSkin(this.skins[i]);
                for (let i = 0; i < t.animations.length; ++i) this.processAnimation(t.animations[i], e[0]);
                this._invokeAll(function(i) {
                    i.afterParse && i.afterParse(e)
                })
            }
            _invokeAll(e) {
                for (let t = 0, r = this.plugins.length; t < r; t++) e(this.plugins[t])
            }
        },
        em = class {
            constructor(e) {
                this.writer = e, this.name = "KHR_lights_punctual"
            }
            writeNode(e, t) {
                if (!e.isLight) return;
                if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
                    console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
                    return
                }
                let r = this.writer,
                    i = r.json,
                    s = r.extensionsUsed,
                    o = {};
                e.name && (o.name = e.name), o.color = e.color.toArray(), o.intensity = e.intensity, e.isDirectionalLight ? o.type = "directional" : e.isPointLight ? (o.type = "point", e.distance > 0 && (o.range = e.distance)) : e.isSpotLight && (o.type = "spot", e.distance > 0 && (o.range = e.distance), o.spot = {}, o.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, o.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), s[this.name] || (i.extensions = i.extensions || {}, i.extensions[this.name] = {
                    lights: []
                }, s[this.name] = !0);
                let l = i.extensions[this.name].lights;
                l.push(o), t.extensions = t.extensions || {}, t.extensions[this.name] = {
                    light: l.length - 1
                }
            }
        },
        tm = class {
            constructor(e) {
                this.writer = e, this.name = "KHR_materials_unlit"
            }
            writeMaterial(e, t) {
                if (!e.isMeshBasicMaterial) return;
                let i = this.writer.extensionsUsed;
                t.extensions = t.extensions || {}, t.extensions[this.name] = {}, i[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9
            }
        },
        rm = class {
            constructor(e) {
                this.writer = e, this.name = "KHR_materials_pbrSpecularGlossiness"
            }
            writeMaterial(e, t) {
                if (!e.isGLTFSpecularGlossinessMaterial) return;
                let r = this.writer,
                    i = r.extensionsUsed,
                    s = {};
                t.pbrMetallicRoughness.baseColorFactor && (s.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor);
                let o = [1, 1, 1];
                if (e.specular.toArray(o, 0), s.specularFactor = o, s.glossinessFactor = e.glossiness, t.pbrMetallicRoughness.baseColorTexture && (s.diffuseTexture = t.pbrMetallicRoughness.baseColorTexture), e.specularMap) {
                    let l = {
                        index: r.processTexture(e.specularMap)
                    };
                    r.applyTextureTransform(l, e.specularMap), s.specularGlossinessTexture = l
                }
                t.extensions = t.extensions || {}, t.extensions[this.name] = s, i[this.name] = !0
            }
        };
    ea.Utils = {
        insertKeyframe: function(n, e) {
            let t = .001,
                r = n.getValueSize(),
                i = new n.TimeBufferType(n.times.length + 1),
                s = new n.ValueBufferType(n.values.length + r),
                o = n.createInterpolant(new n.ValueBufferType(r)),
                l;
            if (n.times.length === 0) {
                i[0] = e;
                for (let a = 0; a < r; a++) s[a] = 0;
                l = 0
            } else if (e < n.times[0]) {
                if (Math.abs(n.times[0] - e) < t) return 0;
                i[0] = e, i.set(n.times, 1), s.set(o.evaluate(e), 0), s.set(n.values, r), l = 0
            } else if (e > n.times[n.times.length - 1]) {
                if (Math.abs(n.times[n.times.length - 1] - e) < t) return n.times.length - 1;
                i[i.length - 1] = e, i.set(n.times, 0), s.set(n.values, 0), s.set(o.evaluate(e), n.values.length), l = i.length - 1
            } else
                for (let a = 0; a < n.times.length; a++) {
                    if (Math.abs(n.times[a] - e) < t) return a;
                    if (n.times[a] < e && n.times[a + 1] > e) {
                        i.set(n.times.slice(0, a + 1), 0), i[a + 1] = e, i.set(n.times.slice(a + 1), a + 2), s.set(n.values.slice(0, (a + 1) * r), 0), s.set(o.evaluate(e), (a + 1) * r), s.set(n.values.slice((a + 1) * r), (a + 2) * r), l = a + 1;
                        break
                    }
                }
            return n.times = i, n.values = s, l
        },
        mergeMorphTargetTracks: function(n, e) {
            let t = [],
                r = {},
                i = n.tracks;
            for (let s = 0; s < i.length; ++s) {
                let o = i[s],
                    l = Be.PropertyBinding.parseTrackName(o.name),
                    a = Be.PropertyBinding.findNode(e, l.nodeName);
                if (l.propertyName !== "morphTargetInfluences" || l.propertyIndex === void 0) {
                    t.push(o);
                    continue
                }
                if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
                    if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                    console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o = o.clone(), o.setInterpolation(Be.InterpolateLinear)
                }
                let c = a.morphTargetInfluences.length,
                    f = a.morphTargetDictionary[l.propertyIndex];
                if (f === void 0) throw new Error("THREE.GLTFExporter: Morph target name not found: " + l.propertyIndex);
                let h;
                if (r[a.uuid] === void 0) {
                    h = o.clone();
                    let v = new h.ValueBufferType(c * h.times.length);
                    for (let g = 0; g < h.times.length; g++) v[g * c + f] = h.values[g];
                    h.name = (l.nodeName || "") + ".morphTargetInfluences", h.values = v, r[a.uuid] = h, t.push(h);
                    continue
                }
                let m = o.createInterpolant(new o.ValueBufferType(1));
                h = r[a.uuid];
                for (let v = 0; v < h.times.length; v++) h.values[v * c + f] = m.evaluate(h.times[v]);
                for (let v = 0; v < o.times.length; v++) {
                    let g = this.insertKeyframe(h, o.times[v]);
                    h.values[g * c + f] = o.values[v]
                }
            }
            return n.tracks = t, n
        }
    };
    var Ml = {
        isPublish: !1,
        gltfQueue: []
    };

    function ra(n, e, t) {
        return n[e.uuid] === void 0 && (n[e.uuid] = e.toJSON(t)), e.uuid
    }
    var Vu = new ea,
        im = new cr;
    im.setEncoderPath("/_libraries/");
    Vu.setDRACOExporter(im);

    function nm(n, e, t) {
        if (n[e.uuid] === void 0)
            if (e.userData.type === "NonParametricGeometry" || e.userData.type === "SubdivGeometry") {
                if (e.userData.type === "SubdivGeometry")
                    if (Ml.isPublish) e = Fn.create({
                        geometry: e.clone()
                    }), e.userData.parameters.subdivisions === 0 && (delete e.attributes.color, delete e.attributes.faceMap, delete e.attributes.positionWASM, delete e.attributes.indexWASM, delete e.attributes.verticesPerFaceWASM);
                    else {
                        let i = (e.originalGeometry ?? e).clone();
                        delete i.attributes.color, delete i.attributes.faceMap, delete i.attributes.position, delete i.attributes.normal, i.index = null, e.originalGeometry ? e.originalGeometry = i : e = i
                    } let r = e.originalGeometry;
                if (r !== void 0) {
                    let i = e.userData;
                    e = r, e.userData = i
                }
                if (!Ml.isPublish) n[e.uuid] = e.toJSON();
                else {
                    let i = {
                        type: "NonParametricGeometry",
                        uuid: e.uuid,
                        userData: {}
                    };
                    e.name !== "" && (i.name = e.name), Object.keys(e.userData).length > 0 && (i.userData = Ne({}, e.userData));
                    let s = new un.Group;
                    if (Array.isArray(t)) Jh(e).forEach(l => {
                        let a = new un.Mesh(l, new un.MeshStandardMaterial);
                        s.add(a)
                    });
                    else {
                        let o = new un.Mesh(e, new un.MeshStandardMaterial);
                        s.add(o)
                    }
                    Ml.gltfQueue.push(new Promise(async o => {
                        await Promise.all(Ml.gltfQueue), Vu.parse(s, l => {
                            i.gltf = l, o()
                        }, l => {
                            Vu.parse(s, a => {
                                i.gltf = a, o()
                            }, () => {}, {
                                draco: !1
                            })
                        }, {
                            draco: !0
                        })
                    })), n[e.uuid] = i
                }
            } else {
                let r = e.userData;
                if (r.type === "VectorGeometry") {
                    let i = e.userData.shape;
                    r = Object.assign({}, r, {
                        shape: i.toJSON()
                    })
                }
                n[e.uuid] = {
                    uuid: e.uuid,
                    userData: r
                }
            } return e.uuid
    }

    function js(n) {
        let e = [];
        for (let t in n) {
            let r = n[t];
            delete r.metadata, e.push(r)
        }
        return e
    }

    function sm(n) {
        let e = [];
        for (let t in n) e.push(n[t]);
        return e
    }
    var kn = class {
        constructor(e) {
            this.object = e;
            this.uuid = Wt.MathUtils.generateUUID();
            this.states = [];
            this.events = [];
            this._interpolateMaterialBetweenValues = (e, t, r, i = t.getNames()) => {
                for (let s = 0, o = i.length; s < o; ++s) {
                    let l = i[s],
                        a = `f${t.id}_${l}`,
                        c = `f${r.id}_${l}`,
                        f = t.uniforms[a],
                        h = r.uniforms[c];
                    if (!(f.value === void 0 || h === void 0)) {
                        if (l === "mode") {
                            f.value !== h.value && (f.value = h.value);
                            continue
                        }
                        if (typeof f.value == "boolean") {
                            f.value !== h.value && (f.value = h.value);
                            continue
                        }
                        if (typeof f.value == "number") {
                            f.value !== h.value && this._animation?.add({
                                targets: f,
                                value: Number(h.value)
                            }, 0);
                            continue
                        }
                        if ("isVector2" in f.value) {
                            f.value.equals(h.value) === !1 && this._animation?.add({
                                targets: f,
                                x: h.value.x,
                                y: h.value.y
                            }, 0);
                            continue
                        }
                        if ("isVector3" in f.value) {
                            f.value.equals(h.value) === !1 && this._animation?.add({
                                targets: f,
                                x: h.value.x,
                                y: h.value.y,
                                z: h.value.z
                            }, 0);
                            continue
                        }
                        if ("isColor" in f.value) {
                            f.value.equals(h.value) === !1 && this._animation?.add({
                                targets: f.value,
                                r: h.value.r,
                                g: h.value.g,
                                b: h.value.b
                            }, 0);
                            continue
                        }
                    }
                }
                if (t.backLayer) {
                    let o = `f${t.backLayer.id}_alpha`,
                        l = t.backLayer.uniforms[o];
                    this._animation?.add({
                        targets: l,
                        value: 0
                    }, 0)
                }
            };
            this._interpolateMaterialBetweenLayers = (e, t, r) => {
                let i = e.layersList;
                if (t.backLayer === void 0) {
                    let c = r.getValues();
                    c.alpha = 0, t.backLayer = i.addLayerBeforeAt(c, t), t.backLayer.isBack = !0, e.dispose()
                }
                let s = `f${t.id}_alpha`,
                    o = `f${t.backLayer?.id}_alpha`,
                    l = t.uniforms[s],
                    a = t.backLayer?.uniforms[o];
                this._animation?.add({
                    targets: l,
                    value: 0
                }, 0).add({
                    targets: a,
                    value: r.uniforms[`f${r.id}_alpha`].value
                }, 0)
            };
            this._interpolateMaterialTexture = (e, t, r) => {
                let i = `f${t.id}_texture`,
                    s = t.uniforms[i].value,
                    o = r.uniforms[`f${r.id}_texture`].value,
                    l = t.uniforms[`f${t.id}_crop`],
                    a = r.uniforms[`f${r.id}_crop`];
                l && a && l.value !== a.value && (l.value = Number(a.value)), (s.wrapS !== o.wrapS || s.wrapT !== o.wrapT) && (s.wrapS = o.wrapS, s.wrapT = o.wrapT, s.needsUpdate = !0);
                let c = s.matrix,
                    f = o.matrix;
                if (c.equals(f) === !1) {
                    let m = {
                        repeatX: s.repeat.x,
                        repeatY: s.repeat.y,
                        offsetX: s.offset.x,
                        offsetY: s.offset.y
                    };
                    this._animation?.add({
                        targets: m,
                        repeatX: o.repeat.x,
                        repeatY: o.repeat.y,
                        offsetX: o.offset.x,
                        offsetY: o.offset.y,
                        update: () => {
                            s.repeat.set(m.repeatX, m.repeatY), s.offset.set(m.offsetX, m.offsetY), s.updateMatrix(), s.needsUpdate = !0
                        }
                    }, 0)
                }
                let h = ["alpha", "mode"];
                t.type === "displace_map" && h.push("intensity"), this._interpolateMaterialBetweenValues(e, t, r, h)
            };
            this._interpolateMaterialGradient = (e, t, r) => {
                let i = t.uniforms[`f${t.id}_num`],
                    s = r.uniforms[`f${r.id}_num`],
                    o = `f${t.id}_steps`,
                    l = `f${r.id}_steps`,
                    a = t.uniforms[o],
                    c = r.uniforms[l],
                    f = `f${t.id}_colors`,
                    h = `f${r.id}_colors`,
                    m = t.uniforms[f],
                    v = r.uniforms[h];
                if (i.value <= s.value) {
                    let g = m.value[i.value - 1];
                    for (let y = Number(i.value); y < s.value; ++y) a.value[y] = 1, m.value[y].copy(g);
                    i.value !== s.value && (i.value = Number(s.value));
                    for (let y = 0; y < s.value; ++y) {
                        let A = m.value[y],
                            w = v.value[y];
                        if (a.value[y] !== c.value[y] || !A.equals(w)) {
                            let C = {
                                value: a.value[y]
                            };
                            this._animation?.add({
                                targets: [C, A],
                                value: c.value[y],
                                x: w.x,
                                y: w.y,
                                z: w.z,
                                w: w.w,
                                update: () => {
                                    a.value[y] = C.value
                                }
                            }, 0)
                        }
                    }
                } else {
                    let g = [];
                    for (let A = 0; A < s.value; ++A) {
                        let w = m.value[A],
                            C = v.value[A];
                        if (a.value[A] !== c.value[A] || !w.equals(C)) {
                            let S = {
                                value: a.value[A]
                            };
                            g.push(new Promise(E => {
                                this._animation?.add({
                                    targets: [S, w],
                                    value: c.value[A],
                                    x: C.x,
                                    y: C.y,
                                    z: C.z,
                                    w: C.w,
                                    update: () => {
                                        a.value[A] = S.value
                                    },
                                    complete: () => {
                                        E(A)
                                    }
                                }, 0)
                            }))
                        }
                    }
                    let y = v.value[s.value - 1];
                    for (let A = Number(s.value); A < i.value; ++A) {
                        let w = m.value[A];
                        (a.value[A] !== c.value[A] || !w.equals(y)) && g.push(new Promise(C => {
                            let S = {
                                value: a.value[A]
                            };
                            this._animation?.add({
                                targets: [S, w],
                                value: 1,
                                x: y.x,
                                y: y.y,
                                z: y.z,
                                w: y.w,
                                update: () => {
                                    a.value[A] = S.value
                                },
                                complete: () => {
                                    C(A)
                                }
                            }, 0)
                        }))
                    }
                    Promise.all(g).then(() => {
                        i.value = Number(s.value)
                    }, () => {})
                }
                this._interpolateMaterialBetweenValues(e, t, r, ["alpha", "mode", "gl_type", "smooth", "offset", "morph", "angle"])
            };
            this.statesManager = new Uu(this)
        }
        computeCache() {
            return this.cache = {
                mouseDown: this.events.find(e => e.type === Re.MOUSE_DOWN),
                mouseUp: this.events.find(e => e.type === Re.MOUSE_UP),
                mouseHover: this.events.find(e => e.type === Re.MOUSE_HOVER),
                start: this.events.find(e => e.type === Re.START),
                lookAt: this.events.find(e => e.type === Re.LOOK_AT),
                follow: this.events.find(e => e.type === Re.FOLLOW),
                keyDown: this.events.filter(e => e.type === Re.KEY_DOWN),
                keyUp: this.events.filter(e => e.type === Re.KEY_UP)
            }, this.cache
        }
        newState(e) {
            let t = new cn;
            return t.name = e, t.update(this.object), this.selectedState = this.states.length, this.states.push(t), t
        }
        addState(e, t) {
            this.states.splice(t, 0, e)
        }
        removeState(e) {
            this.selectedState === e && (this.selectedState = void 0), this.states.splice(e, 1)
        }
        selectState(e) {
            e !== void 0 && this.states[e].execute(this.object), this.selectedState = e
        }
        hasEventType(e, t) {
            return e === Re.KEY_DOWN || e === Re.KEY_UP ? t === void 0 ? !1 : this.events.some(r => r.type === e && r.key === t) : this.events.some(r => r.type === e)
        }
        newEvent() {
            let e = [Re.MOUSE_DOWN, Re.MOUSE_UP, Re.MOUSE_HOVER, Re.KEY_DOWN].find(r => this.hasEventType(r) === !1),
                t = new ks(e);
            return this.events.push(t), t
        }
        addEvent(e, t) {
            this.events.splice(t, 0, e);
            let r = this.events[t].targets;
            for (let i = 0, s = r.length; i < s; ++i) r[i].object !== void 0 && zn.add(r[i])
        }
        removeEvent(e) {
            let t = this.events[e].targets;
            for (let r = 0, i = t.length; r < i; ++r) t[r].object !== void 0 && zn.delete(t[r]);
            this.events.splice(e, 1)
        }
        copy(e) {
            this.selectedState = e.selectedState;
            for (let t = 0, r = e.states.length; t < r; ++t) this.addState(e.states[t].clone(), t);
            for (let t = 0, r = e.events.length; t < r; ++t) {
                this.addEvent(e.events[t].clone(), t);
                let i = e.events[t].targets;
                for (let s = 0, o = i.length; s < o; ++s) {
                    let l = i[s].clone();
                    i[s].object === e.object ? (l.object = this.object, l.state = this.states[e.states.indexOf(i[s].state)]) : (l.object = i[s].object, l.state = i[s].state), this.events[t].addTarget(l, s)
                }
            }
            return this
        }
        clone(e) {
            return new kn(e).copy(this)
        }
        toJSON(e) {
            e === void 0 && (e = {
                nodes: {},
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                interactionStates: {}
            });
            let t = {
                uuid: this.uuid
            };
            if (this.selectedState !== void 0 && (t.selectedState = this.selectedState), this.states.length > 0) {
                t.states = [];
                for (let r = 0, i = this.states.length; r < i; ++r) t.states.push(ra(e.interactionStates, this.states[r], e))
            }
            if (this.events.length > 0) {
                t.events = [];
                for (let r = 0, i = this.events.length; r < i; ++r) t.events.push(this.events[r].toJSON())
            }
            return t
        }
        fromJSON(e, t, r) {
            if (this.uuid = e.uuid, this.selectedState = e.selectedState, this.states = [], this.events = [], e.states !== void 0)
                for (let i = 0, s = e.states.length; i < s; ++i) this.states.push(r[e.states[i]]);
            if (e.events !== void 0)
                for (let i = 0, s = e.events.length; i < s; ++i) this.events.push(new ks().fromJSON(e.events[i], t, r));
            return this
        }
        start() {
            this._animation !== void 0 && (this._animation.pause(), this._animation = void 0, this._removeBackLayer()), this.states.length > 1 ? (this.states[0].execute(this.object), this._currentState = this.states[0], this._prevState = void 0) : this._state0 !== void 0 ? this._state0.execute(this.object) : this.events.some(e => e.type === Re.LOOK_AT || e.type === Re.FOLLOW) && (this._state0 = new cn, this._state0.update(this.object))
        }
        end() {
            this._animation !== void 0 && (this._animation.pause(), this._animation = void 0, this._removeBackLayer()), this.states.length > 1 ? this.states[this.selectedState ?? 0].execute(this.object) : this._state0 !== void 0 && (this._state0.execute(this.object), this._state0 = void 0), this._currentState = void 0, this._prevState = void 0
        }
        lookAt(e) {
            this.object.lookAt(e), this._animation?.finished.then(() => {
                this.lookAt(e)
            })
        }
        follow(e) {
            this.object.position.copy(e), this.object.parent !== null && this.object.position.applyMatrix4(new Wt.Matrix4().copy(this.object.parent.matrixWorld).invert()), this.object.position.applyMatrix4(new Wt.Matrix4().copy(this.object.hiddenMatrix).invert())
        }
        play(e) {
            this.object.visible && e.state !== void 0 && this.animate(e.state, e)
        }
        reverse(e) {
            this.object.visible && this._prevState !== void 0 && this.animate(this._prevState, e)
        }
        _removeBackLayer() {
            if ("material" in this.object) {
                let e = this.object.material;
                if (e instanceof Array)
                    for (let t = 0, r = e.length; t < r; ++t) {
                        let i = e[t].layersList,
                            s = i.head;
                        for (; s;)
                            if (s.backLayer) {
                                delete s.backLayer;
                                let o = s.next;
                                i.removeLayer(s.id), s = o
                            } else s.isBack && (s.isBack = !1), s = s.next
                    } else {
                        let t = e.layersList,
                            r = t.head;
                        for (; r;)
                            for (; r;)
                                if (r.backLayer) {
                                    delete r.backLayer;
                                    let i = r.next;
                                    t.removeLayer(r.id), r = i
                                } else r.isBack && (r.isBack = !1), r = r.next
                    }
            }
        }
        getTimingFunction(e, t, r) {
            switch (e) {
                case ii.LINEAR:
                    return "cubicBezier( 0, 0, 1, 1 )";
                case ii.EASE:
                    return "cubicBezier( .25, .1, .25, 1 )";
                case ii.EASE_IN:
                    return "cubicBezier( .42, 0, 1, 1 )";
                case ii.EASE_OUT:
                    return "cubicBezier( 0, 0, .58, 1 )";
                case ii.EASE_IN_OUT:
                    return "cubicBezier( .42, 0, .58, 1 )";
                case ii.CUBIC:
                    return `cubicBezier( ${t[0]}, ${t[1]}, ${t[2]}, ${t[3]} )`;
                case ii.SPRING:
                    return `spring( ${r.mass}, ${r.stiffness}, ${r.damping}, ${r.velocity} )`
            }
        }
        animate(e, t) {
            if (this._currentState === e) {
                if (this._animation?.reversed) {
                    let r = this._animation?.currentTime ?? 0;
                    this._animation?.reset(), this._animation?.seek(r), this._animation?.play()
                }
            } else this._prevState = this._currentState, this._currentState = e, this._animation !== void 0 && this._animation.pause(), this._removeBackLayer(), t.cycle === !0 && t.repeat === !0 ? this._animation = $o.timeline({
                duration: t.duration,
                delay: t.delay / 2,
                endDelay: t.delay / 2,
                direction: "alternate",
                loop: !0,
                rewind: t.rewind,
                easing: this.getTimingFunction(t.easing, t.cubicControls, t.springParameters)
            }) : t.cycle === !0 && t.repeat === !1 ? this._animation = $o.timeline({
                duration: t.duration,
                delay: t.delay,
                endDelay: t.delay / 2,
                direction: "alternate",
                rewind: t.rewind,
                easing: this.getTimingFunction(t.easing, t.cubicControls, t.springParameters)
            }) : t.cycle === !1 && t.repeat === !0 ? this._animation = $o.timeline({
                duration: t.duration,
                delay: t.delay,
                direction: "normal",
                loop: !0,
                easing: this.getTimingFunction(t.easing, t.cubicControls, t.springParameters)
            }) : this._animation = $o.timeline({
                duration: t.duration,
                delay: t.delay,
                direction: "normal",
                easing: this.getTimingFunction(t.easing, t.cubicControls, t.springParameters)
            }), this._animation.finished.then(() => {
                this._removeBackLayer(), this._animation = void 0
            }), this.animateMatrix(e), this.animateGeometry(e), this.animateMaterial(e), this.animateCamera(e)
        }
        animateMatrix(e) {
            if (this.object.position.equals(e.position) === !1) {
                let s = this.object.position.clone(),
                    o = {
                        t: 0
                    };
                this._animation?.add({
                    targets: o,
                    t: 1,
                    update: () => {
                        this.object.position.lerpVectors(s, e.position, o.t)
                    }
                }, 0)
            }
            if (this.object.scale.equals(e.scale) === !1) {
                let s = this.object.scale.clone(),
                    o = {
                        t: 0
                    };
                this._animation?.add({
                    targets: o,
                    t: 1,
                    update: () => {
                        this.object.scale.lerpVectors(s, e.scale, o.t)
                    }
                }, 0)
            }
            if (this.object.rotation.equals(e.rotation) === !1) {
                let s = this.object.quaternion.clone(),
                    o = {
                        t: 0
                    },
                    l = {
                        x: this.object.rotation.x - e.rotation.x,
                        y: this.object.rotation.y - e.rotation.y,
                        z: this.object.rotation.z - e.rotation.z
                    },
                    a = e.rotation.clone(),
                    c = .01 * Wt.MathUtils.DEG2RAD,
                    f = 359.99 * Wt.MathUtils.DEG2RAD;
                l.x === Math.PI * 2 ? a.x === 0 ? a.x = c : a.x === Math.PI * 2 && (a.x = f) : l.x === -Math.PI * 2 && (a.x === 0 ? a.x = -c : a.x === Math.PI * 2 && (a.x = -f)), l.y === Math.PI * 2 ? a.y === 0 ? a.y = c : a.y === Math.PI * 2 && (a.y = f) : l.y === -Math.PI * 2 && (a.y === 0 ? a.y = -c : a.y === Math.PI * 2 && (a.y = -f)), l.z === Math.PI * 2 ? a.z === 0 ? a.z = c : a.z === Math.PI * 2 && (a.z = f) : l.z === -Math.PI * 2 && (a.z === 0 ? a.z = -c : a.z === Math.PI * 2 && (a.z = -f));
                let h = new Wt.Quaternion().setFromEuler(a);
                this._animation?.add({
                    targets: o,
                    t: 1,
                    update: () => {
                        Nh(s, h, this.object.quaternion, o.t)
                    }
                }, 0)
            }
            let t = new Wt.Vector3,
                r = new Wt.Quaternion,
                i = new Wt.Vector3;
            if (e.hiddenMatrix.decompose(t, r, i), "hiddenMatrix" in this.object) {
                let s = new Wt.Vector3,
                    o = new Wt.Quaternion,
                    l = new Wt.Vector3;
                if (this.object.hiddenMatrix.decompose(s, o, l), this.object.hiddenMatrix.equals(e.hiddenMatrix) === !1) {
                    let a = new Wt.Vector3,
                        c = new Wt.Quaternion,
                        f = new Wt.Vector3,
                        h = {
                            t: 0
                        },
                        m = this.object.hiddenMatrix;
                    this._animation?.add({
                        targets: h,
                        t: 1,
                        update: () => {
                            c.slerpQuaternions(o, r, h.t), a.lerpVectors(s, t, h.t), f.lerpVectors(l, i, h.t), m.compose(a, c, f)
                        }
                    }, 0)
                }
            }
        }
        animateGeometry(e) {
            if ("geometry" in this.object && e.geometry !== void 0) {
                let r = this.object.geometry.userData.parameters,
                    i = e.geometry;
                if (i.width !== r.width || i.height !== r.height || i.depth !== r.depth) {
                    let s = this.object;
                    this._animation?.add({
                        targets: r,
                        width: i.width,
                        height: i.height,
                        depth: i.depth,
                        update: () => {
                            s.updateGeometry({
                                parameters: {
                                    width: r.width,
                                    height: r.height,
                                    depth: r.depth
                                }
                            })
                        }
                    }, 0)
                }
            }
        }
        animateMaterial(e) {
            if ("material" in this.object)
                if (this.object.material instanceof Array)
                    for (let t = 0, r = this.object.material.length; t < r; ++t) this._interpolateMaterial(this.object.material[t], e.material[t]);
                else {
                    if (this.object.material.userData.isAsset) return;
                    this._interpolateMaterial(this.object.material, e.material)
                }
        }
        _interpolateMaterial(e, t) {
            let r = e.layersList.head,
                i = 0;
            for (; r;) {
                if (r.isBack === !0) {
                    r = r.next;
                    continue
                }
                let s = t.layersList[i++];
                if (il(r)) {
                    let o = r.uniforms[`f${r.id}_texture`].value,
                        l = s.uniforms[`f${s.id}_texture`].value;
                    o.image === l.image ? this._interpolateMaterialTexture(e, r, s) : this._interpolateMaterialBetweenLayers(e, r, s)
                } else r.type === "gradient" ? r.uniforms[`f${r.id}_gl_type`].value === s.uniforms[`f${s.id}_gl_type`].value ? this._interpolateMaterialGradient(e, r, s) : this._interpolateMaterialBetweenLayers(e, r, s) : this._interpolateMaterialBetweenValues(e, r, s);
                r = r.next
            }
        }
        animateCamera(e) {
            if (this.object.objectType === "CombinedCamera" && e.camera !== void 0) {
                let t = this.object,
                    r = t.cameraType === "OrthographicCamera" ? e.camera.zoomOrtho : e.camera.zoomPersp;
                t.zoom !== r && this._animation?.add({
                    targets: t,
                    zoom: r,
                    update: () => {
                        t.updateProjectionMatrix()
                    }
                }, 0)
            }
        }
    };
    var _l = W(J());
    var Il = n => class extends n {
        hasEntityChild() {
            return this.children.some(t => Al(t))
        }
        attach(t, r) {
            this.updateWorldMatrix(!0, !1);
            let i = new _l.Matrix4().copy(this.matrixWorld).invert();
            return t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), i.multiply(t.parent.matrixWorld)), Al(t) ? t.hiddenMatrix.premultiply(i) : t.applyMatrix4(i), t.updateWorldMatrix(!1, !1), this.add(t), r !== void 0 && (this.children.pop(), this.children.splice(r, 0, t)), this
        }
        copy(t, r = !0) {
            if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), r === !0)
                for (let i = 0; i < t.children.length; i++) {
                    let s = t.children[i];
                    this.add(s.clone())
                }
            return this
        }
        toJSON(t) {
            let r = t === void 0,
                i = {
                    object: {
                        uuid: "",
                        objectType: ""
                    }
                };
            t === void 0 && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                interactionStates: {},
                nodes: {}
            }, i.metadata = {
                version: 1.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            let s = {
                uuid: this.uuid,
                objectType: this.type
            };
            if (this.name !== "" && (s.name = this.name), s.matrix = this.matrix.toArray(), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), s.layers = this.layers.mask, JSON.stringify(this.userData) !== "{}" && (s.userData = this.userData), this.children.length > 0) {
                s.children = [];
                for (let o of this.children)(Al(o) || o instanceof _l.Light) && s.children.push(o.toJSON(t).object)
            }
            if (r) {
                let o = js(t.geometries),
                    l = js(t.materials),
                    a = js(t.textures),
                    c = js(t.images),
                    f = js(t.interactionStates),
                    h = sm(t.nodes);
                o.length > 0 && (i.geometries = o), l.length > 0 && (i.materials = l), a.length > 0 && (i.textures = a), c.length > 0 && (i.images = c), f.length > 0 && (i.interactionStates = f), h.length > 0 && (i.nodes = h)
            }
            return i.object = s, i
        }
        fromJSON(t) {
            return this.uuid = t.uuid, t.name !== void 0 && (this.name = t.name), t.matrix !== void 0 ? (this.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (this.matrixAutoUpdate = t.matrixAutoUpdate), this.matrixAutoUpdate && this.matrix.decompose(this.position, this.quaternion, this.scale)) : (t.position !== void 0 && this.position.fromArray(t.position), t.rotation !== void 0 && this.rotation.fromArray(t.rotation), t.quaternion !== void 0 && this.quaternion.fromArray(t.quaternion), t.scale !== void 0 && this.scale.fromArray(t.scale)), this.castShadow = t.castShadow !== void 0, this.receiveShadow = t.receiveShadow !== void 0, t.visible !== void 0 && (this.visible = t.visible), t.frustumCulled !== void 0 && (this.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (this.renderOrder = t.renderOrder), t.layers !== void 0 && (this.layers.mask = t.layers), t.userData !== void 0 && (this.userData = t.userData), this
        }
    };
    var Sr = n => "isEntity" in n,
        om = n => "isAbstractMesh" in n,
        Hu = n => "objectHelper" in n,
        kr = n => class extends Il(n) {
            constructor() {
                super(...arguments);
                this.objectType = "";
                this.isEntity = !0;
                this.raycastLock = !1;
                this.scaleLock = !1;
                this.hiddenMatrix = new Ll.Matrix4;
                this.interaction = new kn(this);
                this.forceComputeSize = !1
            }
            set visibility(t) {
                this.visible = t;
                for (let r of this.children) Sr(r) && r.traverseEntity(i => {
                    Hu(i) && i.visible && (i.objectHelper.visible = t)
                })
            }
            get visibility() {
                return this.visible
            }
            get interactionCache() {
                return this.interaction.cache === void 0 && this.interaction.computeCache(), this.interaction.cache
            }
            traverseEntity(t) {
                t(this);
                for (let r of this.children) Sr(r) && r.traverseEntity(t)
            }
            computeSingleBoundingBox() {
                this.singleBoundingBox || (this.singleBoundingBox = new wl), this.singleBoundingBox.setFromObjectSize(this, !1), this.singleBoundingBox.computeVertices(), this.singleBoundingBox.computeEdges(), this.singleBoundingBox.computeFaces()
            }
            computeComplexBoundingBox(t) {
                this.complexBoundingBox || (this.complexBoundingBox = new wl), this.complexBoundingBox.setFromObjectSize(this, t), this.complexBoundingBox.computeVertices(), this.complexBoundingBox.computeEdges(), this.complexBoundingBox.computeFaces()
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, t = !0);
                for (let r of this.children) r.updateMatrixWorld(t)
            }
            updateWorldMatrix(t, r) {
                let i = this.parent;
                if (t && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), r)
                    for (let s of this.children) s.updateWorldMatrix(!1, !0)
            }
            shallowClone(t) {
                return new this.constructor().shallowCopy(this, t)
            }
            shallowCopy(t, r = !0) {
                if (super.copy(t, !1), this.raycastLock = t.raycastLock, this.scaleLock = t.scaleLock, this.hiddenMatrix.copy(t.hiddenMatrix), t.interaction !== void 0 && this.interaction.copy(t.interaction), r === !0)
                    for (let i of t.children) Sr(i) && this.add(i.shallowClone());
                return this
            }
            clone(t) {
                return new this.constructor().copy(this, t)
            }
            copy(t, r = !0) {
                if (super.copy(t, !1), this.raycastLock = t.raycastLock, this.scaleLock = t.scaleLock, this.hiddenMatrix.copy(t.hiddenMatrix), t.interaction !== void 0 && this.interaction.copy(t.interaction), r === !0)
                    for (let i of t.children) Sr(i) && this.add(i.clone());
                return this
            }
            keepChildrenMatrixWorld() {
                let t = new Ll.Matrix4,
                    r = this.matrixWorld.clone();
                this.updateWorldMatrix(!1, !1), t.copy(this.matrixWorld).invert(), t.multiply(r);
                for (let i of this.children) Sr(i) && i.hiddenMatrix.premultiply(t)
            }
            toJSON(t) {
                let r = super.toJSON(t),
                    i = r.object;
                return this.raycastLock === !0 && (i.raycastLock = !0), this.scaleLock === !0 && (i.scaleLock = !0), i.hiddenMatrix = this.hiddenMatrix.toArray(), this.interaction !== void 0 && (i.interaction = this.interaction.toJSON(t)), r
            }
            fromJSON(t) {
                return super.fromJSON(t), t.raycastLock !== void 0 && (this.raycastLock = t.raycastLock), t.scaleLock !== void 0 && (this.scaleLock = t.scaleLock), this.hiddenMatrix.fromArray(t.hiddenMatrix), this
            }
            fromObject3D(t) {
                let r = t.children;
                return t.children = [], Object.assign(t, {
                    raycastLock: !1,
                    scaleLock: !1,
                    hiddenMatrix: new Ll.Matrix4
                }), this.copy(t), t.children = r, this
            }
        };
    var yt = W(J()),
        Dl = class extends yt.Object3D {
            constructor(e, t = {}) {
                super();
                this.object = e, e.computeComplexBoundingBox(!0);
                let r = e.complexBoundingBox.getSize(new yt.Vector3),
                    i = .1;
                this.parameters = {
                    type: t.type !== void 0 ? t.type : "radial",
                    hideBase: t.hideBase !== void 0 ? t.hideBase : !1,
                    count: t.count !== void 0 ? t.count : 3,
                    ra_radius: t.ra_radius !== void 0 ? t.ra_radius : Math.max(r.x, r.y) * 2,
                    ra_startAngle: t.ra_startAngle !== void 0 ? t.ra_startAngle : 0,
                    ra_endAngle: t.ra_endAngle !== void 0 ? t.ra_endAngle : 360,
                    ra_align: t.ra_align !== void 0 ? t.ra_align : !1,
                    ra_axis: t.ra_axis !== void 0 ? t.ra_axis : "y",
                    ra_scale: t.ra_scale !== void 0 ? t.ra_scale.clone() : new yt.Vector3,
                    ra_rotation: t.ra_rotation !== void 0 ? t.ra_rotation.clone() : new yt.Euler,
                    ra_position: t.ra_position !== void 0 ? t.ra_position.clone() : new yt.Vector3,
                    li_scale: t.li_scale !== void 0 ? t.li_scale.clone() : new yt.Vector3,
                    li_rotation: t.li_rotation !== void 0 ? t.li_rotation.clone() : new yt.Euler,
                    li_position: t.li_position !== void 0 ? t.li_position.clone() : new yt.Vector3(r.x + r.x * i, 0, 0).round(),
                    gr_count: t.gr_count !== void 0 ? t.gr_count.clone() : new yt.Vector3(2, 2, 2),
                    gr_size: t.gr_size !== void 0 ? t.gr_size.clone() : new yt.Vector3(r.x + r.x * i, r.y + r.y * i, r.z + r.z * i).round(),
                    gr_fromCenter: t.gr_fromCenter !== void 0 ? t.gr_fromCenter : !0
                }, this.update(), this.setHideBase(this.parameters.hideBase)
            }
            refreshMaterial() {
                if ("material" in this.object)
                    for (let e of this.children) e.material = this.object.material
            }
            setHideBase(e) {
                if ("material" in this.object) {
                    if (Array.isArray(this.object.material)) {
                        if (this.children.length > 0) {
                            for (let t of this.object.material) t.visible = !0;
                            if (e) {
                                let t = this.object.material.map(r => r.clone());
                                for (let r of this.children) r.material = t
                            } else
                                for (let t of this.children) t.material = this.object.material
                        }
                        for (let t of this.object.material) t.visible = !e
                    } else {
                        if (this.children.length > 0)
                            if (this.object.material.visible = !0, e) {
                                let t = this.object.material.clone();
                                for (let r of this.children) r.material = t
                            } else
                                for (let t of this.children) t.material = this.object.material;
                        this.object.material.visible = !e
                    }
                    this.parameters.hideBase = e
                }
            }
            update() {
                switch (this._updateCount(), this.parameters.type) {
                    case "radial":
                        this._updateRadial(this.parameters);
                        break;
                    case "linear":
                        this._updateLinear(this.parameters);
                        break;
                    case "grid":
                        this._updateGrid(this.parameters)
                }
            }
            _updateCount() {
                let e = this.parameters.type === "grid" ? this.parameters.gr_count.x * this.parameters.gr_count.y * this.parameters.gr_count.z : this.parameters.count;
                if (this.children.length !== e)
                    if (this.children.length < e)
                        for (let t = 0, r = e - this.children.length; t < r; ++t) {
                            let i = this.object.shallowClone(!1);
                            i.visible = !0, this.add(i), this.parameters.hideBase && this.setHideBase(!0)
                        } else
                            for (let t = 0, r = this.children.length - e; t < r; ++t) this.remove(this.children[0])
            }
            _updateRadial(e) {
                let t = e.ra_startAngle * yt.MathUtils.DEG2RAD,
                    r = e.ra_endAngle * yt.MathUtils.DEG2RAD,
                    i = t - r,
                    s = new yt.Euler(e.ra_rotation.x * yt.MathUtils.DEG2RAD, e.ra_rotation.y * yt.MathUtils.DEG2RAD, e.ra_rotation.z * yt.MathUtils.DEG2RAD),
                    o;
                switch (e.ra_axis) {
                    case "x":
                        o = new yt.Vector3(1, 0, 0);
                        break;
                    case "y":
                        o = new yt.Vector3(0, 1, 0);
                        break;
                    case "z":
                        o = new yt.Vector3(0, 0, 1);
                        break
                }
                for (let [l, a] of this.children.entries()) {
                    a.hiddenMatrix.identity(), a.scale.x = e.ra_scale.x + 1, a.scale.y = e.ra_scale.y + 1, a.scale.z = e.ra_scale.z + 1, a.position.setScalar(0);
                    let c = i / e.count * l - t;
                    switch (e.ra_axis) {
                        case "x":
                            a.rotation.set(0, c, 0);
                            break;
                        case "y":
                            a.rotation.set(0, 0, c);
                            break;
                        case "z":
                            a.rotation.set(c, 0, 0);
                            break
                    }
                    a.translateOnAxis(o, e.ra_radius), a.position.add(e.ra_position), e.ra_align === !0 ? (a.rotation.x += s.x, a.rotation.y += s.y, a.rotation.z += s.z) : a.rotation.copy(s)
                }
            }
            _updateLinear(e) {
                if (e.type !== "linear") throw new Error;
                let t = new yt.Euler(e.li_rotation.x * yt.MathUtils.DEG2RAD, e.li_rotation.y * yt.MathUtils.DEG2RAD, e.li_rotation.z * yt.MathUtils.DEG2RAD);
                for (let [r, i] of this.children.entries()) i.hiddenMatrix.identity(), i.scale.x = e.li_scale.x * r + 1, i.scale.y = e.li_scale.y * r + 1, i.scale.z = e.li_scale.z * r + 1, i.rotation.x = t.x * r, i.rotation.y = t.y * r, i.rotation.z = t.z * r, i.position.x = e.li_position.x * r, i.position.y = e.li_position.y * r, i.position.z = e.li_position.z * r
            }
            _updateGrid(e) {
                let t = 0;
                if (e.gr_fromCenter === !0) {
                    let r = {
                            x: e.gr_count.x % 2 == 0 ? 2 : 1,
                            y: e.gr_count.y % 2 == 0 ? 2 : 1,
                            z: e.gr_count.z % 2 == 0 ? 2 : 1
                        },
                        i = new yt.Vector3(e.gr_size.x * (e.gr_count.x - r.x) * .5, e.gr_size.y * (e.gr_count.y - r.y) * .5, e.gr_size.z * (e.gr_count.z - r.z) * .5);
                    for (let s = 0; s < e.gr_count.x; s++)
                        for (let o = 0; o < e.gr_count.y; o++)
                            for (let l = 0; l < e.gr_count.z; l++) {
                                let a = this.children[t++];
                                a.hiddenMatrix.identity(), a.scale.setScalar(1), a.rotation.set(0, 0, 0), a.position.x = e.gr_size.x * s - i.x, a.position.y = e.gr_size.y * o - i.y, a.position.z = e.gr_size.z * l - i.z
                            }
                } else
                    for (let r = 0; r < e.gr_count.x; r++)
                        for (let i = 0; i < e.gr_count.y; i++)
                            for (let s = 0; s < e.gr_count.z; s++) {
                                let o = this.children[t++];
                                o.hiddenMatrix.identity(), o.scale.setScalar(1), o.rotation.set(0, 0, 0), o.position.x = e.gr_size.x * r, o.position.y = -e.gr_size.y * i, o.position.z = -e.gr_size.z * s
                            }
            }
            toJSON() {
                return {
                    type: "Cloner",
                    parameters: {
                        type: this.parameters.type,
                        hideBase: this.parameters.hideBase,
                        count: this.parameters.count,
                        ra_radius: this.parameters.ra_radius,
                        ra_startAngle: this.parameters.ra_startAngle,
                        ra_endAngle: this.parameters.ra_endAngle,
                        ra_align: this.parameters.ra_align,
                        ra_axis: this.parameters.ra_axis,
                        ra_scale: this.parameters.ra_scale.toArray(),
                        ra_rotation: this.parameters.ra_rotation.toArray(),
                        ra_position: this.parameters.ra_position.toArray(),
                        li_scale: this.parameters.li_scale.toArray(),
                        li_rotation: this.parameters.li_rotation.toArray(),
                        li_position: this.parameters.li_position.toArray(),
                        gr_count: this.parameters.gr_count.toArray(),
                        gr_size: this.parameters.gr_size.toArray(),
                        gr_fromCenter: this.parameters.gr_fromCenter
                    }
                }
            }
            fromJSON(e) {
                let t = e.parameters;
                return this.parameters.type = t.type, this.parameters.hideBase = t.hideBase, this.parameters.count = t.count, this.parameters.ra_radius = t.ra_radius, this.parameters.ra_startAngle = t.ra_startAngle, this.parameters.ra_endAngle = t.ra_endAngle, this.parameters.ra_align = t.ra_align, this.parameters.ra_axis = t.ra_axis, this.parameters.ra_scale.fromArray(t.ra_scale), this.parameters.ra_rotation.fromArray(t.ra_rotation), this.parameters.ra_position.fromArray(t.ra_position), this.parameters.li_scale.fromArray(t.li_scale), this.parameters.li_rotation.fromArray(t.li_rotation), this.parameters.li_position.fromArray(t.li_position), this.parameters.gr_count.fromArray(t.gr_count), this.parameters.gr_size.fromArray(t.gr_size), this.parameters.gr_fromCenter = t.gr_fromCenter, this.update(), this.setHideBase(this.parameters.hideBase), this
            }
        };
    var Nr = class extends kr(am.Mesh) {
        constructor(e, t) {
            super(e, t);
            this.isAbstractMesh = !0;
            Array.isArray(t) && (this.selectedMaterial = 0)
        }
        get cloner() {
            return this._cloner
        }
        set cloner(e) {
            this._cloner && this.remove(this._cloner), e && this.add(e), this._cloner = e
        }
        getSelectedMaterial(e) {
            return Array.isArray(this.material) ? (this.selectedMaterial === void 0 && (this.selectedMaterial = e ?? 0), this.material[e ?? this.selectedMaterial]) : this.material
        }
        setSelectedMaterial(e, t) {
            Array.isArray(this.material) ? (this.selectedMaterial === void 0 && (this.selectedMaterial = t ?? 0), t = t ?? this.selectedMaterial, this.material[t].dispose(), this.material[t] = e) : (this.material.dispose(), this.material = e)
        }
        updateGeometry(e) {
            let t = this.geometry,
                r = Xo[t.userData.type],
                i = this.objectType === "NonParametric" ? Object.assign({}, t.userData, {
                    geometry: t
                }) : t.userData,
                s = r.build(r.normalizeInputs(e, i)),
                o = t.uuid;
            this.geometry.dispose(), this.geometry = s, this.geometry.uuid = o, this.geometry.computeBoundingSphere()
        }
        resizeGeometry(e, t, r) {
            Ko.resizeGeometry(this.geometry, {
                width: e,
                height: t,
                depth: r
            })
        }
        shallowClone(e) {
            return new this.constructor(this.geometry, this.material).shallowCopy(this, e)
        }
        clone(e) {
            let t = this.objectType === "NonParametric" ? Object.assign({}, this.geometry.userData, {
                    geometry: this.geometry.clone()
                }) : this.geometry.userData,
                r = qo(t),
                i = Array.isArray(this.material) ? this.material.map(s => s.clone()) : this.material.clone();
            return new this.constructor(r, i).copy(this, e)
        }
        copy(e, t = !0) {
            return super.copy(e, t), e.cloner && (this.cloner = new Dl(e, e.cloner.parameters), this.add(this.cloner)), this
        }
        toJSON(e) {
            let t = super.toJSON(e),
                r = t.object;
            if (this.cloner !== void 0 && (r.cloner = this.cloner.toJSON()), r.geometry = nm(e.geometries, this.geometry, this.material), Array.isArray(this.material)) {
                let i = [];
                for (let s = 0, o = this.material.length; s < o; s++) i.push(ra(e.materials, this.material[s], e));
                r.material = i
            } else r.material = ra(e.materials, this.material, e);
            return t
        }
        fromJSON(e) {
            return super.fromJSON(e), e.selectedMaterial !== void 0 && (this.selectedMaterial = e.selectedMaterial), e.cloner !== void 0 && (this.cloner = new Dl(this).fromJSON(e.cloner)), this
        }
    };
    var jr = W(J());
    var lm = W(J()),
        Ti = n => {
            var e;
            return e = class extends n {
                constructor() {
                    super(...arguments);
                    this.isObjectHelper = !0
                }
            }, e.geometryHelper = new lm.BoxBufferGeometry(30, 30, 30), e
        };
    var fn = W(J());
    var Ur = W(J()),
        Wu = new Ur.Ray,
        Ju = new Ur.Sphere,
        cm = new Ur.Matrix4,
        Ei = (n, e, t, r) => {
            let i = e,
                s = n.matrixWorld;
            if (i.boundingSphere === null && i.computeBoundingSphere(), Ju.copy(i.boundingSphere), Ju.applyMatrix4(s), t.ray.intersectsSphere(Ju) === !1 || (cm.copy(s).invert(), Wu.copy(t.ray).applyMatrix4(cm), i.boundingBox !== null && Wu.intersectsBox(i.boundingBox) === !1)) return;
            let o, l, a, c, f = i.index,
                h = i.attributes.position,
                m = i.drawRange,
                v, g, y = Math.max(0, m.start),
                A = Math.min(f.count, m.start + m.count);
            for (v = y, g = A; v < g; v += 3)
                if (l = f.getX(v), a = f.getX(v + 1), c = f.getX(v + 2), o = w(n, t, Wu, h, l, a, c), o) {
                    o.faceIndex = Math.floor(v / 3), r.push(o);
                    return
                }
            function w(C, S, E, M, L, I, z) {
                let O = new Ur.Vector3,
                    X = new Ur.Vector3,
                    k = new Ur.Vector3,
                    Q = new Ur.Vector3,
                    te = new Ur.Vector3;
                if (O.fromBufferAttribute(M, L), X.fromBufferAttribute(M, I), k.fromBufferAttribute(M, z), E.intersectTriangle(O, X, k, !1, Q) === null) return null;
                te.copy(Q), te.applyMatrix4(C.matrixWorld);
                let le = S.ray.origin.distanceTo(te);
                return le < S.near || le > S.far ? null : {
                    faceIndex: 1,
                    distance: le,
                    point: te.clone(),
                    object: C
                }
            }
        };
    var ia = class extends Ti(fn.CameraHelper) {
        constructor(e) {
            super(e);
            this.object = e;
            let t = new fn.SphereGeometry(15, 4, 2),
                r = new fn.MeshBasicMaterial({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                }),
                i = new fn.Mesh(t, r);
            this.add(i), this.object = e, this.name = `CombinedCameraHelper: ${e.uuid}`
        }
        raycast(e, t) {
            Ei(this.object, ia.geometryHelper, e, t)
        }
    };
    var um = W(J());
    var na = class extends Ti(um.DirectionalLightHelper) {
        constructor(e, t = 15, r = 10066329) {
            super(e, t, r);
            this.object = e;
            this.name = `DirectionalLightHelper: ${e.uuid}`
        }
        raycast(e, t) {
            Ei(this.object, na.geometryHelper, e, t)
        }
    };
    var fm = W(J());
    var sa = class extends Ti(fm.AxesHelper) {
        constructor(e, t = 15) {
            super(t);
            this.object = e;
            this.object.updateMatrixWorld(), this.name = `EmptyObjectHelper: ${e.uuid}`, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
        }
        raycast(e, t) {
            Ei(this.object, sa.geometryHelper, e, t)
        }
        update() {}
    };
    var dm = W(J());
    var oa = class extends Ti(dm.PointLightHelper) {
        constructor(e, t = 15, r = 6710886) {
            super(e, t, r);
            this.object = e;
            this.name = `PointLightHelper: ${e.uuid}`
        }
        raycast(e, t) {
            Ei(this.object, oa.geometryHelper, e, t)
        }
    };
    var Pl = W(J());
    var Ol = class extends Ti(Pl.SpotLightHelper) {
            constructor(e, t = 6710886) {
                super(e, t);
                this.object = e;
                this.name = `SpotLightHelper: ${e.uuid}`
            }
            raycast(e, t) {
                Ei(this.object, Ol.geometryHelper, e, t)
            }
            update() {
                if (this.object !== void 0) {
                    let e = Ol._vector,
                        t = this.object.distance ? this.object.distance : 1e3,
                        r = t * Math.tan(this.object.angle);
                    this.cone.scale.set(r, r, t), e.setFromMatrixPosition(this.object.target.matrixWorld), this.cone.lookAt(e);
                    let i = this.color !== void 0 ? this.color : this.light.color;
                    if (this.cone.material instanceof Array)
                        for (let s = 0, o = this.cone.material.length; s < o; s++) this.cone.material[s].color.set(i);
                    else this.cone.material.color.set(i)
                }
            }
        },
        Bl = Ol;
    Bl._vector = new Pl.Vector3;
    var Mi = W(J());
    var uA = new Mi.Vector3(0, 0, 1),
        hm = new Mi.Vector3,
        mm = new Mi.Vector3,
        pm = new Mi.Matrix3,
        aa = class extends Nr {
            constructor(e = lr.create({}), t = new Pr({
                side: Mi.DoubleSide
            })) {
                super(e, t);
                this.recursiveSelection = !1;
                this.objectType = "VectorObject";
                this.eventDispatcher = new Mi.EventDispatcher;
                this._onShapeUpdate = () => {
                    if (this.geometry instanceof Ho) {
                        if (this.geometry.updateFromShape()) {
                            let e = this.geometry.drawCount,
                                t = this.geometry.userData;
                            this.updateGeometry(Object.assign(this.geometry.userData, {
                                parameters: Object.assign(t.parameters, {
                                    surfaceMaxCount: e + 1e3
                                })
                            }))
                        }
                    } else this.updateGeometry({});
                    this.computeSingleBoundingBox(), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox()
                };
                this.castShadow = !0, this.receiveShadow = !0, this.forceComputeSize = !0, this.shape = e.userData.shape, this.shape.eventDispatcher?.addEventListener("update", this._onShapeUpdate)
            }
            toJSON(e) {
                let t = super.toJSON(e);
                return t.object.objectType = "VectorObject", t
            }
            setHelperVisibility() {}
            updateGeometry(e) {
                if (super.updateGeometry(e), "userData" in this.geometry) {
                    let t = this.geometry.userData.parameters;
                    this.eventDispatcher.dispatchEvent({
                        type: "geometryUpdate",
                        parameters: t
                    })
                }
            }
            setShape(e) {
                this.shape && this.shape.eventDispatcher?.removeEventListener("update", this._onShapeUpdate), this.shape = e, this.shape.eventDispatcher?.addEventListener("update", this._onShapeUpdate)
            }
            updateWorldMatrix(e, t) {
                super.updateWorldMatrix(e, t), pm.getNormalMatrix(this.matrixWorld), hm.copy(uA).applyMatrix3(pm).normalize(), mm.setFromMatrixPosition(this.matrixWorld), this.shape.plane.setFromNormalAndCoplanarPoint(hm, mm)
            }
            clone(e) {
                let t = this.shape.clone(),
                    r = this.material.clone(),
                    i = this.geometry.userData,
                    s = lr.create(Object.assign({}, i, {
                        shape: t
                    })),
                    o = new aa(s, r).copy(this, e);
                return o.shape = t, t.update(), o
            }
            raycast(e, t) {
                Nr.prototype.raycast.call(this, e, t)
            }
        };
    var _i = (n, e) => class extends n {
        constructor() {
            super(...arguments);
            this.objectHelper = new e(this);
            this.enableHelper = !1
        }
        set visibility(r) {
            this.visible = r, this.setHelperVisibility(r), this.setHelperChildrenVisibility(r)
        }
        get visibility() {
            return this.visible
        }
        get geometryHelper() {
            return e.geometryHelper
        }
        setHelperVisibility(r) {
            this.objectHelper.visible = r
        }
        setHelperChildrenVisibility(r) {
            for (let i of this.children) Sr(i) && i.traverseEntity(s => {
                Hu(s) && s.visible && (s.objectHelper.visible = r)
            })
        }
        raycast(r, i) {
            this.objectHelper.raycast(r, i)
        }
        copy(r, i = !0) {
            return super.copy(r, i), r.enableHelper !== void 0 && (this.enableHelper = r.enableHelper), r.objectHelper !== void 0 && (this.objectHelper.visible = r.objectHelper.visible), this
        }
        toJSON(r) {
            let i = super.toJSON(r),
                s = i.object;
            return s.enableHelper = this.enableHelper, i
        }
        fromJSON(r) {
            return super.fromJSON(r), r.enableHelper !== void 0 && (this.enableHelper = !0), this
        }
    };
    var Un = class extends _i(kr(jr.Camera), ia) {
        constructor(e = 100, t = 100, r = 45, i = 50, s = 5e4) {
            super();
            this.objectType = "CombinedCamera";
            this.width = window.innerWidth, this.height = window.innerHeight, this.orthoCamera = new jr.OrthographicCamera(e * -.5, e * .5, t * .5, t * -.5, i, s), this.perspCamera = new jr.PerspectiveCamera(r, e / t, i, s), this._cameraType = "OrthographicCamera", this.left = this.orthoCamera.left, this.right = this.orthoCamera.right, this.top = this.orthoCamera.top, this.bottom = this.orthoCamera.bottom, this.far = this.orthoCamera.far, this.view = this.orthoCamera.view, this.aspect = this.perspCamera.aspect, this.fov = this.perspCamera.fov, this.focus = this.perspCamera.focus, this.filmGauge = this.perspCamera.filmGauge, this.filmOffset = this.perspCamera.filmOffset, this.targetOffset = 1e3, this.toOrthographic(!0)
        }
        setDefault() {
            this.name = "Default Camera", this.isEntity = !1, this.enableHelper = !1, this.objectHelper.visible = !1
        }
        get isPerspectiveCamera() {
            return this.cameraType === "PerspectiveCamera"
        }
        get isOrthographicCamera() {
            return !this.isPerspectiveCamera
        }
        get cameraType() {
            return this._cameraType
        }
        set cameraType(e) {
            e === "PerspectiveCamera" ? this.toPerspective() : e === "OrthographicCamera" && this.toOrthographic()
        }
        get near() {
            return this._cameraType === "PerspectiveCamera" ? this.perspCamera.near : this.orthoCamera.near
        }
        set near(e) {
            this._cameraType === "PerspectiveCamera" ? this.perspCamera.near = e : this.orthoCamera.near = e
        }
        get zoom() {
            return this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom : this.orthoCamera.zoom
        }
        set zoom(e) {
            e >= 0 && (this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom = e : this.orthoCamera.zoom = e)
        }
        getTarget(e) {
            let r = this.getWorldDirection(new jr.Vector3).multiplyScalar(this.targetOffset);
            return e.copy(this.position).add(r), e
        }
        getViewFrontToObject(e) {
            let t = e.getWorldPosition(new jr.Vector3),
                i = e.getWorldDirection(new jr.Vector3).multiplyScalar(this.targetOffset);
            return {
                position: t.clone().add(i),
                target: t
            }
        }
        getViewToObject(e) {
            let t = e.getWorldPosition(new jr.Vector3),
                i = this.getWorldDirection(new jr.Vector3).multiplyScalar(this.targetOffset);
            return {
                position: t.clone().sub(i),
                target: t
            }
        }
        setViewplaneSize(e, t) {
            this.left = -e * .5, this.right = e * .5, this.top = t * .5, this.bottom = -t * .5, this.aspect = e / t, this.updateProjectionMatrix()
        }
        toOrthographic(e) {
            this.orthoCamera.left = this.left, this.orthoCamera.right = this.right, this.orthoCamera.top = this.top, this.orthoCamera.bottom = this.bottom, this.orthoCamera.view = this.view, this.orthoCamera.far = this.far, this.orthoCamera.updateProjectionMatrix(), this.projectionMatrix = this.orthoCamera.projectionMatrix, this.projectionMatrixInverse = this.orthoCamera.projectionMatrixInverse, this._cameraType = "OrthographicCamera", (this.enableHelper === !0 || e === !0) && this.objectHelper.update()
        }
        toPerspective(e) {
            this.perspCamera.aspect = this.aspect, this.perspCamera.fov = this.fov, this.perspCamera.view = this.view, this.perspCamera.far = this.far, this.perspCamera.updateProjectionMatrix(), this.projectionMatrix = this.perspCamera.projectionMatrix, this.projectionMatrixInverse = this.perspCamera.projectionMatrixInverse, this._cameraType = "PerspectiveCamera", (this.enableHelper === !0 || e === !0) && this.objectHelper.update()
        }
        setFocalLength(e) {
            this.perspCamera.setFocalLength(e), this.toPerspective()
        }
        getFocalLength() {
            return this.perspCamera.getFocalLength()
        }
        getEffectiveFOV() {
            return this.perspCamera.getEffectiveFOV()
        }
        getFilmWidth() {
            return this.perspCamera.getFilmWidth()
        }
        getFilmHeight() {
            return this.perspCamera.getFilmHeight()
        }
        setViewOffset(e, t, r, i, s, o) {
            this._cameraType === "PerspectiveCamera" ? this.perspCamera.setViewOffset(e, t, r, i, s, o) : this.orthoCamera.setViewOffset(e, t, r, i, s, o)
        }
        clearViewOffset() {
            this._cameraType === "PerspectiveCamera" ? (this.perspCamera.clearViewOffset(), this.toPerspective()) : (this.orthoCamera.clearViewOffset(), this.toOrthographic())
        }
        updateProjectionMatrix(e) {
            this._cameraType === "PerspectiveCamera" ? this.toPerspective(e) : this._cameraType === "OrthographicCamera" && this.toOrthographic(e)
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        raycast(e, t) {
            this.enableHelper && this.objectHelper.visible && this.objectHelper.raycast(e, t)
        }
        copy(e, t) {
            return super.copy(e, t), this.orthoCamera.copy(e.orthoCamera), this.perspCamera.copy(e.perspCamera), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.far = e.far, this.view = e.view === null ? null : Object.assign({}, e.view), this._cameraType = e._cameraType, this.aspect = e.aspect, this.fov = e.fov, this.focus = e.focus, this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this.targetOffset = e.targetOffset, this.updateProjectionMatrix(), this
        }
        fromCameraRender(e) {
            let t = {
                    near: this.orthoCamera.near,
                    far: this.orthoCamera.far
                },
                r = {
                    near: this.perspCamera.near,
                    far: this.perspCamera.far
                };
            return this.copy(e), this.name = "", this.isEntity = !0, this.enableHelper = !0, this.objectHelper.visible = !0, this.orthoCamera.near = t.near, this.orthoCamera.far = t.far, this.perspCamera.near = r.near, this.perspCamera.far = r.far, this.updateProjectionMatrix(), this
        }
        toJSON(e) {
            let t = super.toJSON(e),
                r = t.object;
            return r.objectType = "CombinedCamera", r.cameraType = this.cameraType, r.targetOffset = this.targetOffset, r.left = this.left, r.right = this.right, r.top = this.top, r.bottom = this.bottom, this.view !== null && (r.view = Object.assign({}, this.view)), r.zoomOrtho = this.orthoCamera.zoom, r.nearOrtho = this.orthoCamera.near, r.far = this.far, r.aspect = this.aspect, r.fov = this.fov, r.focus = this.focus, r.filmGauge = this.filmGauge, r.filmOffset = this.filmOffset, r.zoomPersp = this.perspCamera.zoom, r.nearPersp = this.perspCamera.near, t
        }
        fromJSON(e) {
            return super.fromJSON(e), this.cameraType = e.cameraType, e.targetOffset !== void 0 && (this.targetOffset = e.targetOffset), e.left !== void 0 && (this.left = e.left), e.right !== void 0 && (this.right = e.right), e.top !== void 0 && (this.top = e.top), e.bottom !== void 0 && (this.bottom = e.bottom), e.view !== void 0 && (this.view = Object.assign({}, e.view)), e.zoomOrtho !== void 0 && (this.orthoCamera.zoom = e.zoomOrtho), e.nearOrtho !== void 0 && (this.orthoCamera.near = e.nearOrtho), e.far !== void 0 && (this.far = e.far), e.aspect !== void 0 && (this.aspect = e.aspect), e.fov !== void 0 && (this.fov = e.fov), e.focus !== void 0 && (this.focus = e.focus), e.filmGauge !== void 0 && (this.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (this.filmOffset = e.filmOffset), e.zoomPersp !== void 0 && (this.perspCamera.zoom = e.zoomPersp), e.nearPersp !== void 0 && (this.perspCamera.near = e.nearPersp), this.updateProjectionMatrix(), this
        }
    };
    var gm = W(J());
    var dn = class extends _i(kr(gm.Group), sa) {
        constructor() {
            super(...arguments);
            this.objectType = "EmptyObject"
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return t.object.objectType = "EmptyObject", t
        }
    };
    var jn = W(J());
    var Qu = class extends _i(kr(jn.DirectionalLight), na) {
        constructor(...e) {
            super(...e);
            this.objectType = "LightDirectional";
            this._gizmos = {};
            this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024;
            let r = this.shadow.camera;
            r.top = 1250, r.bottom = -1250, r.right = 1250, r.left = -1250, r.near = 1, r.far = 2500;
            let i = new jn.CameraHelper(this.shadow.camera);
            i.visible = !1, this._gizmos.shadowmap = i, this.update()
        }
        get gizmos() {
            return this._gizmos
        }
        showGizmos() {
            for (let e in this._gizmos) {
                let t = this._gizmos[e];
                t instanceof jn.CameraHelper && (t.visible = !0)
            }
        }
        hideGizmos() {
            for (let e in this._gizmos) {
                let t = this._gizmos[e];
                t instanceof jn.CameraHelper && (t.visible = !1)
            }
        }
        update() {
            this.shadow.camera.updateProjectionMatrix();
            for (let e in this._gizmos) {
                let t = this._gizmos[e];
                t instanceof jn.CameraHelper && t.update()
            }
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.enableHelper === !0 && this.objectHelper.visible === !0 && this.objectHelper.update()
        }
        copy(e, t = !0) {
            return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
        toJSON(e) {
            let t = super.toJSON(e),
                r = t.object;
            return r.objectType = "LightDirectional", r.color = this.color.getHex(), r.intensity = this.intensity, r.shadow = this.shadow.toJSON(), t
        }
        fromJSON(e) {
            super.fromJSON(e), this.color.set(e.color), this.intensity = e.intensity, this.shadow.normalBias = e.shadow.normalBias ?? 0, this.shadow.radius = e.shadow.radius, this.shadow.mapSize.fromArray(e.shadow.mapSize);
            let t = this.shadow.camera,
                r = e.shadow.camera;
            return t.near = r.near, t.far = r.far, t.zoom = r.zoom, t.left = r.left, t.right = r.right, t.top = r.top, t.bottom = r.bottom, r.view !== void 0 && (t.view = Object.assign({}, r.view)), this
        }
    };
    var ir = W(J());
    var Yu = class extends _i(kr(ir.PointLight), oa) {
        constructor(...e) {
            super(...e);
            this.objectType = "LightPoint";
            this._gizmos = {};
            this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024;
            let r = this.shadow.camera;
            r.fov = 90, r.aspect = 1, r.near = 100, r.far = 2500;
            let i = new ir.Vector3(-r.far + this.position.x, -r.far + this.position.y, -r.far + this.position.z),
                s = new ir.Vector3(r.far + this.position.x, r.far + this.position.y, r.far + this.position.z),
                o = new ir.Box3(i, s),
                l = new ir.Box3Helper(o, new ir.Color(16755200));
            l.visible = !1, this._gizmos.shadowmap = l, this.update()
        }
        get gizmos() {
            return this._gizmos
        }
        showGizmos() {
            for (let e in this._gizmos) {
                let t = this._gizmos[e];
                t instanceof ir.Box3Helper && (t.visible = !0)
            }
        }
        hideGizmos() {
            for (let e in this._gizmos) {
                let t = this._gizmos[e];
                t instanceof ir.Box3Helper && (t.visible = !1)
            }
        }
        update() {
            if (this.shadow && (this.shadow.camera.updateProjectionMatrix(), this._gizmos))
                for (let e in this._gizmos) {
                    let t = this._gizmos[e];
                    if (t instanceof ir.Box3Helper) {
                        let r = this.shadow.camera,
                            i = new ir.Vector3(-r.far + this.position.x, -r.far + this.position.y, -r.far + this.position.z),
                            s = new ir.Vector3(r.far + this.position.x, r.far + this.position.y, r.far + this.position.z);
                        t.box.set(i, s), t.updateMatrixWorld(!0)
                    }
                }
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.enableHelper === !0 && this.objectHelper.visible === !0 && this.objectHelper.update()
        }
        copy(e, t = !0) {
            return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
        toJSON(e) {
            let t = super.toJSON(e),
                r = t.object;
            return r.objectType = "LightPoint", r.color = this.color.getHex(), r.intensity = this.intensity, r.distance = this.distance, r.decay = this.decay, r.shadow = this.shadow.toJSON(), t
        }
        fromJSON(e) {
            super.fromJSON(e), this.color.set(e.color), this.intensity = e.intensity, this.distance = e.distance, this.decay = e.decay, this.shadow.normalBias = e.shadow.normalBias ?? 0, this.shadow.radius = e.shadow.radius, this.shadow.mapSize.fromArray(e.shadow.mapSize);
            let t = this.shadow.camera,
                r = e.shadow.camera;
            return t.near = r.near, t.far = r.far, t.zoom = r.zoom, t.fov = r.fov, t.focus = r.focus, t.aspect = r.aspect, t.filmGauge = r.filmGauge, t.filmOffset = r.filmOffset, r.view !== void 0 && (t.view = Object.assign({}, r.view)), this
        }
    };
    var Cr = W(J());
    var vm = new Cr.Vector3,
        ym = new Cr.Vector3,
        xm = new Cr.Quaternion,
        Ku = class extends _i(kr(Cr.SpotLight), Bl) {
            constructor(...e) {
                super(...e);
                this.objectType = "LightSpot";
                this._gizmos = {};
                this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024;
                let r = this.shadow.camera;
                r.fov = Cr.MathUtils.RAD2DEG * 2 * this.angle, r.aspect = 1, r.near = 100, r.far = 2500;
                let i = new Cr.CameraHelper(this.shadow.camera);
                i.visible = !1, this._gizmos.shadowmap = i, this.update()
            }
            get gizmos() {
                return this._gizmos
            }
            showGizmos() {
                for (let e in this._gizmos) {
                    let t = this._gizmos[e];
                    t instanceof Cr.CameraHelper && (t.visible = !0)
                }
            }
            hideGizmos() {
                for (let e in this._gizmos) {
                    let t = this._gizmos[e];
                    t instanceof Cr.CameraHelper && (t.visible = !1)
                }
            }
            update() {
                this.shadow.camera.updateProjectionMatrix();
                for (let e in this._gizmos) {
                    let t = this._gizmos[e];
                    t instanceof Cr.CameraHelper && t.update()
                }
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e), ym.setFromMatrixPosition(this.matrixWorld), xm.setFromRotationMatrix(this.matrixWorld), vm.copy(this.up).applyQuaternion(xm).negate().multiplyScalar(this.distance), this.target.position.copy(ym).add(vm), this.target.updateMatrixWorld(), this.enableHelper === !0 && this.objectHelper.visible === !0 && this.objectHelper.update()
            }
            copy(e, t = !0) {
                return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
            toJSON(e) {
                let t = super.toJSON(e),
                    r = t.object;
                return r.objectType = "LightSpot", r.color = this.color.getHex(), r.intensity = this.intensity, r.distance = this.distance, r.angle = this.angle, r.decay = this.decay, r.penumbra = this.penumbra, r.shadow = this.shadow.toJSON(), t
            }
            fromJSON(e) {
                super.fromJSON(e), this.color.set(e.color), this.intensity = e.intensity, this.distance = e.distance, this.angle = e.angle, this.decay = e.decay, this.penumbra = e.penumbra, this.shadow.normalBias = e.shadow.normalBias ?? 0, this.shadow.radius = e.shadow.radius, this.shadow.mapSize.fromArray(e.shadow.mapSize);
                let t = this.shadow.camera,
                    r = e.shadow.camera;
                return t.near = r.near, t.far = r.far, t.zoom = r.zoom, t.fov = r.fov, t.focus = r.focus, t.aspect = r.aspect, t.filmGauge = r.filmGauge, t.filmOffset = r.filmOffset, r.view !== void 0 && (t.view = Object.assign({}, r.view)), this
            }
        };
    var bm = W(J());
    var Am = n => n.tagName === "VIDEO",
        Vs = class {
            static resize(e, t, r) {
                let i = e / t,
                    s;
                if (!r.image) return;
                let o = r.image;
                Am(o) ? s = o.videoWidth / o.videoHeight : s = o.width / o.height, i > s && (r.imageType == "WEBCAM" ? r.repeat.set(-1, 1 * s / i) : r.repeat.set(1, 1 * s / i)), i < s && (r.imageType == "WEBCAM" ? r.repeat.set(1 * i / s * -1, 1) : r.repeat.set(1 * i / s, 1)), i == s && (r.imageType == "WEBCAM" ? r.repeat.set(-1, 1) : r.repeat.set(1, 1))
            }
            static resizeTextureLayer(e, t, r) {
                let i = e / t,
                    s = r.image !== void 0 ? r.image.width / r.image.height : 1,
                    o;
                i > s ? o = {
                    x: 1,
                    y: s / i
                } : i < s ? o = {
                    x: i / s,
                    y: 1
                } : o = {
                    x: 1,
                    y: 1
                }, r.repeat.set(o.x, o.y), r.updateMatrix()
            }
            static resizeTextureLayers(e, t, r) {
                let i = r.userData.layers,
                    s = i.getLayers();
                for (let o = 0; o < s.length; o++) {
                    let l = s[o];
                    il(l) && (Vs.resizeTextureLayer(e, t, l.uniforms[`f${l.id}_texture`].value), i.updateLayerUniform())
                }
            }
            static resizeComplex(e, t, r, i) {
                let s = e / t,
                    o, l = r.image;
                Am(l) ? o = l.videoWidth / l.videoHeight : o = l.width / l.height, i.geometry.type.includes("Shape") ? (s > o && (r.imageType == "WEBCAM" ? r.repeat.set(1 / e * -1, 1 / t * o / s) : r.repeat.set(1 / e, 1 / t * o / s)), s < o && (r.imageType == "WEBCAM" ? r.repeat.set(1 / e * s / o * -1, 1 / t) : r.repeat.set(1 / e * s / o, 1 / t)), s == o && (r.imageType == "WEBCAM" ? r.repeat.set(1 / e * -1, 1 / t) : r.repeat.set(1 / e, 1 / t))) : (s > o && (r.imageType == "WEBCAM" ? r.repeat.set(-1, 1 * o / s) : r.repeat.set(1, 1 * o / s)), s < o && (r.imageType == "WEBCAM" ? r.repeat.set(1 * s / o * -1, 1) : r.repeat.set(1 * s / o, 1)), s == o && (r.imageType == "WEBCAM" ? r.repeat.set(-1, 1) : r.repeat.set(1, 1)))
            }
        };
    var la = class extends Nr {
        constructor(e, t = new Pr) {
            super(e, t);
            this.objectType = "Mesh2D";
            this.castShadow = !0, this.receiveShadow = !0
        }
        updateGeometry(e) {
            super.updateGeometry(e), this.material.userData.layers && Vs.resizeTextureLayers(this.geometry.userData.parameters.width, this.geometry.userData.parameters.height, this.material)
        }
        resizeGeometry(e, t) {
            super.resizeGeometry(e, t, 0), this.material.userData.layers && Vs.resizeTextureLayers(this.geometry.userData.parameters.width, this.geometry.userData.parameters.height, this.material)
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return t.object.objectType = "Mesh2D", t
        }
        static fromTexture(e) {
            let t, r;
            if (e instanceof bm.VideoTexture) {
                let o = e.image;
                t = o.videoWidth * .5, r = o.videoHeight * .5
            } else {
                let o = e.image;
                t = o.width * .5, r = o.height * .5
            }
            let i = xl.create({
                    parameters: {
                        width: t,
                        height: r
                    }
                }),
                s = new Pr;
            return s.layersList.changeLayer(0, {
                type: pt.TEXTURE,
                texture: e
            }), s.layersList.moveLayer(0, 1), s.dispose(), new la(i, s)
        }
    };
    var ca = class extends Nr {
        constructor(e, t = new zr) {
            super(e, t);
            this.objectType = "Mesh3D";
            this.castShadow = !0, this.receiveShadow = !0
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return t.object.objectType = "Mesh3D", t
        }
    };
    var Xu = class extends ca {
        constructor(e, t = new zr) {
            super(e, t);
            this.objectType = "NonParametric"
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return t.object.objectType = "NonParametric", t
        }
    };
    var hn;
    (function(r) {
        r[r.TEXT = 0] = "TEXT", r[r.ARRAY_BUFFER = 1] = "ARRAY_BUFFER", r[r.BINARY_STRING = 2] = "BINARY_STRING"
    })(hn || (hn = {}));

    function Sm(n, e, t = 1) {
        let r = new FileReader;
        return new Promise((i, s) => {
            let o = () => {
                s({
                    error: !0,
                    filename: n.name
                }), e.itemError(n.name), e.itemEnd(n.name)
            };
            switch (r.addEventListener("loadstart", () => {
                    e.itemStart(n.name)
                }), r.addEventListener("load", l => {
                    let a = l.target?.result;
                    a != null ? i(a) : o()
                }, !1), r.addEventListener("error", o), t) {
                case 0:
                    r.readAsText(n);
                    break;
                case 2:
                    r.readAsBinaryString !== void 0 && r.readAsBinaryString(n);
                    break;
                case 1:
                default:
                    r.readAsArrayBuffer(n)
            }
        })
    }
    var H = W(J()),
        qu = class extends H.Loader {
            constructor(e) {
                super(e);
                this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
                    return new Tm(t)
                }), this.register(function(t) {
                    return new Lm(t)
                }), this.register(function(t) {
                    return new Dm(t)
                }), this.register(function(t) {
                    return new Em(t)
                }), this.register(function(t) {
                    return new Mm(t)
                }), this.register(function(t) {
                    return new _m(t)
                }), this.register(function(t) {
                    return new Im(t)
                }), this.register(function(t) {
                    return new Nm(t)
                }), this.register(function(t) {
                    return new Pm(t)
                })
            }
            load(e, t, r, i) {
                let s = this,
                    o;
                this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = H.LoaderUtils.extractUrlBase(e), this.manager.itemStart(e);
                let l = function(c) {
                        i ? i(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e)
                    },
                    a = new H.FileLoader(this.manager);
                a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(c) {
                    try {
                        s.parse(c, o, function(f) {
                            t(f), s.manager.itemEnd(e)
                        }, l)
                    } catch (f) {
                        l(f)
                    }
                }, r, l)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e, this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e, this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e, this
            }
            register(e) {
                return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
            }
            unregister(e) {
                return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
            }
            parse(e, t, r, i) {
                let s, o = {},
                    l = {};
                if (typeof e == "string") s = e;
                else if (H.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === Bm) {
                    try {
                        o[ot.KHR_BINARY_GLTF] = new Rm(e)
                    } catch (h) {
                        i && i(h);
                        return
                    }
                    s = o[ot.KHR_BINARY_GLTF].content
                } else s = H.LoaderUtils.decodeText(new Uint8Array(e));
                let a = JSON.parse(s);
                if (a.asset === void 0 || a.asset.version[0] < 2) {
                    i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                    return
                }
                let c = new Jm(a, {
                    path: t || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                c.fileLoader.setRequestHeader(this.requestHeader);
                for (let f = 0; f < this.pluginCallbacks.length; f++) {
                    let h = this.pluginCallbacks[f](c);
                    l[h.name] = h, o[h.name] = !0
                }
                if (a.extensionsUsed)
                    for (let f = 0; f < a.extensionsUsed.length; ++f) {
                        let h = a.extensionsUsed[f],
                            m = a.extensionsRequired || [];
                        switch (h) {
                            case ot.KHR_MATERIALS_UNLIT:
                                o[h] = new Cm;
                                break;
                            case ot.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                o[h] = new zm;
                                break;
                            case ot.KHR_DRACO_MESH_COMPRESSION:
                                o[h] = new Fm(a, this.dracoLoader);
                                break;
                            case ot.KHR_TEXTURE_TRANSFORM:
                                o[h] = new Gm;
                                break;
                            case ot.KHR_MESH_QUANTIZATION:
                                o[h] = new km;
                                break;
                            default:
                                m.indexOf(h) >= 0 && l[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
                        }
                    }
                c.setExtensions(o), c.setPlugins(l), c.parse(r, i)
            }
        };

    function dA() {
        let n = {};
        return {
            get: function(e) {
                return n[e]
            },
            add: function(e, t) {
                n[e] = t
            },
            remove: function(e) {
                delete n[e]
            },
            removeAll: function() {
                n = {}
            }
        }
    }
    var ot = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
        },
        Nm = class {
            constructor(e) {
                this.parser = e, this.name = ot.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                let e = this.parser,
                    t = this.parser.json.nodes || [];
                for (let r = 0, i = t.length; r < i; r++) {
                    let s = t[r];
                    s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
                }
            }
            _loadLight(e) {
                let t = this.parser,
                    r = "light:" + e,
                    i = t.cache.get(r);
                if (i) return i;
                let s = t.json,
                    a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e],
                    c, f = new H.Color(16777215);
                a.color !== void 0 && f.fromArray(a.color);
                let h = a.range !== void 0 ? a.range : 0;
                switch (a.type) {
                    case "directional":
                        c = new H.DirectionalLight(f), c.target.position.set(0, 0, -1), c.add(c.target);
                        break;
                    case "point":
                        c = new H.PointLight(f), c.distance = h;
                        break;
                    case "spot":
                        c = new H.SpotLight(f), c.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, c.angle = a.spot.outerConeAngle, c.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type)
                }
                return c.position.set(0, 0, 0), c.decay = 2, a.intensity !== void 0 && (c.intensity = a.intensity), c.name = t.createUniqueName(a.name || "light_" + e), i = Promise.resolve(c), t.cache.add(r, i), i
            }
            createNodeAttachment(e) {
                let t = this,
                    r = this.parser,
                    s = r.json.nodes[e],
                    l = (s.extensions && s.extensions[this.name] || {}).light;
                return l === void 0 ? null : this._loadLight(l).then(function(a) {
                    return r._getNodeRef(t.cache, l, a)
                })
            }
        },
        Cm = class {
            constructor() {
                this.name = ot.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return H.MeshBasicMaterial
            }
            extendParams(e, t, r) {
                let i = [];
                e.color = new H.Color(1, 1, 1), e.opacity = 1;
                let s = t.pbrMetallicRoughness;
                if (s) {
                    if (Array.isArray(s.baseColorFactor)) {
                        let o = s.baseColorFactor;
                        e.color.fromArray(o), e.opacity = o[3]
                    }
                    s.baseColorTexture !== void 0 && i.push(r.assignTexture(e, "map", s.baseColorTexture))
                }
                return Promise.all(i)
            }
        },
        Tm = class {
            constructor(e) {
                this.parser = e, this.name = ot.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                let r = this.parser.json.materials[e];
                return !r.extensions || !r.extensions[this.name] ? null : H.MeshPhysicalMaterial
            }
            extendMaterialParams(e, t) {
                let r = this.parser,
                    i = r.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                let s = [],
                    o = i.extensions[this.name];
                if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
                    let l = o.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new H.Vector2(l, -l)
                }
                return Promise.all(s)
            }
        },
        Em = class {
            constructor(e) {
                this.parser = e, this.name = ot.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                let r = this.parser.json.materials[e];
                return !r.extensions || !r.extensions[this.name] ? null : H.MeshPhysicalMaterial
            }
            extendMaterialParams(e, t) {
                let r = this.parser,
                    i = r.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                let s = [],
                    o = i.extensions[this.name];
                return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(r.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s)
            }
        },
        Mm = class {
            constructor(e) {
                this.parser = e, this.name = ot.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                let r = this.parser.json.materials[e];
                return !r.extensions || !r.extensions[this.name] ? null : H.MeshPhysicalMaterial
            }
            extendMaterialParams(e, t) {
                let r = this.parser,
                    i = r.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                let s = [],
                    o = i.extensions[this.name];
                t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 0;
                let l = o.attenuationColor || [1, 1, 1];
                return t.attenuationTint = new H.Color(l[0], l[1], l[2]), Promise.all(s)
            }
        },
        _m = class {
            constructor(e) {
                this.parser = e, this.name = ot.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                let r = this.parser.json.materials[e];
                return !r.extensions || !r.extensions[this.name] ? null : H.MeshPhysicalMaterial
            }
            extendMaterialParams(e, t) {
                let i = this.parser.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                let s = i.extensions[this.name];
                return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve()
            }
        },
        Im = class {
            constructor(e) {
                this.parser = e, this.name = ot.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                let r = this.parser.json.materials[e];
                return !r.extensions || !r.extensions[this.name] ? null : H.MeshPhysicalMaterial
            }
            extendMaterialParams(e, t) {
                let r = this.parser,
                    i = r.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                let s = [],
                    o = i.extensions[this.name];
                t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
                let l = o.specularColorFactor || [1, 1, 1];
                return t.specularTint = new H.Color(l[0], l[1], l[2]), o.specularColorTexture !== void 0 && s.push(r.assignTexture(t, "specularTintMap", o.specularColorTexture).then(function(a) {
                    a.encoding = H.sRGBEncoding
                })), Promise.all(s)
            }
        },
        Lm = class {
            constructor(e) {
                this.parser = e, this.name = ot.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                let t = this.parser,
                    r = t.json,
                    i = r.textures[e];
                if (!i.extensions || !i.extensions[this.name]) return null;
                let s = i.extensions[this.name],
                    o = r.images[s.source],
                    l = t.options.ktx2Loader;
                if (!l) {
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, o, l)
            }
        },
        Dm = class {
            constructor(e) {
                this.parser = e, this.name = ot.EXT_TEXTURE_WEBP, this.isSupported = null
            }
            loadTexture(e) {
                let t = this.name,
                    r = this.parser,
                    i = r.json,
                    s = i.textures[e];
                if (!s.extensions || !s.extensions[t]) return null;
                let o = s.extensions[t],
                    l = i.images[o.source],
                    a = r.textureLoader;
                if (l.uri) {
                    let c = r.options.manager.getHandler(l.uri);
                    c !== null && (a = c)
                }
                return this.detectSupport().then(function(c) {
                    if (c) return r.loadTextureImage(e, l, a);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return r.loadTexture(e)
                })
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise(function(e) {
                    let t = new Image;
                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                        e(t.height === 1)
                    }
                })), this.isSupported
            }
        },
        Pm = class {
            constructor(e) {
                this.name = ot.EXT_MESHOPT_COMPRESSION, this.parser = e
            }
            loadBufferView(e) {
                let t = this.parser.json,
                    r = t.bufferViews[e];
                if (r.extensions && r.extensions[this.name]) {
                    let i = r.extensions[this.name],
                        s = this.parser.getDependency("buffer", i.buffer),
                        o = this.parser.options.meshoptDecoder;
                    if (!o || !o.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return Promise.all([s, o.ready]).then(function(l) {
                        let a = i.byteOffset || 0,
                            c = i.byteLength || 0,
                            f = i.count,
                            h = i.byteStride,
                            m = new ArrayBuffer(f * h),
                            v = new Uint8Array(l[0], a, c);
                        return o.decodeGltfBuffer(new Uint8Array(m), f, h, v, i.mode, i.filter), m
                    })
                } else return null
            }
        },
        Bm = "glTF",
        ua = 12,
        Om = {
            JSON: 1313821514,
            BIN: 5130562
        },
        Rm = class {
            constructor(e) {
                this.name = ot.KHR_BINARY_GLTF, this.content = null, this.body = null;
                let t = new DataView(e, 0, ua);
                if (this.header = {
                        magic: H.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
                        version: t.getUint32(4, !0),
                        length: t.getUint32(8, !0)
                    }, this.header.magic !== Bm) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                let r = this.header.length - ua,
                    i = new DataView(e, ua),
                    s = 0;
                for (; s < r;) {
                    let o = i.getUint32(s, !0);
                    s += 4;
                    let l = i.getUint32(s, !0);
                    if (s += 4, l === Om.JSON) {
                        let a = new Uint8Array(e, ua + s, o);
                        this.content = H.LoaderUtils.decodeText(a)
                    } else if (l === Om.BIN) {
                        let a = ua + s;
                        this.body = e.slice(a, a + o)
                    }
                    s += o
                }
                if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        },
        Fm = class {
            constructor(e, t) {
                if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = ot.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                let r = this.json,
                    i = this.dracoLoader,
                    s = e.extensions[this.name].bufferView,
                    o = e.extensions[this.name].attributes,
                    l = {},
                    a = {},
                    c = {};
                for (let f in o) {
                    let h = Zu[f] || f.toLowerCase();
                    l[h] = o[f]
                }
                for (let f in e.attributes) {
                    let h = Zu[f] || f.toLowerCase();
                    if (o[f] !== void 0) {
                        let m = r.accessors[e.attributes[f]],
                            v = fa[m.componentType];
                        c[h] = v, a[h] = m.normalized === !0
                    }
                }
                return t.getDependency("bufferView", s).then(function(f) {
                    return new Promise(function(h) {
                        i.decodeDracoFile(f, function(m) {
                            for (let v in m.attributes) {
                                let g = m.attributes[v],
                                    y = a[v];
                                y !== void 0 && (g.normalized = y)
                            }
                            h(m)
                        }, l, c)
                    })
                })
            }
        },
        Gm = class {
            constructor() {
                this.name = ot.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
            }
        },
        Rl = class extends H.MeshStandardMaterial {
            constructor(e) {
                super();
                this.isGLTFSpecularGlossinessMaterial = !0;
                let t = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`),
                    r = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`),
                    i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	texelSpecular = sRGBToLinear( texelSpecular );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`),
                    s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`),
                    o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`),
                    l = {
                        specular: {
                            value: new H.Color().setHex(16777215)
                        },
                        glossiness: {
                            value: 1
                        },
                        specularMap: {
                            value: null
                        },
                        glossinessMap: {
                            value: null
                        }
                    };
                this._extraUniforms = l, this.onBeforeCompile = function(a) {
                    for (let c in l) a.uniforms[c] = l[c];
                    a.fragmentShader = a.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", r).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o)
                }, Object.defineProperties(this, {
                    specular: {
                        get: function() {
                            return l.specular.value
                        },
                        set: function(a) {
                            l.specular.value = a
                        }
                    },
                    specularMap: {
                        get: function() {
                            return l.specularMap.value
                        },
                        set: function(a) {
                            l.specularMap.value = a, a ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                        }
                    },
                    glossiness: {
                        get: function() {
                            return l.glossiness.value
                        },
                        set: function(a) {
                            l.glossiness.value = a
                        }
                    },
                    glossinessMap: {
                        get: function() {
                            return l.glossinessMap.value
                        },
                        set: function(a) {
                            l.glossinessMap.value = a, a ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                        }
                    }
                }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
            }
        },
        zm = class {
            constructor() {
                this.name = ot.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
            }
            getMaterialType() {
                return Rl
            }
            extendParams(e, t, r) {
                let i = t.extensions[this.name];
                e.color = new H.Color(1, 1, 1), e.opacity = 1;
                let s = [];
                if (Array.isArray(i.diffuseFactor)) {
                    let o = i.diffuseFactor;
                    e.color.fromArray(o), e.opacity = o[3]
                }
                if (i.diffuseTexture !== void 0 && s.push(r.assignTexture(e, "map", i.diffuseTexture)), e.emissive = new H.Color(0, 0, 0), e.glossiness = i.glossinessFactor !== void 0 ? i.glossinessFactor : 1, e.specular = new H.Color(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), i.specularGlossinessTexture !== void 0) {
                    let o = i.specularGlossinessTexture;
                    s.push(r.assignTexture(e, "glossinessMap", o)), s.push(r.assignTexture(e, "specularMap", o))
                }
                return Promise.all(s)
            }
            createMaterial(e) {
                let t = new Rl(e);
                return t.fog = !0, t.color = e.color, t.map = e.map === void 0 ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = e.aoMap === void 0 ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap, t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = e.normalMap === void 0 ? null : e.normalMap, t.normalMapType = H.TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = e.specularMap === void 0 ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = e.envMap === void 0 ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t
            }
        },
        km = class {
            constructor() {
                this.name = ot.KHR_MESH_QUANTIZATION
            }
        },
        Vn = class extends H.Interpolant {
            constructor(e, t, r, i) {
                super(e, t, r, i)
            }
            copySampleValue_(e) {
                let t = this.resultBuffer,
                    r = this.sampleValues,
                    i = this.valueSize,
                    s = e * i * 3 + i;
                for (let o = 0; o !== i; o++) t[o] = r[s + o];
                return t
            }
        };
    Vn.prototype.beforeStart_ = Vn.prototype.copySampleValue_;
    Vn.prototype.afterEnd_ = Vn.prototype.copySampleValue_;
    Vn.prototype.interpolate_ = function(n, e, t, r) {
        let i = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            l = o * 2,
            a = o * 3,
            c = r - e,
            f = (t - e) / c,
            h = f * f,
            m = h * f,
            v = n * a,
            g = v - a,
            y = -2 * m + 3 * h,
            A = m - h,
            w = 1 - y,
            C = A - h + f;
        for (let S = 0; S !== o; S++) {
            let E = s[g + S + o],
                M = s[g + S + l] * c,
                L = s[v + S + o],
                I = s[v + S] * c;
            i[S] = w * E + C * M + y * L + A * I
        }
        return i
    };
    var Hi = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        },
        fa = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        Um = {
            9728: H.NearestFilter,
            9729: H.LinearFilter,
            9984: H.NearestMipmapNearestFilter,
            9985: H.LinearMipmapNearestFilter,
            9986: H.NearestMipmapLinearFilter,
            9987: H.LinearMipmapLinearFilter
        },
        jm = {
            33071: H.ClampToEdgeWrapping,
            33648: H.MirroredRepeatWrapping,
            10497: H.RepeatWrapping
        },
        Vm = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        },
        Zu = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        },
        mn = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        },
        hA = {
            CUBICSPLINE: void 0,
            LINEAR: H.InterpolateLinear,
            STEP: H.InterpolateDiscrete
        },
        $u = {
            OPAQUE: "OPAQUE",
            MASK: "MASK",
            BLEND: "BLEND"
        };

    function Hm(n, e) {
        return typeof n != "string" || n === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(n) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(n) || /^data:.*,.*$/i.test(n) || /^blob:.*$/i.test(n) ? n : e + n)
    }

    function mA(n) {
        return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new H.MeshStandardMaterial({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: !1,
            depthTest: !0,
            side: H.FrontSide
        })), n.DefaultMaterial
    }

    function da(n, e, t) {
        for (let r in t.extensions) n[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = t.extensions[r])
    }

    function Hn(n, e) {
        e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
    }

    function pA(n, e, t) {
        let r = !1,
            i = !1;
        for (let l = 0, a = e.length; l < a; l++) {
            let c = e[l];
            if (c.POSITION !== void 0 && (r = !0), c.NORMAL !== void 0 && (i = !0), r && i) break
        }
        if (!r && !i) return Promise.resolve(n);
        let s = [],
            o = [];
        for (let l = 0, a = e.length; l < a; l++) {
            let c = e[l];
            if (r) {
                let f = c.POSITION !== void 0 ? t.getDependency("accessor", c.POSITION) : n.attributes.position;
                s.push(f)
            }
            if (i) {
                let f = c.NORMAL !== void 0 ? t.getDependency("accessor", c.NORMAL) : n.attributes.normal;
                o.push(f)
            }
        }
        return Promise.all([Promise.all(s), Promise.all(o)]).then(function(l) {
            let a = l[0],
                c = l[1];
            return r && (n.morphAttributes.position = a), i && (n.morphAttributes.normal = c), n.morphTargetsRelative = !0, n
        })
    }

    function gA(n, e) {
        if (n.updateMorphTargets(), e.weights !== void 0)
            for (let t = 0, r = e.weights.length; t < r; t++) n.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
            let t = e.extras.targetNames;
            if (n.morphTargetInfluences.length === t.length) {
                n.morphTargetDictionary = {};
                for (let r = 0, i = t.length; r < i; r++) n.morphTargetDictionary[t[r]] = r
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
        }
    }

    function vA(n) {
        let e = n.extensions && n.extensions[ot.KHR_DRACO_MESH_COMPRESSION],
            t;
        return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + Wm(e.attributes) : t = n.indices + ":" + Wm(n.attributes) + ":" + n.mode, t
    }

    function Wm(n) {
        let e = "",
            t = Object.keys(n).sort();
        for (let r = 0, i = t.length; r < i; r++) e += t[r] + ":" + n[t[r]] + ";";
        return e
    }

    function ef(n) {
        switch (n) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
        }
    }
    var Jm = class {
        constructor(e = {}, t = {}) {
            this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new dA, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.textureCache = {}, this.nodeNamesUsed = {}, typeof createImageBitmap != "undefined" && /Firefox/.test(navigator.userAgent) === !1 ? this.textureLoader = new H.ImageBitmapLoader(this.options.manager) : this.textureLoader = new H.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new H.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
        }
        setExtensions(e) {
            this.extensions = e
        }
        setPlugins(e) {
            this.plugins = e
        }
        parse(e, t) {
            let r = this,
                i = this.json,
                s = this.extensions;
            this.cache.removeAll(), this._invokeAll(function(o) {
                return o._markDefs && o._markDefs()
            }), Promise.all(this._invokeAll(function(o) {
                return o.beforeRoot && o.beforeRoot()
            })).then(function() {
                return Promise.all([r.getDependencies("scene"), r.getDependencies("animation"), r.getDependencies("camera")])
            }).then(function(o) {
                let l = {
                    scene: o[0][i.scene || 0],
                    scenes: o[0],
                    animations: o[1],
                    cameras: o[2],
                    asset: i.asset,
                    parser: r,
                    userData: {}
                };
                da(s, l, i), Hn(l, i), Promise.all(r._invokeAll(function(a) {
                    return a.afterRoot && a.afterRoot(l)
                })).then(function() {
                    e(l)
                })
            }).catch(t)
        }
        _markDefs() {
            let e = this.json.nodes || [],
                t = this.json.skins || [],
                r = this.json.meshes || [];
            for (let i = 0, s = t.length; i < s; i++) {
                let o = t[i].joints;
                for (let l = 0, a = o.length; l < a; l++) e[o[l]].isBone = !0
            }
            for (let i = 0, s = e.length; i < s; i++) {
                let o = e[i];
                o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
            }
        }
        _addNodeRef(e, t) {
            t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
        }
        _getNodeRef(e, t, r) {
            if (e.refs[t] <= 1) return r;
            let i = r.clone();
            return i.name += "_instance_" + e.uses[t]++, i
        }
        _invokeOne(e) {
            let t = Object.values(this.plugins);
            t.push(this);
            for (let r = 0; r < t.length; r++) {
                let i = e(t[r]);
                if (i) return i
            }
            return null
        }
        _invokeAll(e) {
            let t = Object.values(this.plugins);
            t.unshift(this);
            let r = [];
            for (let i = 0; i < t.length; i++) {
                let s = e(t[i]);
                s && r.push(s)
            }
            return r
        }
        getDependency(e, t) {
            let r = e + ":" + t,
                i = this.cache.get(r);
            if (!i) {
                switch (e) {
                    case "scene":
                        i = this.loadScene(t);
                        break;
                    case "node":
                        i = this.loadNode(t);
                        break;
                    case "mesh":
                        i = this._invokeOne(function(s) {
                            return s.loadMesh && s.loadMesh(t)
                        });
                        break;
                    case "accessor":
                        i = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        i = this._invokeOne(function(s) {
                            return s.loadBufferView && s.loadBufferView(t)
                        });
                        break;
                    case "buffer":
                        i = this.loadBuffer(t);
                        break;
                    case "material":
                        i = this._invokeOne(function(s) {
                            return s.loadMaterial && s.loadMaterial(t)
                        });
                        break;
                    case "texture":
                        i = this._invokeOne(function(s) {
                            return s.loadTexture && s.loadTexture(t)
                        });
                        break;
                    case "skin":
                        i = this.loadSkin(t);
                        break;
                    case "animation":
                        i = this.loadAnimation(t);
                        break;
                    case "camera":
                        i = this.loadCamera(t);
                        break;
                    default:
                        throw new Error("Unknown type: " + e)
                }
                this.cache.add(r, i)
            }
            return i
        }
        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                let r = this,
                    i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
                t = Promise.all(i.map(function(s, o) {
                    return r.getDependency(e, o)
                })), this.cache.add(e, t)
            }
            return t
        }
        loadBuffer(e) {
            let t = this.json.buffers[e],
                r = this.fileLoader;
            if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[ot.KHR_BINARY_GLTF].body);
            let i = this.options;
            return new Promise(function(s, o) {
                r.load(Hm(t.uri, i.path), s, void 0, function() {
                    o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                })
            })
        }
        loadBufferView(e) {
            let t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then(function(r) {
                let i = t.byteLength || 0,
                    s = t.byteOffset || 0;
                return r.slice(s, s + i)
            })
        }
        loadAccessor(e) {
            let t = this,
                r = this.json,
                i = this.json.accessors[e];
            if (i.bufferView === void 0 && i.sparse === void 0) return Promise.resolve(null);
            let s = [];
            return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function(o) {
                let l = o[0],
                    a = Vm[i.type],
                    c = fa[i.componentType],
                    f = c.BYTES_PER_ELEMENT,
                    h = f * a,
                    m = i.byteOffset || 0,
                    v = i.bufferView !== void 0 ? r.bufferViews[i.bufferView].byteStride : void 0,
                    g = i.normalized === !0,
                    y, A;
                if (v && v !== h) {
                    let w = Math.floor(m / v),
                        C = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + w + ":" + i.count,
                        S = t.cache.get(C);
                    S || (y = new c(l, w * v, i.count * v / f), S = new H.InterleavedBuffer(y, v / f), t.cache.add(C, S)), A = new H.InterleavedBufferAttribute(S, a, m % v / f, g)
                } else l === null ? y = new c(i.count * a) : y = new c(l, m, i.count * a), A = new H.BufferAttribute(y, a, g);
                if (i.sparse !== void 0) {
                    let w = Vm.SCALAR,
                        C = fa[i.sparse.indices.componentType],
                        S = i.sparse.indices.byteOffset || 0,
                        E = i.sparse.values.byteOffset || 0,
                        M = new C(o[1], S, i.sparse.count * w),
                        L = new c(o[2], E, i.sparse.count * a);
                    l !== null && (A = new H.BufferAttribute(A.array.slice(), A.itemSize, A.normalized));
                    for (let I = 0, z = M.length; I < z; I++) {
                        let O = M[I];
                        if (A.setX(O, L[I * a]), a >= 2 && A.setY(O, L[I * a + 1]), a >= 3 && A.setZ(O, L[I * a + 2]), a >= 4 && A.setW(O, L[I * a + 3]), a >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                }
                return A
            })
        }
        loadTexture(e) {
            let t = this.json,
                r = this.options,
                i = t.textures[e],
                s = t.images[i.source],
                o = this.textureLoader;
            if (s.uri) {
                let l = r.manager.getHandler(s.uri);
                l !== null && (o = l)
            }
            return this.loadTextureImage(e, s, o)
        }
        loadTextureImage(e, t, r) {
            let i = this,
                s = this.json,
                o = this.options,
                l = s.textures[e],
                a = (t.uri || t.bufferView) + ":" + l.sampler;
            if (this.textureCache[a]) return this.textureCache[a];
            let c = self.URL || self.webkitURL,
                f = t.uri || "",
                h = !1,
                m = !0,
                v = f.search(/\.jpe?g($|\?)/i) > 0 || f.search(/^data\:image\/jpeg/) === 0;
            if ((t.mimeType === "image/jpeg" || v) && (m = !1), t.bufferView !== void 0) f = i.getDependency("bufferView", t.bufferView).then(function(y) {
                if (t.mimeType === "image/png") {
                    let w = new DataView(y, 25, 1).getUint8(0, !1);
                    m = w === 6 || w === 4 || w === 3
                }
                h = !0;
                let A = new Blob([y], {
                    type: t.mimeType
                });
                return f = c.createObjectURL(A), f
            });
            else if (t.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            let g = Promise.resolve(f).then(function(y) {
                return new Promise(function(A, w) {
                    let C = A;
                    r.isImageBitmapLoader === !0 && (C = function(S) {
                        let E = new H.Texture(S);
                        E.needsUpdate = !0, A(E)
                    }), r.load(Hm(y, o.path), C, void 0, w)
                })
            }).then(function(y) {
                h === !0 && c.revokeObjectURL(f), y.flipY = !1, l.name && (y.name = l.name), m || (y.format = H.RGBFormat);
                let w = (s.samplers || {})[l.sampler] || {};
                return y.magFilter = Um[w.magFilter] || H.LinearFilter, y.minFilter = Um[w.minFilter] || H.LinearMipmapLinearFilter, y.wrapS = jm[w.wrapS] || H.RepeatWrapping, y.wrapT = jm[w.wrapT] || H.RepeatWrapping, i.associations.set(y, {
                    type: "textures",
                    index: e
                }), y
            }).catch(function() {
                return console.error("THREE.GLTFLoader: Couldn't load texture", f), null
            });
            return this.textureCache[a] = g, g
        }
        assignTexture(e, t, r) {
            let i = this;
            return this.getDependency("texture", r.index).then(function(s) {
                if (r.texCoord !== void 0 && r.texCoord != 0 && !(t === "aoMap" && r.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + r.texCoord + " for texture " + t + " not yet supported."), i.extensions[ot.KHR_TEXTURE_TRANSFORM]) {
                    let o = r.extensions !== void 0 ? r.extensions[ot.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (o) {
                        let l = i.associations.get(s);
                        s = i.extensions[ot.KHR_TEXTURE_TRANSFORM].extendTexture(s, o), i.associations.set(s, l)
                    }
                }
                return e[t] = s, s
            })
        }
        assignFinalMaterial(e) {
            let t = e.geometry,
                r = e.material,
                i = t.attributes.tangent !== void 0,
                s = t.attributes.color !== void 0,
                o = t.attributes.normal === void 0;
            if (e.isPoints) {
                let l = "PointsMaterial:" + r.uuid,
                    a = this.cache.get(l);
                a || (a = new H.PointsMaterial, H.Material.prototype.copy.call(a, r), a.color.copy(r.color), a.map = r.map, a.sizeAttenuation = !1, this.cache.add(l, a)), r = a
            } else if (e.isLine) {
                let l = "LineBasicMaterial:" + r.uuid,
                    a = this.cache.get(l);
                a || (a = new H.LineBasicMaterial, H.Material.prototype.copy.call(a, r), a.color.copy(r.color), this.cache.add(l, a)), r = a
            }
            if (i || s || o) {
                let l = "ClonedMaterial:" + r.uuid + ":";
                r.isGLTFSpecularGlossinessMaterial && (l += "specular-glossiness:"), i && (l += "vertex-tangents:"), s && (l += "vertex-colors:"), o && (l += "flat-shading:");
                let a = this.cache.get(l);
                a || (a = r.clone(), s && (a.vertexColors = !0), o && (a.flatShading = !0), i && (a.normalScale && (a.normalScale.y *= -1), a.clearcoatNormalScale && (a.clearcoatNormalScale.y *= -1)), this.cache.add(l, a), this.associations.set(a, this.associations.get(r))), r = a
            }
            r.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv), e.material = r
        }
        getMaterialType() {
            return H.MeshStandardMaterial
        }
        loadMaterial(e) {
            let t = this,
                r = this.json,
                i = this.extensions,
                s = r.materials[e],
                o, l = {},
                a = s.extensions || {},
                c = [];
            if (a[ot.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                let h = i[ot.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                o = h.getMaterialType(), c.push(h.extendParams(l, s, t))
            } else if (a[ot.KHR_MATERIALS_UNLIT]) {
                let h = i[ot.KHR_MATERIALS_UNLIT];
                o = h.getMaterialType(), c.push(h.extendParams(l, s, t))
            } else {
                let h = s.pbrMetallicRoughness || {};
                if (l.color = new H.Color(1, 1, 1), l.opacity = 1, Array.isArray(h.baseColorFactor)) {
                    let m = h.baseColorFactor;
                    l.color.fromArray(m), l.opacity = m[3]
                }
                h.baseColorTexture !== void 0 && c.push(t.assignTexture(l, "map", h.baseColorTexture)), l.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, l.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(l, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(l, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(m) {
                    return m.getMaterialType && m.getMaterialType(e)
                }), c.push(Promise.all(this._invokeAll(function(m) {
                    return m.extendMaterialParams && m.extendMaterialParams(e, l)
                })))
            }
            s.doubleSided === !0 && (l.side = H.DoubleSide);
            let f = s.alphaMode || $u.OPAQUE;
            return f === $u.BLEND ? (l.transparent = !0, l.depthWrite = !1) : (l.transparent = !1, f === $u.MASK && (l.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && o !== H.MeshBasicMaterial && (c.push(t.assignTexture(l, "normalMap", s.normalTexture)), l.normalScale = new H.Vector2(1, -1), s.normalTexture.scale !== void 0 && l.normalScale.set(s.normalTexture.scale, -s.normalTexture.scale)), s.occlusionTexture !== void 0 && o !== H.MeshBasicMaterial && (c.push(t.assignTexture(l, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (l.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== H.MeshBasicMaterial && (l.emissive = new H.Color().fromArray(s.emissiveFactor)), s.emissiveTexture !== void 0 && o !== H.MeshBasicMaterial && c.push(t.assignTexture(l, "emissiveMap", s.emissiveTexture)), Promise.all(c).then(function() {
                let h;
                return o === Rl ? h = i[ot.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(l) : h = new o(l), s.name && (h.name = s.name), h.map && (h.map.encoding = H.sRGBEncoding), h.emissiveMap && (h.emissiveMap.encoding = H.sRGBEncoding), Hn(h, s), t.associations.set(h, {
                    type: "materials",
                    index: e
                }), s.extensions && da(i, h, s), h
            })
        }
        createUniqueName(e) {
            let t = H.PropertyBinding.sanitizeNodeName(e || ""),
                r = t;
            for (let i = 1; this.nodeNamesUsed[r]; ++i) r = t + "_" + i;
            return this.nodeNamesUsed[r] = !0, r
        }
        loadGeometries(e) {
            let t = this,
                r = this.extensions,
                i = this.primitiveCache;

            function s(l) {
                return r[ot.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(l, t).then(function(a) {
                    return Ym(a, l, t)
                })
            }
            let o = [];
            for (let l = 0, a = e.length; l < a; l++) {
                let c = e[l],
                    f = vA(c),
                    h = i[f];
                if (h) o.push(h.promise);
                else {
                    let m;
                    c.extensions && c.extensions[ot.KHR_DRACO_MESH_COMPRESSION] ? m = s(c) : m = Ym(new H.BufferGeometry, c, t), i[f] = {
                        primitive: c,
                        promise: m
                    }, o.push(m)
                }
            }
            return Promise.all(o)
        }
        loadMesh(e) {
            let t = this,
                r = this.json,
                i = this.extensions,
                s = r.meshes[e],
                o = s.primitives,
                l = [];
            for (let a = 0, c = o.length; a < c; a++) {
                let f = o[a].material === void 0 ? mA(this.cache) : this.getDependency("material", o[a].material);
                l.push(f)
            }
            return l.push(t.loadGeometries(o)), Promise.all(l).then(function(a) {
                let c = a.slice(0, a.length - 1),
                    f = a[a.length - 1],
                    h = [];
                for (let v = 0, g = f.length; v < g; v++) {
                    let y = f[v],
                        A = o[v],
                        w, C = c[v];
                    if (A.mode === Hi.TRIANGLES || A.mode === Hi.TRIANGLE_STRIP || A.mode === Hi.TRIANGLE_FAN || A.mode === void 0) w = s.isSkinnedMesh === !0 ? new H.SkinnedMesh(y, C) : new H.Mesh(y, C), w.isSkinnedMesh === !0 && !w.geometry.attributes.skinWeight.normalized && w.normalizeSkinWeights(), A.mode === Hi.TRIANGLE_STRIP ? w.geometry = Km(w.geometry, H.TriangleStripDrawMode) : A.mode === Hi.TRIANGLE_FAN && (w.geometry = Km(w.geometry, H.TriangleFanDrawMode));
                    else if (A.mode === Hi.LINES) w = new H.LineSegments(y, C);
                    else if (A.mode === Hi.LINE_STRIP) w = new H.Line(y, C);
                    else if (A.mode === Hi.LINE_LOOP) w = new H.LineLoop(y, C);
                    else if (A.mode === Hi.POINTS) w = new H.Points(y, C);
                    else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + A.mode);
                    Object.keys(w.geometry.morphAttributes).length > 0 && gA(w, s), w.name = t.createUniqueName(s.name || "mesh_" + e), Hn(w, s), A.extensions && da(i, w, A), t.assignFinalMaterial(w), h.push(w)
                }
                if (h.length === 1) return h[0];
                let m = new H.Group;
                for (let v = 0, g = h.length; v < g; v++) m.add(h[v]);
                return m
            })
        }
        loadCamera(e) {
            let t, r = this.json.cameras[e],
                i = r[r.type];
            if (!i) {
                console.warn("THREE.GLTFLoader: Missing camera parameters.");
                return
            }
            return r.type === "perspective" ? t = new H.PerspectiveCamera(H.MathUtils.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : r.type === "orthographic" && (t = new H.OrthographicCamera(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), r.name && (t.name = this.createUniqueName(r.name)), Hn(t, r), Promise.resolve(t)
        }
        loadSkin(e) {
            let t = this.json.skins[e],
                r = {
                    joints: t.joints
                };
            return t.inverseBindMatrices === void 0 ? Promise.resolve(r) : this.getDependency("accessor", t.inverseBindMatrices).then(function(i) {
                return r.inverseBindMatrices = i, r
            })
        }
        loadAnimation(e) {
            let r = this.json.animations[e],
                i = [],
                s = [],
                o = [],
                l = [],
                a = [];
            for (let c = 0, f = r.channels.length; c < f; c++) {
                let h = r.channels[c],
                    m = r.samplers[h.sampler],
                    v = h.target,
                    g = v.node !== void 0 ? v.node : v.id,
                    y = r.parameters !== void 0 ? r.parameters[m.input] : m.input,
                    A = r.parameters !== void 0 ? r.parameters[m.output] : m.output;
                i.push(this.getDependency("node", g)), s.push(this.getDependency("accessor", y)), o.push(this.getDependency("accessor", A)), l.push(m), a.push(v)
            }
            return Promise.all([Promise.all(i), Promise.all(s), Promise.all(o), Promise.all(l), Promise.all(a)]).then(function(c) {
                let f = c[0],
                    h = c[1],
                    m = c[2],
                    v = c[3],
                    g = c[4],
                    y = [];
                for (let w = 0, C = f.length; w < C; w++) {
                    let S = f[w],
                        E = h[w],
                        M = m[w],
                        L = v[w],
                        I = g[w];
                    if (S === void 0) continue;
                    S.updateMatrix(), S.matrixAutoUpdate = !0;
                    let z;
                    switch (mn[I.path]) {
                        case mn.weights:
                            z = H.NumberKeyframeTrack;
                            break;
                        case mn.rotation:
                            z = H.QuaternionKeyframeTrack;
                            break;
                        case mn.position:
                        case mn.scale:
                        default:
                            z = H.VectorKeyframeTrack;
                            break
                    }
                    let O = S.name ? S.name : S.uuid,
                        X = L.interpolation !== void 0 ? hA[L.interpolation] : H.InterpolateLinear,
                        k = [];
                    mn[I.path] === mn.weights ? S.traverse(function(te) {
                        te.isMesh === !0 && te.morphTargetInfluences && k.push(te.name ? te.name : te.uuid)
                    }) : k.push(O);
                    let Q = M.array;
                    if (M.normalized) {
                        let te = ef(Q.constructor),
                            Z = new Float32Array(Q.length);
                        for (let le = 0, B = Q.length; le < B; le++) Z[le] = Q[le] * te;
                        Q = Z
                    }
                    for (let te = 0, Z = k.length; te < Z; te++) {
                        let le = new z(k[te] + "." + mn[I.path], E.array, Q, X);
                        L.interpolation === "CUBICSPLINE" && (le.createInterpolant = function(U) {
                            return new Vn(this.times, this.values, this.getValueSize() / 3, U)
                        }, le.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), y.push(le)
                    }
                }
                let A = r.name ? r.name : "animation_" + e;
                return new H.AnimationClip(A, void 0, y)
            })
        }
        createNodeMesh(e) {
            let t = this.json,
                r = this,
                i = t.nodes[e];
            return i.mesh === void 0 ? null : r.getDependency("mesh", i.mesh).then(function(s) {
                let o = r._getNodeRef(r.meshCache, i.mesh, s);
                return i.weights !== void 0 && o.traverse(function(l) {
                    if (!!l.isMesh)
                        for (let a = 0, c = i.weights.length; a < c; a++) l.morphTargetInfluences[a] = i.weights[a]
                }), o
            })
        }
        loadNode(e) {
            let t = this.json,
                r = this.extensions,
                i = this,
                s = t.nodes[e],
                o = s.name ? i.createUniqueName(s.name) : "";
            return function() {
                let l = [],
                    a = i._invokeOne(function(c) {
                        return c.createNodeMesh && c.createNodeMesh(e)
                    });
                return a && l.push(a), s.camera !== void 0 && l.push(i.getDependency("camera", s.camera).then(function(c) {
                    return i._getNodeRef(i.cameraCache, s.camera, c)
                })), i._invokeAll(function(c) {
                    return c.createNodeAttachment && c.createNodeAttachment(e)
                }).forEach(function(c) {
                    l.push(c)
                }), Promise.all(l)
            }().then(function(l) {
                let a;
                if (s.isBone === !0 ? a = new H.Bone : l.length > 1 ? a = new H.Group : l.length === 1 ? a = l[0] : a = new H.Object3D, a !== l[0])
                    for (let c = 0, f = l.length; c < f; c++) a.add(l[c]);
                if (s.name && (a.userData.name = s.name, a.name = o), Hn(a, s), s.extensions && da(r, a, s), s.matrix !== void 0) {
                    let c = new H.Matrix4;
                    c.fromArray(s.matrix), a.applyMatrix4(c)
                } else s.translation !== void 0 && a.position.fromArray(s.translation), s.rotation !== void 0 && a.quaternion.fromArray(s.rotation), s.scale !== void 0 && a.scale.fromArray(s.scale);
                return i.associations.set(a, {
                    type: "nodes",
                    index: e
                }), a
            })
        }
        loadScene(e) {
            let t = this.json,
                r = this.extensions,
                i = this.json.scenes[e],
                s = this,
                o = new H.Group;
            i.name && (o.name = s.createUniqueName(i.name)), Hn(o, i), i.extensions && da(r, o, i);
            let l = i.nodes || [],
                a = [];
            for (let c = 0, f = l.length; c < f; c++) a.push(Qm(l[c], o, t, s));
            return Promise.all(a).then(function() {
                return o
            })
        }
    };

    function Qm(n, e, t, r) {
        let i = t.nodes[n];
        return r.getDependency("node", n).then(function(s) {
            if (i.skin === void 0) return s;
            let o;
            return r.getDependency("skin", i.skin).then(function(l) {
                o = l;
                let a = [];
                for (let c = 0, f = o.joints.length; c < f; c++) a.push(r.getDependency("node", o.joints[c]));
                return Promise.all(a)
            }).then(function(l) {
                return s.traverse(function(a) {
                    if (!a.isMesh) return;
                    let c = [],
                        f = [];
                    for (let h = 0, m = l.length; h < m; h++) {
                        let v = l[h];
                        if (v) {
                            c.push(v);
                            let g = new H.Matrix4;
                            o.inverseBindMatrices !== void 0 && g.fromArray(o.inverseBindMatrices.array, h * 16), f.push(g)
                        } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', o.joints[h])
                    }
                    a.bind(new H.Skeleton(c, f), a.matrixWorld)
                }), s
            })
        }).then(function(s) {
            e.add(s);
            let o = [];
            if (i.children) {
                let l = i.children;
                for (let a = 0, c = l.length; a < c; a++) {
                    let f = l[a];
                    o.push(Qm(f, s, t, r))
                }
            }
            return Promise.all(o)
        })
    }

    function yA(n, e, t) {
        let r = e.attributes,
            i = new H.Box3;
        if (r.POSITION !== void 0) {
            let l = t.json.accessors[r.POSITION],
                a = l.min,
                c = l.max;
            if (a !== void 0 && c !== void 0) {
                if (i.set(new H.Vector3(a[0], a[1], a[2]), new H.Vector3(c[0], c[1], c[2])), l.normalized) {
                    let f = ef(fa[l.componentType]);
                    i.min.multiplyScalar(f), i.max.multiplyScalar(f)
                }
            } else {
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                return
            }
        } else return;
        let s = e.targets;
        if (s !== void 0) {
            let l = new H.Vector3,
                a = new H.Vector3;
            for (let c = 0, f = s.length; c < f; c++) {
                let h = s[c];
                if (h.POSITION !== void 0) {
                    let m = t.json.accessors[h.POSITION],
                        v = m.min,
                        g = m.max;
                    if (v !== void 0 && g !== void 0) {
                        if (a.setX(Math.max(Math.abs(v[0]), Math.abs(g[0]))), a.setY(Math.max(Math.abs(v[1]), Math.abs(g[1]))), a.setZ(Math.max(Math.abs(v[2]), Math.abs(g[2]))), m.normalized) {
                            let y = ef(fa[m.componentType]);
                            a.multiplyScalar(y)
                        }
                        l.max(a)
                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                }
            }
            i.expandByVector(l)
        }
        n.boundingBox = i;
        let o = new H.Sphere;
        i.getCenter(o.center), o.radius = i.min.distanceTo(i.max) / 2, n.boundingSphere = o
    }

    function Ym(n, e, t) {
        let r = e.attributes,
            i = [];

        function s(o, l) {
            return t.getDependency("accessor", o).then(function(a) {
                n.setAttribute(l, a)
            })
        }
        for (let o in r) {
            let l = Zu[o] || o.toLowerCase();
            l in n.attributes || i.push(s(r[o], l))
        }
        if (e.indices !== void 0 && !n.index) {
            let o = t.getDependency("accessor", e.indices).then(function(l) {
                n.setIndex(l)
            });
            i.push(o)
        }
        return Hn(n, e), yA(n, e, t), Promise.all(i).then(function() {
            return e.targets !== void 0 ? pA(n, e.targets, t) : n
        })
    }

    function Km(n, e) {
        let t = n.getIndex();
        if (t === null) {
            let o = [],
                l = n.getAttribute("position");
            if (l !== void 0) {
                for (let a = 0; a < l.count; a++) o.push(a);
                n.setIndex(o), t = n.getIndex()
            } else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n
        }
        let r = t.count - 2,
            i = [];
        if (e === H.TriangleFanDrawMode)
            for (let o = 1; o <= r; o++) i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
        else
            for (let o = 0; o < r; o++) o % 2 == 0 ? (i.push(t.getX(o)), i.push(t.getX(o + 1)), i.push(t.getX(o + 2))) : (i.push(t.getX(o + 2)), i.push(t.getX(o + 1)), i.push(t.getX(o)));
        i.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        let s = n.clone();
        return s.setIndex(i), s
    }
    var Tr = W(J()),
        Pt = class extends Tr.Mesh {
            constructor({
                char: e,
                originalChar: t,
                fontFamily: r,
                letterSpacing: i,
                fontSize: s,
                LOD: o = 16
            }, l = new Tr.MeshBasicMaterial({
                color: 0,
                opacity: 1,
                visible: !0,
                transparent: !0,
                side: Tr.DoubleSide
            })) {
                let a = Pt.loadChar(e, r, o);
                super(a.geometry, l);
                this.char = e, this.originalChar = t ?? e, this.fontFamily = r, this.letterSpacing = i, this.fontSize = s, this.LOD = o, this.resolution = a.resolution, this.glyphsHa = a.glyphsHa, this.localPosition = new Tr.Vector2, this.charSize = 0, this.geometry.userData = {
                    type: "CharacterGeometry",
                    parameters: {
                        char: this.char,
                        fontFamily: this.fontFamily,
                        letterSpacing: this.letterSpacing,
                        fontSize: this.fontSize,
                        lod: this.LOD,
                        resolution: this.resolution,
                        charSize: this.charSize,
                        localPosition: this.localPosition
                    }
                }, this.updateFontSize(this.fontSize)
            }
            static get FONTS_PATH() {
                return Pt._fontPath
            }
            static set FONTS_PATH(e) {
                Pt._fontPath = e
            }
            updatePosition(e, t) {
                this.localPosition.copy(e);
                let r = new Tr.Vector3(this.localPosition.x, -this.localPosition.y, 0);
                this.position.copy(r).add(t)
            }
            updateFontSize(e) {
                let t = e / this.resolution;
                this.fontSize = e, this.scale.set(this.fontSize, this.fontSize, 1), this.charSize = this.glyphsHa * t * this.letterSpacing
            }
            updateFontFamily(e) {
                if (this.fontFamily === e) return;
                this.fontFamily = e;
                let t = Pt.loadChar(this.char, e, this.LOD);
                this.geometry = t.geometry, this.resolution = t.resolution, this.glyphsHa = t.glyphsHa, this.geometry.userData = {
                    type: "CharacterGeometry",
                    parameters: {
                        char: this.char,
                        fontFamily: this.fontFamily,
                        letterSpacing: this.letterSpacing,
                        fontSize: this.fontSize,
                        lod: this.LOD,
                        resolution: this.resolution,
                        charSize: this.charSize,
                        localPosition: this.localPosition
                    }
                }, this.updateFontSize(this.fontSize)
            }
            updateChar(e) {
                if (this.char === e) return;
                this.char = e;
                let t = Pt.loadChar(e, this.fontFamily, this.LOD);
                this.geometry = t.geometry, this.resolution = t.resolution, this.glyphsHa = t.glyphsHa, this.geometry.userData = {
                    type: "CharacterGeometry",
                    parameters: {
                        char: this.char,
                        fontFamily: this.fontFamily,
                        letterSpacing: this.letterSpacing,
                        fontSize: this.fontSize,
                        lod: this.LOD,
                        resolution: this.resolution,
                        charSize: this.charSize,
                        localPosition: this.localPosition
                    }
                }, this.updateFontSize(this.fontSize)
            }
            updateLetterSpacing(e) {
                this.letterSpacing !== e && (this.letterSpacing = e, this.updateFontSize(this.fontSize))
            }
            updateLOD(e) {
                if (this.LOD === e) return;
                this.LOD = e;
                let t = Pt.loadChar(this.char, this.fontFamily, this.LOD);
                this.geometry = t.geometry, this.resolution = t.resolution, this.glyphsHa = t.glyphsHa, this.geometry.userData = {
                    type: "CharacterGeometry",
                    parameters: {
                        char: this.char,
                        fontFamily: this.fontFamily,
                        letterSpacing: this.letterSpacing,
                        fontSize: this.fontSize,
                        lod: this.LOD,
                        resolution: this.resolution,
                        charSize: this.charSize,
                        localPosition: this.localPosition
                    }
                }, this.updateFontSize(this.fontSize)
            }
            clone() {
                let e = {
                    char: this.char,
                    originalChar: this.originalChar,
                    fontFamily: this.fontFamily,
                    letterSpacing: this.letterSpacing,
                    fontSize: this.fontSize,
                    LOD: this.LOD
                };
                return new Pt(e).copy(this)
            }
            static loadFont(e) {
                return new Promise(function(t, r) {
                    Pt.fontCache[e] ? t(Pt.fontCache[e]) : new Tr.FontLoader().load(Pt.FONTS_PATH + e + ".json", s => {
                        Pt.fontCache[e] = s, t(s)
                    }, void 0, r)
                })
            }
            static loadChar(e, t, r) {
                if (Pt.charCache[e]) {
                    if (Pt.charCache[e][r] && Pt.charCache[e][r].fontFamily === t) return Pt.charCache[e][r]
                } else Pt.charCache[e] = {};
                let i = Pt.fontCache[t],
                    s = i.generateShapes(e, 1);
                return Pt.charCache[e][r] = {
                    geometry: new Tr.ShapeBufferGeometry(s, r),
                    fontFamily: t,
                    resolution: i.data.resolution,
                    glyphsHa: i.data.glyphs[e].ha
                }, Pt.charCache[e][r]
            }
        },
        Vr = Pt;
    Vr.charCache = {}, Vr.fontCache = {}, Vr._fontPath = "/_assets/_fonts/";
    var Wi = W(J());
    var tf = W(J());
    var Wn;
    (function(r) {
        r[r.STANDARD = 1] = "STANDARD", r[r.UPPERCASE = 2] = "UPPERCASE", r[r.LOWERCASE = 3] = "LOWERCASE"
    })(Wn || (Wn = {}));
    var pn;
    (function(r) {
        r[r.TOP = 1] = "TOP", r[r.MIDDLE = 2] = "MIDDLE", r[r.BOTTOM = 3] = "BOTTOM"
    })(pn || (pn = {}));
    var Er;
    (function(i) {
        i[i.LEFT = 1] = "LEFT", i[i.RIGHT = 2] = "RIGHT", i[i.CENTER = 3] = "CENTER", i[i.JUSTIFY = 4] = "JUSTIFY"
    })(Er || (Er = {}));
    var Jn;
    (function(t) {
        t[t.TO_RIGHT = 1] = "TO_RIGHT", t[t.TO_LEFT = -1] = "TO_LEFT"
    })(Jn || (Jn = {}));
    var Fl = new tf.Vector2,
        Hs = class {
            constructor(e, t, r) {
                this.message = [];
                this.endLine = !0;
                this.yLinePos = e, this.lineHeight = t, this.maxCharSize = r, this.nextChar3DPos = new tf.Vector2(0, this.yLinePos + this.maxCharSize * this.lineHeight), this.align = Er.LEFT
            }
            addChar3D(e, t, r = this.message.length) {
                this.message.splice(r, 0, e), e.fontSize > this.maxCharSize ? (this.maxCharSize = e.fontSize, this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight, this.fullUpdate(t)) : (e.updatePosition(this.nextChar3DPos, t), this.nextChar3DPos.x += e.charSize)
            }
            deleteChar3D(e = this.message.length - 1) {
                let t = this.message[e];
                if (t) return this.message.splice(e, 1), this.nextChar3DPos.x -= t.charSize, t
            }
            isEndLine(e) {
                this.endLine = e
            }
            fullUpdate(e, t = 0) {
                this.nextChar3DPos.x = 0;
                for (let r = t, i = this.message.length; r < i; r += 1) this.message[r].updatePosition(this.nextChar3DPos, e), this.nextChar3DPos.x += this.message[r].charSize
            }
            checkOverFlow(e) {
                let t, r = this.message.length - 1;
                if (r <= 0) return !1;
                for (; r >= 0;) {
                    if (this.message[r].char !== " ") {
                        t = this.message[r];
                        break
                    }
                    r -= 1
                }
                return !!(r >= 0 && t && t.localPosition.x + t.charSize > e)
            }
            containSpaceOverFlow(e = this.message.length - 1) {
                for (let t = e; t >= 0; t -= 1)
                    if (this.message[t].char === " ") return !0;
                return !1
            }
            containSpace(e = this.message.length - 1) {
                if (this.endLine) return !0;
                for (let t = e; t >= 0; t -= 1)
                    if (this.message[t].char === " ") return !0;
                return !1
            }
            popWord(e = this.message.length - 1) {
                let t = [],
                    r = !0,
                    i;
                for (i = e; i >= 0; i -= 1)
                    if (this.message[i].char === " ") {
                        r = !1, t.length === 0 && (i -= 1, t.splice(0, 0, this.message[i]));
                        break
                    } else t.splice(0, 0, this.message[i]);
                return r ? t = [] : this.message.splice(i + 1, t.length), t
            }
            getWord(e = 0, t = 1) {
                let r = [],
                    i = e;
                for (i = e;; i += t) {
                    if (!this.message[i] || this.message[i].char === " ") {
                        r.length === 0 && this.message[i] && (r.push(this.message[i]), this.message.splice(i, 1));
                        break
                    }
                    t > 0 ? (r.push(this.message[i]), this.message.splice(i, 1), i -= t) : (r.splice(0, 0, this.message[i]), this.message.splice(i, 1))
                }
                return r
            }
            getWordAtIndex(e) {
                let t = [];
                for (let r = e; r < this.message.length && this.message[r].char !== " "; r++) t.push(this.message[r]);
                for (let r = e - 1; r >= 0 && this.message[r].char !== " "; r--) t.splice(0, 0, this.message[r]);
                return t
            }
            wordSize(e = 0, t = -1) {
                let r = 0,
                    i = e;
                for (; i >= 0 && i < this.message.length;) {
                    if (this.message[i].char === " ") {
                        r === 0 && (r = this.message[i].charSize);
                        break
                    }
                    r += this.message[i].charSize, i += t
                }
                return (i < 0 || i >= this.message.length) && !this.endLine ? this.message[e] ? this.message[e].charSize : 999999999 : r === 0 ? 999999999 : r
            }
            spaceLeft(e) {
                return e - this.nextChar3DPos.x
            }
            popChar(e = this.message.length - 1) {
                return this.nextChar3DPos.x -= this.message[e].charSize, this.message.splice(e, 1)
            }
            isEmpty() {
                return !this.message.length
            }
            updateNextCharPosY() {
                this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight
            }
            updateYLinePos(e) {
                this.yLinePos = e, this.updateNextCharPosY()
            }
            updatelineHeight(e) {
                this.lineHeight = e, this.updateNextCharPosY()
            }
            updateFontSize(e, t = 0, r = this.message.length - 1) {
                for (let i = t; i <= r; i += 1) this.message[i].updateFontSize(e);
                this.maxCharSize = e, this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight
            }
            countSpaces() {
                let e = 0;
                for (let t = 0; t < this.message.length; t++) this.message[t].char === " " && (e += 1);
                return e
            }
            alignText(e, t, r, i, s) {
                switch (r) {
                    case Er.LEFT:
                        this.leftAlign(e, s);
                        break;
                    case Er.CENTER:
                        this.centerAlign(this.spaceLeft(t), e, s);
                        break;
                    case Er.RIGHT:
                        this.rightAlign(this.spaceLeft(t), e, s);
                        break;
                    case Er.JUSTIFY:
                        this.justifyAlign(this.spaceLeft(t), e, s);
                        break
                }
            }
            offsetCharacters(e, t, r) {
                Fl.set(t, r);
                let i = this.message.length;
                for (let s = 0; s < i; s++) this.message[s].updatePosition(this.message[s].localPosition.add(Fl), e)
            }
            leftAlign(e, t) {
                this.align = Er.LEFT, this.offsetCharacters(e, 0, t)
            }
            centerAlign(e, t, r) {
                this.align = Er.CENTER, this.offsetCharacters(t, e / 2, r)
            }
            rightAlign(e, t, r) {
                this.align = Er.RIGHT, this.offsetCharacters(t, e, r)
            }
            justifyAlign(e, t, r) {
                if (this.align = Er.JUSTIFY, this.endLine) {
                    this.offsetCharacters(t, 0, r);
                    return
                }
                let i = this.countSpaces();
                if (i === 0) {
                    this.offsetCharacters(t, 0, r);
                    return
                }
                let s = e / i,
                    o = 0;
                for (let l = 0; l < this.message.length; l++) this.message[l].char === " " && (o += s), Fl.set(o, r), this.message[l].updatePosition(this.message[l].localPosition.add(Fl), t)
            }
            clone() {
                let e = new Hs(this.yLinePos, this.lineHeight, this.maxCharSize);
                e.nextChar3DPos = this.nextChar3DPos.clone(), e.align = this.align, e.endLine = this.endLine;
                for (let t = 0; t < this.message.length; t++) e.message.push(this.message[t].clone());
                return e
            }
        };
    var Qn = class extends Nr {
        constructor(e, t = new Pr({
            transparent: !0,
            opacity: 1,
            visible: !1,
            side: Wi.DoubleSide
        })) {
            super(e, t);
            this.objectType = "TextFrame";
            this.material.visible = !1, this._geometryUserData = e.userData, this.userData.textFrame = {
                hexColor: 6974058,
                opacity: 1,
                visible: !0,
                fontSize: 16,
                lineHeight: 1.5,
                letterSpacing: 1,
                fontFamily: "roboto_regular",
                textTransform: Wn.STANDARD,
                horizontalAlignment: 1,
                verticalAlignment: pn.TOP,
                LOD: 16,
                maxLineSize: this._geometryUserData.parameters.width,
                textOrigin: new Wi.Vector3(this._geometryUserData.parameters.width * -.5, this._geometryUserData.parameters.height * .5, 0),
                textLines: []
            }, this.createTextLine()
        }
        raycast(e, t) {
            let r = [];
            if (super.raycast(e, r), r.length > 0) {
                t.push(r[0]);
                return
            }
            let i = [];
            for (let s = 0, o = this.children.length; s < o; ++s)
                if (this.children[s] instanceof Vr && (e.intersectObject(this.children[s], !1, i), i.length > 0)) {
                    i[0].object = this, t.push(i[0]);
                    return
                }
        }
        updateGeometry(e) {
            let t = this.userData,
                r = this.geometry.userData,
                i = r.parameters.width,
                s = e.parameters?.width,
                o = e.parameters?.height,
                l = r.parameters.height,
                a = t.textFrame;
            super.updateGeometry(e), a.maxLineSize = r.parameters.width, a.textOrigin.set(r.parameters.width * -.5, r.parameters.height * .5, 0), o !== void 0 && l !== o ? (this.checkOverFlow(), this.checkCapacity()) : s !== void 0 && (i < s ? this.checkCapacity() : i > s && this.checkOverFlow())
        }
        checkOverFlow(e = 0) {
            let t = this.userData,
                r = t.textFrame.textOrigin,
                i = t.textFrame.textLines;
            for (let s = e; s < i.length; s++) {
                i[s].updateYLinePos(this.getNewLinePosition(s)), i[s].fullUpdate(r);
                let o = [];
                for (; i[s].checkOverFlow(t.textFrame.maxLineSize);) i[s].containSpaceOverFlow() ? o.splice(0, 0, i[s].getWord(i[s].message.length - 1, Jn.TO_LEFT)) : o.splice(0, 0, i[s].popChar());
                if (o.length > 0) {
                    i[s + 1] === void 0 && (i[s].isEndLine(!1), this.createTextLine());
                    let l = 0;
                    for (let a = 0; a < o.length; a += 1)
                        for (let c = 0; c < o[a].length; c += 1) i[s + 1].addChar3D(o[a][c], r, l), l += 1;
                    i[s + 1].fullUpdate(r)
                }
                i[s].fullUpdate(r)
            }
            this.textFullUpdate(e)
        }
        checkCapacity(e = 0) {
            let t = this.userData,
                r = t.textFrame.textOrigin,
                i = t.textFrame.maxLineSize,
                s = t.textFrame.textLines;
            for (let o = e; o < s.length; o += 1)
                if (s[o].updateYLinePos(this.getNewLinePosition(o)), s[o].fullUpdate(r), !!s[o - 1])
                    for (; !s[o - 1].endLine;) {
                        let l, a = s[o - 1].spaceLeft(i);
                        if (s[o].wordSize(0, Jn.TO_RIGHT) <= a) {
                            s[o].containSpace() ? l = s[o].getWord(0, Jn.TO_RIGHT) : l = s[o].popChar(0);
                            for (let c = 0; c < l.length; c += 1) l[c] && s[o - 1].addChar3D(l[c], r)
                        } else {
                            s[o].isEmpty() ? (s[o].endLine && s[o - 1].isEndLine(!0), s.splice(o, 1), o -= 1) : (s[o].updateYLinePos(this.getNewLinePosition(o)), s[o].fullUpdate(r));
                            break
                        }
                    }
            this.textFullUpdate(e)
        }
        createTextLine(e = this.userData.textFrame.textLines.length) {
            let r = this.userData.textFrame;
            r.textLines.splice(e, 0, new Hs(this.getNewLinePosition(e), r.lineHeight, r.fontSize))
        }
        textFullUpdate(e = 0) {
            let r = this.userData.textFrame,
                i = r.textLines,
                s = this.getVerticalAlignmentOffSet();
            for (let o = e; o < i.length; o++) i[o].updateYLinePos(this.getNewLinePosition(o)), i[o].fullUpdate(r.textOrigin), i[o].alignText(r.textOrigin, r.maxLineSize, r.horizontalAlignment, r.verticalAlignment, s)
        }
        getVerticalAlignmentOffSet() {
            switch (this.userData.textFrame.verticalAlignment) {
                case pn.TOP:
                    return 0;
                case pn.MIDDLE:
                    return this.getRemainingVerticalSpace() / 2;
                case pn.BOTTOM:
                    return this.getRemainingVerticalSpace();
                default:
                    return 0
            }
        }
        getRemainingVerticalSpace() {
            let t = this.userData.textFrame.textLines;
            return this.geometry.userData.parameters.height - this.getNewLinePosition(t.length)
        }
        getNewLinePosition(e) {
            let r = this.userData.textFrame.textLines,
                i = 0;
            for (let s = 0; s < e; s += 1) i += r[s].maxCharSize * r[s].lineHeight;
            return i
        }
        updateColor(e) {
            let t = this.userData;
            t.textFrame.hexColor = e;
            let r = t.textFrame.textLines;
            for (let i = 0; i < r.length; i++) {
                let s = r[i].message;
                for (let o = 0; o < s.length; o++) {
                    let l = s[o].material;
                    l.color?.isColor && l.color.setHex(e)
                }
            }
        }
        updateOpacity(e) {
            let t = this.userData;
            t.textFrame.opacity = e;
            let r = t.textFrame.textLines;
            for (let i = 0; i < r.length; i++) {
                let s = r[i].message;
                for (let o = 0; o < s.length; o++) {
                    let l = s[o].material;
                    l.opacity = e
                }
            }
        }
        updateVisible(e) {
            let t = this.userData;
            t.textFrame.visible = e;
            let r = t.textFrame.textLines;
            for (let i = 0; i < r.length; i++) {
                let s = r[i].message;
                for (let o = 0; o < s.length; o++) {
                    let l = s[o].material;
                    l.visible = e
                }
            }
        }
        async updateFontFamily(e) {
            await Vr.loadFont(e);
            let r = this.userData.textFrame,
                i = r.textLines;
            r.fontFamily = e;
            for (let s = 0; s < i.length; s++) {
                let o = i[s].message;
                for (let l = 0; l < o.length; l++) o[l].updateFontFamily(e)
            }
            this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity()
        }
        updateFontSize(e) {
            let r = this.userData.textFrame,
                i = r.textLines,
                s = r.fontSize;
            r.fontSize = e;
            for (let o = 0; o < i.length; o++) i[o].updateFontSize(e);
            this.textFullUpdate(), e > s ? this.checkOverFlow() : e < s && this.checkCapacity()
        }
        async updateTextTransform(e) {
            let r = this.userData.textFrame;
            await Vr.loadFont(r.fontFamily);
            let i = r.textLines;
            switch (r.textTransform = e, e) {
                case Wn.UPPERCASE:
                    for (let s = 0; s < i.length; s++) {
                        let o = i[s].message;
                        for (let l = 0; l < o.length; l++) i[s].message[l].updateChar(o[l].char.toUpperCase())
                    }
                    break;
                case Wn.LOWERCASE:
                    for (let s = 0; s < i.length; s++) {
                        let o = i[s].message;
                        for (let l = 0; l < o.length; l++) i[s].message[l].updateChar(o[l].char.toLowerCase())
                    }
                    break;
                default:
                    for (let s = 0; s < i.length; s++) {
                        let o = i[s].message;
                        for (let l = 0; l < o.length; l++) i[s].message[l].updateChar(o[l].originalChar)
                    }
            }
            this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity()
        }
        updateLetterSpacing(e) {
            let t = this.userData,
                r = t.textFrame.textLines;
            t.textFrame.letterSpacing = e;
            for (let i = 0; i < r.length; i++) {
                let s = r[i].message;
                for (let o = 0; o < s.length; o++) s[o].updateLetterSpacing(e)
            }
            this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity()
        }
        updateLOD(e) {
            let t = this.userData;
            t.textFrame.LOD = e;
            let r = t.textFrame.textLines;
            for (let i = 0; i < r.length; i++);
            this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity()
        }
        updateLineHeight(e) {
            let t = this.userData,
                r = t.textFrame.textLines;
            t.textFrame.lineHeight = e;
            for (let i = 0; i < r.length; i++) r[i].updatelineHeight(e);
            this.textFullUpdate()
        }
        updateVerticalAlignment(e) {
            let t = this.userData;
            t.textFrame.verticalAlignment = e, this.textFullUpdate()
        }
        updateHorizontalAlignment(e) {
            let t = this.userData;
            t.textFrame.horizontalAlignment = e, this.textFullUpdate()
        }
        copy(e, t) {
            super.copy(e, t);
            let r = this.userData,
                i = e.userData,
                s = this.geometry.userData;
            r.textFrame.textOrigin = new Wi.Vector3(s.parameters.width * -.5, s.parameters.height * .5, 0);
            let o = i.textFrame.textLines;
            r.textFrame.textLines = [];
            for (let l = 0; l < o.length; l++) {
                let a = o[l].clone(),
                    c = a.message;
                r.textFrame.textLines.push(a);
                for (let f = 0; f < c.length; f++) this.add(c[f])
            }
            return this.textFullUpdate(), this.updateColor(i.textFrame.hexColor), this
        }
        toJSON(e) {
            let t = super.toJSON(e),
                r = t.object;
            r.objectType = "TextFrame";
            let s = this.userData.textFrame.textLines.map(o => {
                let l = o.message.map(a => ({
                    char: a.char,
                    originalChar: a.originalChar,
                    fontFamily: a.fontFamily,
                    letterSpacing: a.letterSpacing,
                    fontSize: a.fontSize,
                    LOD: a.LOD
                }));
                return {
                    align: o.align,
                    endLine: o.endLine,
                    lineHeight: o.lineHeight,
                    maxCharSize: o.maxCharSize,
                    yLinePos: o.yLinePos,
                    message: l
                }
            });
            return r.userData.textFrame.textLinesData = s, t
        }
        async fromJSONasync(e) {
            if (super.fromJSON(e), e.userData !== void 0) {
                let t = e.userData.textFrame;
                await Vr.loadFont(t.fontFamily), t.textOrigin = new Wi.Vector3(t.textOrigin.x, t.textOrigin.y, t.textOrigin.z);
                let r = new Wi.MeshBasicMaterial({
                    color: t.hexColor,
                    opacity: t.opacity,
                    visible: t.visible,
                    transparent: !0,
                    side: Wi.DoubleSide
                });
                t.textLinesData && (t.textLines = t.textLinesData.map((i, s) => {
                    let o = new Hs(Number(i.yLinePos), Number(i.lineHeight), Number(i.maxCharSize)),
                        l = i.message.map((a, c) => {
                            if (a.char === void 0) {
                                let m = t.textLines[s].message[c];
                                if ("geometries" in m) {
                                    let v = m.geometries[0].userData.parameters;
                                    Object.assign(a, {
                                        LOD: v.lod,
                                        char: v.char,
                                        fontFamily: v.fontFamily,
                                        fontSize: v.fontSize,
                                        letterSpacing: v.letterSpacing,
                                        originalChar: v.char
                                    })
                                }
                            }
                            let f = {
                                    char: a.char,
                                    fontFamily: a.fontFamily,
                                    letterSpacing: Number(a.letterSpacing),
                                    fontSize: Number(a.fontSize),
                                    LOD: a.LOD
                                },
                                h = new Vr(f, r.clone());
                            return o.addChar3D(h, t.textOrigin), this.add(h), h
                        });
                    return o.message = l, o
                }), this.userData.textFrame = t), this.textFullUpdate()
            }
            return this
        }
    };
    Qn.VERTICAL_ALIGN = pn, Qn.HORIZONTAL_ALIGN = Er, Qn.TEXT_TRANSFORM = Wn, Qn.TRAVEL_DIRECTION = Jn;
    var Jt = W(J());
    var gt = W(J()),
        Gl = W(J()),
        rf = W(J()),
        nr = W(J()),
        Hr = W(J()),
        kl = W(J()),
        Mr = W(J()),
        Yn = W(J()),
        jl = W(J()),
        Vl = W(J()),
        Hl = W(J()),
        ni = W(J()),
        si = W(J()),
        Xt = W(J()),
        nf = W(J()),
        oi = W(J()),
        Ii = W(J()),
        Jl = W(J()),
        Or = W(J()),
        Ws = W(J()),
        ur = W(J()),
        Di = W(J()),
        ai = W(J()),
        sf = W(J()),
        ip = W(J()),
        li = W(J()),
        Wr = W(J()),
        Yl = W(J()),
        sp = W(J()),
        Js = W(J()),
        Kl = W(J()),
        Xl = W(J()),
        ql = W(J()),
        ui = W(J()),
        ma = W(J()),
        ap = W(J()),
        Jr = W(J()),
        db = W(J()),
        ff = W(J()),
        pb = W(J()),
        $l = W(J()),
        qt = W(J()),
        mp = W(J()),
        xb = W(J()),
        pa = W(J()),
        Kn = W(J()),
        Ir = W(J()),
        pp = W(J()),
        ga = W(J()),
        Yi = W(J()),
        Rr = W(J()),
        Xn = W(J()),
        Qs = W(J()),
        xp = W(J()),
        Ap = W(J()),
        va = W(J()),
        Ki = W(J()),
        Sb = W(J()),
        Nt = W(J()),
        Zn = W(J()),
        ya = W(J()),
        Ys = W(J()),
        df = W(J()),
        Eb = W(J()),
        ec = W(J()),
        xa = W(J()),
        tc = W(J());
    var Xm = {
        RED: 0,
        GREEN: 1,
        BLUE: 2,
        ALPHA: 3
    };
    var ha = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
    var xA = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`,
        zl = class extends nr.ShaderMaterial {
            constructor(n = !1, e = !1) {
                super({
                    type: "BokehMaterial",
                    defines: {
                        PASS: n ? "2" : "1"
                    },
                    uniforms: {
                        kernel64: new nr.Uniform(null),
                        kernel16: new nr.Uniform(null),
                        inputBuffer: new nr.Uniform(null),
                        cocBuffer: new nr.Uniform(null),
                        texelSize: new nr.Uniform(new nr.Vector2),
                        scale: new nr.Uniform(1)
                    },
                    fragmentShader: xA,
                    vertexShader: ha,
                    blending: nr.NoBlending,
                    depthWrite: !1,
                    depthTest: !1
                });
                this.toneMapped = !1, e && (this.defines.FOREGROUND = "1"), this.generateKernel()
            }
            generateKernel() {
                let n = 2.39996323,
                    e = new Float32Array(128),
                    t = new Float32Array(32),
                    r = 0,
                    i = 0;
                for (let l = 0; l < 80; ++l) {
                    let a = l * n,
                        c = Math.sqrt(l) / Math.sqrt(80),
                        f = c * Math.cos(a),
                        h = c * Math.sin(a);
                    l % 5 == 0 ? (t[i++] = f, t[i++] = h) : (e[r++] = f, e[r++] = h)
                }
                let s = [],
                    o = [];
                for (let l = 0; l < 128;) s.push(new nr.Vector4(e[l++], e[l++], e[l++], e[l++]));
                for (let l = 0; l < 32;) o.push(new nr.Vector4(t[l++], t[l++], t[l++], t[l++]));
                this.uniforms.kernel64.value = s, this.uniforms.kernel16.value = o
            }
            setTexelSize(n, e) {
                this.uniforms.texelSize.value.set(n, e)
            }
        },
        AA = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focalLength;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focalLength,abs(signedDistance));gl_FragColor.rg=vec2(step(signedDistance,0.0)*magnitude,step(0.0,signedDistance)*magnitude);}`,
        bA = class extends Hr.ShaderMaterial {
            constructor(n) {
                super({
                    type: "CircleOfConfusionMaterial",
                    defines: {
                        DEPTH_PACKING: "0"
                    },
                    uniforms: {
                        depthBuffer: new Hr.Uniform(null),
                        focusDistance: new Hr.Uniform(0),
                        focalLength: new Hr.Uniform(0),
                        cameraNear: new Hr.Uniform(.3),
                        cameraFar: new Hr.Uniform(1e3)
                    },
                    fragmentShader: AA,
                    vertexShader: ha,
                    blending: Hr.NoBlending,
                    depthWrite: !1,
                    depthTest: !1
                });
                this.toneMapped = !1, this.adoptCameraSettings(n)
            }
            get depthPacking() {
                return Number(this.defines.DEPTH_PACKING)
            }
            set depthPacking(n) {
                this.defines.DEPTH_PACKING = n.toFixed(0), this.needsUpdate = !0
            }
            adoptCameraSettings(n = null) {
                n !== null && (this.uniforms.cameraNear.value = n.near, this.uniforms.cameraFar.value = n.far, n instanceof Hr.PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
            }
        },
        wA = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=linearToRelativeLuminance(texture2D(inputBuffer,vUv).rgb);float lLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv0).rgb);float lTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=linearToRelativeLuminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=linearToRelativeLuminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`,
        SA = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`;
    var NA = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <dithering_fragment>
}`,
        CA = "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",
        qm = class extends Mr.ShaderMaterial {
            constructor(n = new Mr.Vector2) {
                super({
                    type: "ConvolutionMaterial",
                    uniforms: {
                        inputBuffer: new Mr.Uniform(null),
                        texelSize: new Mr.Uniform(new Mr.Vector2),
                        halfTexelSize: new Mr.Uniform(new Mr.Vector2),
                        kernel: new Mr.Uniform(0),
                        scale: new Mr.Uniform(1)
                    },
                    fragmentShader: NA,
                    vertexShader: CA,
                    blending: Mr.NoBlending,
                    depthWrite: !1,
                    depthTest: !1
                });
                this.toneMapped = !1, this.setTexelSize(n.x, n.y), this.kernelSize = Ul.LARGE
            }
            getKernel() {
                return TA[this.kernelSize]
            }
            setTexelSize(n, e) {
                this.uniforms.texelSize.value.set(n, e), this.uniforms.halfTexelSize.value.set(n, e).multiplyScalar(.5)
            }
        },
        TA = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])],
        Ul = {
            VERY_SMALL: 0,
            SMALL: 1,
            MEDIUM: 2,
            LARGE: 3,
            VERY_LARGE: 4,
            HUGE: 5
        },
        EA = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
}`,
        Zm = class extends Yn.ShaderMaterial {
            constructor() {
                super({
                    type: "CopyMaterial",
                    uniforms: {
                        inputBuffer: new Yn.Uniform(null),
                        opacity: new Yn.Uniform(1)
                    },
                    fragmentShader: EA,
                    vertexShader: ha,
                    blending: Yn.NoBlending,
                    depthWrite: !1,
                    depthTest: !1
                });
                this.toneMapped = !1
            }
        };
    var MA = class extends si.ShaderMaterial {
            constructor(n = new si.Vector2, e = Wl.COLOR) {
                super({
                    type: "EdgeDetectionMaterial",
                    defines: {
                        LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                        EDGE_THRESHOLD: "0.1",
                        DEPTH_THRESHOLD: "0.01",
                        PREDICATION_MODE: "0",
                        PREDICATION_THRESHOLD: "0.01",
                        PREDICATION_SCALE: "2.0",
                        PREDICATION_STRENGTH: "1.0",
                        DEPTH_PACKING: "0"
                    },
                    uniforms: {
                        inputBuffer: new si.Uniform(null),
                        depthBuffer: new si.Uniform(null),
                        predicationBuffer: new si.Uniform(null),
                        texelSize: new si.Uniform(n)
                    },
                    fragmentShader: wA,
                    vertexShader: SA,
                    blending: si.NoBlending,
                    depthWrite: !1,
                    depthTest: !1
                });
                this.toneMapped = !1, this.setEdgeDetectionMode(e)
            }
            get depthPacking() {
                return Number(this.defines.DEPTH_PACKING)
            }
            set depthPacking(n) {
                this.defines.DEPTH_PACKING = n.toFixed(0), this.needsUpdate = !0
            }
            setEdgeDetectionMode(n) {
                this.defines.EDGE_DETECTION_MODE = n.toFixed(0), this.needsUpdate = !0
            }
            setLocalContrastAdaptationFactor(n) {
                this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = n.toFixed("6"), this.needsUpdate = !0
            }
            setEdgeDetectionThreshold(n) {
                this.defines.EDGE_THRESHOLD = n.toFixed("6"), this.defines.DEPTH_THRESHOLD = (n * .1).toFixed("6"), this.needsUpdate = !0
            }
            setPredicationMode(n) {
                this.defines.PREDICATION_MODE = n.toFixed(0), this.needsUpdate = !0
            }
            setPredicationBuffer(n) {
                this.uniforms.predicationBuffer.value = n
            }
            setPredicationThreshold(n) {
                this.defines.PREDICATION_THRESHOLD = n.toFixed("6"), this.needsUpdate = !0
            }
            setPredicationScale(n) {
                this.defines.PREDICATION_SCALE = n.toFixed("6"), this.needsUpdate = !0
            }
            setPredicationStrength(n) {
                this.defines.PREDICATION_STRENGTH = n.toFixed("6"), this.needsUpdate = !0
            }
        },
        Wl = {
            DEPTH: 0,
            LUMA: 1,
            COLOR: 2
        },
        $m = {
            DISABLED: 0,
            DEPTH: 1,
            CUSTOM: 2
        },
        _A = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`,
        IA = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}",
        LA = class extends Xt.ShaderMaterial {
            constructor(n = null, e = null, t = null, r, i = !1) {
                super({
                    type: "EffectMaterial",
                    defines: {
                        DEPTH_PACKING: "0",
                        ENCODE_OUTPUT: "1"
                    },
                    uniforms: {
                        inputBuffer: new Xt.Uniform(null),
                        depthBuffer: new Xt.Uniform(null),
                        resolution: new Xt.Uniform(new Xt.Vector2),
                        texelSize: new Xt.Uniform(new Xt.Vector2),
                        cameraNear: new Xt.Uniform(.3),
                        cameraFar: new Xt.Uniform(1e3),
                        aspect: new Xt.Uniform(1),
                        time: new Xt.Uniform(0)
                    },
                    blending: Xt.NoBlending,
                    depthWrite: !1,
                    depthTest: !1,
                    dithering: i
                });
                this.toneMapped = !1, n !== null && this.setShaderParts(n), e !== null && this.setDefines(e), t !== null && this.setUniforms(t), this.adoptCameraSettings(r)
            }
            get depthPacking() {
                return Number(this.defines.DEPTH_PACKING)
            }
            set depthPacking(n) {
                this.defines.DEPTH_PACKING = n.toFixed(0), this.needsUpdate = !0
            }
            setShaderParts(n) {
                return this.fragmentShader = _A.replace(lt.FRAGMENT_HEAD, n.get(lt.FRAGMENT_HEAD)).replace(lt.FRAGMENT_MAIN_UV, n.get(lt.FRAGMENT_MAIN_UV)).replace(lt.FRAGMENT_MAIN_IMAGE, n.get(lt.FRAGMENT_MAIN_IMAGE)), this.vertexShader = IA.replace(lt.VERTEX_HEAD, n.get(lt.VERTEX_HEAD)).replace(lt.VERTEX_MAIN_SUPPORT, n.get(lt.VERTEX_MAIN_SUPPORT)), this.needsUpdate = !0, this
            }
            setDefines(n) {
                for (let e of n.entries()) this.defines[e[0]] = e[1];
                return this.needsUpdate = !0, this
            }
            setUniforms(n) {
                for (let e of n.entries()) this.uniforms[e[0]] = e[1];
                return this
            }
            adoptCameraSettings(n = null) {
                n !== null && (this.uniforms.cameraNear.value = n.near, this.uniforms.cameraFar.value = n.far, n instanceof Xt.PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
            }
            setSize(n, e) {
                let t = Math.max(n, 1),
                    r = Math.max(e, 1);
                this.uniforms.resolution.value.set(t, r), this.uniforms.texelSize.value.set(1 / t, 1 / r), this.uniforms.aspect.value = t / r
            }
        },
        lt = {
            FRAGMENT_HEAD: "FRAGMENT_HEAD",
            FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
            FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
            VERTEX_HEAD: "VERTEX_HEAD",
            VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
        };
    var DA = `#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=linearToRelativeLuminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`,
        PA = class extends oi.ShaderMaterial {
            constructor(n = !1, e = null) {
                let t = e !== null;
                super({
                    type: "LuminanceMaterial",
                    uniforms: {
                        inputBuffer: new oi.Uniform(null),
                        threshold: new oi.Uniform(0),
                        smoothing: new oi.Uniform(1),
                        range: new oi.Uniform(t ? e : new oi.Vector2)
                    },
                    fragmentShader: DA,
                    vertexShader: ha,
                    blending: oi.NoBlending,
                    depthWrite: !1,
                    depthTest: !1
                });
                this.toneMapped = !1, this.colorOutput = n, this.useThreshold = !0, this.useRange = t
            }
            get threshold() {
                return this.uniforms.threshold.value
            }
            set threshold(n) {
                this.uniforms.threshold.value = n
            }
            get smoothing() {
                return this.uniforms.smoothing.value
            }
            set smoothing(n) {
                this.uniforms.smoothing.value = n
            }
            get useThreshold() {
                return this.defines.THRESHOLD !== void 0
            }
            set useThreshold(n) {
                n ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.needsUpdate = !0
            }
            get colorOutput() {
                return this.defines.COLOR !== void 0
            }
            set colorOutput(n) {
                n ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0
            }
            setColorOutputEnabled(n) {
                this.colorOutput = n
            }
            get useRange() {
                return this.defines.RANGE !== void 0
            }
            set useRange(n) {
                n ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.needsUpdate = !0
            }
            get luminanceRange() {
                return this.useRange
            }
            set luminanceRange(n) {
                this.useRange = n
            }
            setLuminanceRangeEnabled(n) {
                this.useRange = n
            }
        },
        BA = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`,
        OA = class extends Ii.ShaderMaterial {
            constructor(n = null) {
                super({
                    type: "MaskMaterial",
                    uniforms: {
                        maskTexture: new Ii.Uniform(n),
                        inputBuffer: new Ii.Uniform(null),
                        strength: new Ii.Uniform(1)
                    },
                    fragmentShader: BA,
                    vertexShader: ha,
                    blending: Ii.NoBlending,
                    depthWrite: !1,
                    depthTest: !1
                });
                this.toneMapped = !1, this.colorChannel = Xm.RED, this.maskFunction = ep.DISCARD
            }
            set maskTexture(n) {
                this.uniforms.maskTexture.value = n, delete this.defines.MASK_PRECISION_HIGH, n.type !== Ii.UnsignedByteType && (this.defines.MASK_PRECISION_HIGH = "1"), this.needsUpdate = !0
            }
            set colorChannel(n) {
                this.defines.COLOR_CHANNEL = n.toFixed(0), this.needsUpdate = !0
            }
            set maskFunction(n) {
                this.defines.MASK_FUNCTION = n.toFixed(0), this.needsUpdate = !0
            }
            get inverted() {
                return this.defines.INVERTED !== void 0
            }
            set inverted(n) {
                this.inverted && !n ? delete this.defines.INVERTED : n && (this.defines.INVERTED = "1"), this.needsUpdate = !0
            }
            get strength() {
                return this.uniforms.strength.value
            }
            set strength(n) {
                this.uniforms.strength.value = n
            }
        },
        ep = {
            DISCARD: 0,
            MULTIPLY: 1,
            MULTIPLY_RGB_SET_ALPHA: 2
        };
    var RA = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`,
        FA = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}",
        GA = class extends Or.ShaderMaterial {
            constructor(n = new Or.Vector2, e = new Or.Vector2) {
                super({
                    type: "SMAAWeightsMaterial",
                    defines: {
                        MAX_SEARCH_STEPS_INT: "16",
                        MAX_SEARCH_STEPS_FLOAT: "16.0",
                        MAX_SEARCH_STEPS_DIAG_INT: "8",
                        MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                        CORNER_ROUNDING: "25",
                        CORNER_ROUNDING_NORM: "0.25",
                        AREATEX_MAX_DISTANCE: "16.0",
                        AREATEX_MAX_DISTANCE_DIAG: "20.0",
                        AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                        AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                        SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                        SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                    },
                    uniforms: {
                        inputBuffer: new Or.Uniform(null),
                        areaTexture: new Or.Uniform(null),
                        searchTexture: new Or.Uniform(null),
                        texelSize: new Or.Uniform(n),
                        resolution: new Or.Uniform(e)
                    },
                    fragmentShader: RA,
                    vertexShader: FA,
                    blending: Or.NoBlending,
                    depthWrite: !1,
                    depthTest: !1
                });
                this.toneMapped = !1
            }
            setOrthogonalSearchSteps(n) {
                let e = Math.min(Math.max(n, 0), 112);
                this.defines.MAX_SEARCH_STEPS_INT = e.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = e.toFixed("1"), this.needsUpdate = !0
            }
            setDiagonalSearchSteps(n) {
                let e = Math.min(Math.max(n, 0), 20);
                this.defines.MAX_SEARCH_STEPS_DIAG_INT = e.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = e.toFixed("1"), this.needsUpdate = !0
            }
            setCornerRounding(n) {
                let e = Math.min(Math.max(n, 0), 100);
                this.defines.CORNER_ROUNDING = e.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (e / 100).toFixed("4"), this.needsUpdate = !0
            }
            get diagonalDetection() {
                return this.defines.DISABLE_DIAG_DETECTION === void 0
            }
            set diagonalDetection(n) {
                n ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0
            }
            get cornerRounding() {
                return this.defines.DISABLE_CORNER_DETECTION === void 0
            }
            set cornerRounding(n) {
                n ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0
            }
        };
    var zA = new ur.Camera,
        gn = null;

    function kA() {
        if (gn === null) {
            let n = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                e = new Float32Array([0, 0, 2, 0, 0, 2]);
            gn = new ur.BufferGeometry, gn.setAttribute !== void 0 ? (gn.setAttribute("position", new ur.BufferAttribute(n, 3)), gn.setAttribute("uv", new ur.BufferAttribute(e, 2))) : (gn.addAttribute("position", new ur.BufferAttribute(n, 3)), gn.addAttribute("uv", new ur.BufferAttribute(e, 2)))
        }
        return gn
    }
    var Li = class {
            constructor(n = "Pass", e = new ur.Scene, t = zA) {
                this.name = n, this.scene = e, this.camera = t, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
            }
            get renderToScreen() {
                return !this.rtt
            }
            set renderToScreen(n) {
                if (this.rtt === n) {
                    let e = this.getFullscreenMaterial();
                    e !== null && (e.needsUpdate = !0), this.rtt = !n
                }
            }
            getFullscreenMaterial() {
                return this.screen !== null ? this.screen.material : null
            }
            setFullscreenMaterial(n) {
                let e = this.screen;
                e !== null ? e.material = n : (e = new ur.Mesh(kA(), n), e.frustumCulled = !1, this.scene === null && (this.scene = new ur.Scene), this.scene.add(e), this.screen = e)
            }
            getDepthTexture() {
                return null
            }
            setDepthTexture(n, e = 0) {}
            render(n, e, t, r, i) {
                throw new Error("Render method not implemented!")
            }
            setSize(n, e) {}
            initialize(n, e, t) {}
            dispose() {
                let n = this.getFullscreenMaterial();
                n !== null && n.dispose();
                for (let e of Object.keys(this)) {
                    let t = this[e];
                    if (t !== null && typeof t.dispose == "function") {
                        if (t instanceof ur.Scene) continue;
                        this[e].dispose()
                    }
                }
            }
        },
        tp = class extends Li {
            constructor(n, e = !0) {
                super("SavePass");
                this.setFullscreenMaterial(new Zm), this.needsSwap = !1, this.renderTarget = n, n === void 0 && (this.renderTarget = new Di.WebGLRenderTarget(1, 1, {
                    minFilter: Di.LinearFilter,
                    magFilter: Di.LinearFilter,
                    stencilBuffer: !1,
                    depthBuffer: !1
                }), this.renderTarget.texture.name = "SavePass.Target"), this.resize = e
            }
            get texture() {
                return this.renderTarget.texture
            }
            render(n, e, t, r, i) {
                this.getFullscreenMaterial().uniforms.inputBuffer.value = e.texture, n.setRenderTarget(this.renderToScreen ? null : this.renderTarget), n.render(this.scene, this.camera)
            }
            setSize(n, e) {
                if (this.resize) {
                    let t = Math.max(n, 1),
                        r = Math.max(e, 1);
                    this.renderTarget.setSize(t, r)
                }
            }
            initialize(n, e, t) {
                if (!e && t === Di.UnsignedByteType && (this.renderTarget.texture.format = Di.RGBFormat), t !== void 0 && (this.renderTarget.texture.type = t, t !== Di.UnsignedByteType)) {
                    let r = this.getFullscreenMaterial();
                    r.defines.FRAMEBUFFER_PRECISION_HIGH = "1"
                }
            }
        };
    var Ji = -1,
        _r = class {
            constructor(n, e = Ji, t = Ji, r = 1) {
                this.resizable = n, this.base = new sf.Vector2(1, 1), this.target = new sf.Vector2(e, t), this.s = r
            }
            get scale() {
                return this.s
            }
            set scale(n) {
                this.s = n, this.target.x = Ji, this.target.y = Ji, this.resizable.setSize(this.base.x, this.base.y)
            }
            get width() {
                let n = this.base,
                    e = this.target,
                    t;
                return e.x !== Ji ? t = e.x : e.y !== Ji ? t = Math.round(e.y * (n.x / n.y)) : t = Math.round(n.x * this.s), t
            }
            set width(n) {
                this.target.x = n, this.resizable.setSize(this.base.x, this.base.y)
            }
            get height() {
                let n = this.base,
                    e = this.target,
                    t;
                return e.y !== Ji ? t = e.y : e.x !== Ji ? t = Math.round(e.x / (n.x / n.y)) : t = Math.round(n.y * this.s), t
            }
            set height(n) {
                this.target.y = n, this.resizable.setSize(this.base.x, this.base.y)
            }
            static get AUTO_SIZE() {
                return Ji
            }
        },
        rp = class extends Li {
            constructor({
                resolutionScale: n = .5,
                width: e = _r.AUTO_SIZE,
                height: t = _r.AUTO_SIZE,
                kernelSize: r = Ul.LARGE
            } = {}) {
                super("BlurPass");
                this.renderTargetA = new ai.WebGLRenderTarget(1, 1, {
                    minFilter: ai.LinearFilter,
                    magFilter: ai.LinearFilter,
                    stencilBuffer: !1,
                    depthBuffer: !1
                }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B", this.resolution = new _r(this, e, t, n), this.convolutionMaterial = new qm, this.ditheredConvolutionMaterial = new qm, this.ditheredConvolutionMaterial.dithering = !0, this.dithering = !1, this.kernelSize = r
            }
            get width() {
                return this.resolution.width
            }
            set width(n) {
                this.resolution.width = n
            }
            get height() {
                return this.resolution.height
            }
            set height(n) {
                this.resolution.height = n
            }
            get scale() {
                return this.convolutionMaterial.uniforms.scale.value
            }
            set scale(n) {
                this.convolutionMaterial.uniforms.scale.value = n, this.ditheredConvolutionMaterial.uniforms.scale.value = n
            }
            get kernelSize() {
                return this.convolutionMaterial.kernelSize
            }
            set kernelSize(n) {
                this.convolutionMaterial.kernelSize = n, this.ditheredConvolutionMaterial.kernelSize = n
            }
            getResolutionScale() {
                return this.resolution.scale
            }
            setResolutionScale(n) {
                this.resolution.scale = n
            }
            render(n, e, t, r, i) {
                let s = this.scene,
                    o = this.camera,
                    l = this.renderTargetA,
                    a = this.renderTargetB,
                    c = this.convolutionMaterial,
                    f = c.uniforms,
                    h = c.getKernel(),
                    m = e,
                    v, g, y;
                for (this.setFullscreenMaterial(c), g = 0, y = h.length - 1; g < y; ++g) v = (g & 1) == 0 ? l : a, f.kernel.value = h[g], f.inputBuffer.value = m.texture, n.setRenderTarget(v), n.render(s, o), m = v;
                this.dithering && (c = this.ditheredConvolutionMaterial, f = c.uniforms, this.setFullscreenMaterial(c)), f.kernel.value = h[g], f.inputBuffer.value = m.texture, n.setRenderTarget(this.renderToScreen ? null : t), n.render(s, o)
            }
            setSize(n, e) {
                let t = this.resolution;
                t.base.set(n, e);
                let r = t.width,
                    i = t.height;
                this.renderTargetA.setSize(r, i), this.renderTargetB.setSize(r, i), this.convolutionMaterial.setTexelSize(1 / r, 1 / i), this.ditheredConvolutionMaterial.setTexelSize(1 / r, 1 / i)
            }
            initialize(n, e, t) {
                if (!e && t === ai.UnsignedByteType && (this.renderTargetA.texture.format = ai.RGBFormat, this.renderTargetB.texture.format = ai.RGBFormat), t !== void 0 && (this.renderTargetA.texture.type = t, this.renderTargetB.texture.type = t, t !== ai.UnsignedByteType)) {
                    let r = this.convolutionMaterial,
                        i = this.ditheredConvolutionMaterial;
                    r.defines.FRAMEBUFFER_PRECISION_HIGH = "1", i.defines.FRAMEBUFFER_PRECISION_HIGH = "1"
                }
            }
            static get AUTO_SIZE() {
                return _r.AUTO_SIZE
            }
        },
        UA = class extends Li {
            constructor() {
                super("ClearMaskPass", null, null);
                this.needsSwap = !1
            }
            render(n, e, t, r, i) {
                let s = n.state.buffers.stencil;
                s.setLocked(!1), s.setTest(!1)
            }
        },
        of = new ip.Color,
        af = class extends Li {
            constructor(n = !0, e = !0, t = !1) {
                super("ClearPass", null, null);
                this.needsSwap = !1, this.color = n, this.depth = e, this.stencil = t, this.overrideClearColor = null, this.overrideClearAlpha = -1
            }
            render(n, e, t, r, i) {
                let s = this.overrideClearColor,
                    o = this.overrideClearAlpha,
                    l = n.getClearAlpha(),
                    a = s !== null,
                    c = o >= 0;
                a ? ( of .copy(n.getClearColor( of )), n.setClearColor(s, c ? o : l)) : c && n.setClearAlpha(o), n.setRenderTarget(this.renderToScreen ? null : e), n.clear(this.color, this.depth, this.stencil), a ? n.setClearColor( of , l) : c && n.setClearAlpha(l)
            }
        },
        lf = !1,
        np = class {
            constructor(n = null) {
                this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(n), this.meshCount = 0, this.replaceMaterial = e => {
                    if (e.isMesh) {
                        let t;
                        if (e.material.flatShading) switch (e.material.side) {
                            case Wr.DoubleSide:
                                t = this.materialsFlatShadedDoubleSide;
                                break;
                            case Wr.BackSide:
                                t = this.materialsFlatShadedBackSide;
                                break;
                            default:
                                t = this.materialsFlatShaded;
                                break
                        } else switch (e.material.side) {
                            case Wr.DoubleSide:
                                t = this.materialsDoubleSide;
                                break;
                            case Wr.BackSide:
                                t = this.materialsBackSide;
                                break;
                            default:
                                t = this.materials;
                                break
                        }
                        this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount
                    }
                }
            }
            setMaterial(n) {
                if (this.disposeMaterials(), this.material = n, n !== null) {
                    let e = this.materials = [n.clone(), n.clone(), n.clone()];
                    for (let t of e) t.uniforms = Object.assign({}, n.uniforms), t.side = Wr.FrontSide;
                    e[2].skinning = !0, this.materialsBackSide = e.map(t => {
                        let r = t.clone();
                        return r.uniforms = Object.assign({}, n.uniforms), r.side = Wr.BackSide, r
                    }), this.materialsDoubleSide = e.map(t => {
                        let r = t.clone();
                        return r.uniforms = Object.assign({}, n.uniforms), r.side = Wr.DoubleSide, r
                    }), this.materialsFlatShaded = e.map(t => {
                        let r = t.clone();
                        return r.uniforms = Object.assign({}, n.uniforms), r.flatShading = !0, r
                    }), this.materialsFlatShadedBackSide = e.map(t => {
                        let r = t.clone();
                        return r.uniforms = Object.assign({}, n.uniforms), r.flatShading = !0, r.side = Wr.BackSide, r
                    }), this.materialsFlatShadedDoubleSide = e.map(t => {
                        let r = t.clone();
                        return r.uniforms = Object.assign({}, n.uniforms), r.flatShading = !0, r.side = Wr.DoubleSide, r
                    })
                }
            }
            render(n, e, t) {
                let r = n.shadowMap.enabled;
                if (n.shadowMap.enabled = !1, lf) {
                    let i = this.originalMaterials;
                    this.meshCount = 0, e.traverse(this.replaceMaterial), n.render(e, t);
                    for (let s of i) s[0].material = s[1];
                    this.meshCount !== i.size && i.clear()
                } else {
                    let i = e.overrideMaterial;
                    e.overrideMaterial = this.material, n.render(e, t), e.overrideMaterial = i
                }
                n.shadowMap.enabled = r
            }
            disposeMaterials() {
                if (this.material !== null) {
                    let n = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                    for (let e of n) e.dispose()
                }
            }
            dispose() {
                this.originalMaterials.clear(), this.disposeMaterials()
            }
            static get workaroundEnabled() {
                return lf
            }
            static set workaroundEnabled(n) {
                lf = n
            }
        },
        Ql = class extends Li {
            constructor(n, e, t = null) {
                super("RenderPass", n, e);
                this.needsSwap = !1, this.clearPass = new af, this.overrideMaterialManager = t === null ? null : new np(t)
            }
            get renderToScreen() {
                return super.renderToScreen
            }
            set renderToScreen(n) {
                super.renderToScreen = n, this.clearPass.renderToScreen = n
            }
            get overrideMaterial() {
                let n = this.overrideMaterialManager;
                return n !== null ? n.material : null
            }
            set overrideMaterial(n) {
                let e = this.overrideMaterialManager;
                n !== null ? e !== null ? e.setMaterial(n) : this.overrideMaterialManager = new np(n) : e !== null && (e.dispose(), this.overrideMaterialManager = null)
            }
            get clear() {
                return this.clearPass.enabled
            }
            set clear(n) {
                this.clearPass.enabled = n
            }
            getClearPass() {
                return this.clearPass
            }
            render(n, e, t, r, i) {
                let s = this.scene,
                    o = this.camera,
                    l = s.background,
                    a = this.renderToScreen ? null : e;
                this.clear && (this.clearPass.overrideClearColor !== null && (s.background = null), this.clearPass.render(n, e)), n.setRenderTarget(a), this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(n, s, o) : n.render(s, o), s.background !== l && (s.background = l)
            }
        },
        cf = class extends Li {
            constructor(n, e, {
                resolutionScale: t = 1,
                width: r = _r.AUTO_SIZE,
                height: i = _r.AUTO_SIZE,
                renderTarget: s
            } = {}) {
                super("DepthPass");
                this.needsSwap = !1, this.renderPass = new Ql(n, e, new li.MeshDepthMaterial({
                    depthPacking: li.RGBADepthPacking
                }));
                let o = this.renderPass.getClearPass();
                o.overrideClearColor = new li.Color(16777215), o.overrideClearAlpha = 1, this.renderTarget = s, this.renderTarget === void 0 && (this.renderTarget = new li.WebGLRenderTarget(1, 1, {
                    minFilter: li.NearestFilter,
                    magFilter: li.NearestFilter,
                    stencilBuffer: !1
                }), this.renderTarget.texture.name = "DepthPass.Target"), this.resolution = new _r(this, r, i, t)
            }
            get texture() {
                return this.renderTarget.texture
            }
            getResolutionScale() {
                return this.resolutionScale
            }
            setResolutionScale(n) {
                this.resolutionScale = n, this.setSize(this.resolution.base.x, this.resolution.base.y)
            }
            render(n, e, t, r, i) {
                let s = this.renderToScreen ? null : this.renderTarget;
                this.renderPass.render(n, s)
            }
            setSize(n, e) {
                let t = this.resolution;
                t.base.set(n, e), this.renderTarget.setSize(t.width, t.height)
            }
        };
    var zO = new Float32Array([255 / 256 / 256 ** 3, 255 / 256 / 256 ** 2, 255 / 256 / 256, 255 / 256]);
    var et = {
            SKIP: 0,
            ADD: 1,
            ALPHA: 2,
            AVERAGE: 3,
            COLOR_BURN: 4,
            COLOR_DODGE: 5,
            DARKEN: 6,
            DIFFERENCE: 7,
            EXCLUSION: 8,
            LIGHTEN: 9,
            MULTIPLY: 10,
            DIVIDE: 11,
            NEGATION: 12,
            NORMAL: 13,
            OVERLAY: 14,
            REFLECT: 15,
            SCREEN: 16,
            SOFT_LIGHT: 17,
            SUBTRACT: 18
        },
        jA = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}",
        VA = "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}",
        HA = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}",
        WA = "float blend(const in float x,const in float y){return(y==0.0)? y : max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
        JA = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
        QA = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}",
        YA = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}",
        KA = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}",
        XA = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}",
        qA = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}",
        ZA = "float blend(const in float x,const in float y){return(y>0.0)? min(x/y,1.0): 1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
        $A = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}",
        eb = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}",
        tb = "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
        rb = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
        ib = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}",
        nb = "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
        sb = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}",
        ob = new Map([
            [et.SKIP, null],
            [et.ADD, jA],
            [et.ALPHA, VA],
            [et.AVERAGE, HA],
            [et.COLOR_BURN, WA],
            [et.COLOR_DODGE, JA],
            [et.DARKEN, QA],
            [et.DIFFERENCE, YA],
            [et.EXCLUSION, KA],
            [et.LIGHTEN, XA],
            [et.MULTIPLY, qA],
            [et.DIVIDE, ZA],
            [et.NEGATION, $A],
            [et.NORMAL, eb],
            [et.OVERLAY, tb],
            [et.REFLECT, rb],
            [et.SCREEN, ib],
            [et.SOFT_LIGHT, nb],
            [et.SUBTRACT, sb]
        ]),
        ab = class extends Xl.EventDispatcher {
            constructor(n, e = 1) {
                super();
                this.blendFunction = n, this.opacity = new Xl.Uniform(e)
            }
            getBlendFunction() {
                return this.blendFunction
            }
            setBlendFunction(n) {
                this.blendFunction = n, this.dispatchEvent({
                    type: "change"
                })
            }
            getShaderCode() {
                return ob.get(this.blendFunction)
            }
        },
        Pi = class extends ql.EventDispatcher {
            constructor(n, e, {
                attributes: t = ci.NONE,
                blendFunction: r = et.SCREEN,
                defines: i = new Map,
                uniforms: s = new Map,
                extensions: o = null,
                vertexShader: l = null
            } = {}) {
                super();
                this.name = n, this.attributes = t, this.fragmentShader = e, this.vertexShader = l, this.defines = i, this.uniforms = s, this.extensions = o, this.blendMode = new ab(r), this.blendMode.addEventListener("change", a => this.setChanged())
            }
            setChanged() {
                this.dispatchEvent({
                    type: "change"
                })
            }
            getAttributes() {
                return this.attributes
            }
            setAttributes(n) {
                this.attributes = n, this.setChanged()
            }
            getFragmentShader() {
                return this.fragmentShader
            }
            setFragmentShader(n) {
                this.fragmentShader = n, this.setChanged()
            }
            getVertexShader() {
                return this.vertexShader
            }
            setVertexShader(n) {
                this.vertexShader = n, this.setChanged()
            }
            setDepthTexture(n, e = 0) {}
            update(n, e, t) {}
            setSize(n, e) {}
            initialize(n, e, t) {}
            dispose() {
                for (let n of Object.keys(this)) {
                    let e = this[n];
                    if (e !== null && typeof e.dispose == "function") {
                        if (e instanceof ql.Scene) continue;
                        this[n].dispose()
                    }
                }
            }
        },
        ci = {
            NONE: 0,
            DEPTH: 1,
            CONVOLUTION: 2
        };

    function uf(n, e) {
        let t = [],
            r;
        for (;
            (r = n.exec(e)) !== null;) t.push(r[1]);
        return t
    }

    function op(n, e, t) {
        let r, i;
        for (let s of e) {
            r = "$1" + n + s.charAt(0).toUpperCase() + s.slice(1), i = new RegExp("([^\\.])(\\b" + s + "\\b)", "g");
            for (let o of t.entries()) o[1] !== null && t.set(o[0], o[1].replace(i, r))
        }
    }

    function lb(n, e, t, r, i, s, o) {
        let l = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g,
            a = /(?:varying\s+\w+\s+(\w*))/g,
            c = e.blendMode,
            f = new Map([
                ["fragment", e.getFragmentShader()],
                ["vertex", e.getVertexShader()]
            ]),
            h = f.get("fragment") !== void 0 && /mainImage/.test(f.get("fragment")),
            m = f.get("fragment") !== void 0 && /mainUv/.test(f.get("fragment")),
            v = [],
            g = [],
            y = !1,
            A = !1;
        if (f.get("fragment") === void 0) console.error("Missing fragment shader", e);
        else if (m && (o & ci.CONVOLUTION) != 0) console.error("Effects that transform UV coordinates are incompatible with convolution effects", e);
        else if (!h && !m) console.error("The fragment shader contains neither a mainImage nor a mainUv function", e);
        else {
            if (m && (t.set(lt.FRAGMENT_MAIN_UV, t.get(lt.FRAGMENT_MAIN_UV) + "	" + n + `MainUv(UV);
`), y = !0), f.get("vertex") !== null && /mainSupport/.test(f.get("vertex"))) {
                let w = "	" + n + "MainSupport(";
                /mainSupport *\([\w\s]*?uv\s*?\)/.test(f.get("vertex")) && (w += "vUv"), w += `);
`, t.set(lt.VERTEX_MAIN_SUPPORT, t.get(lt.VERTEX_MAIN_SUPPORT) + w), v = v.concat(uf(a, f.get("vertex"))), g = g.concat(v).concat(uf(l, f.get("vertex")))
            }
            if (g = g.concat(uf(l, f.get("fragment"))).concat(Array.from(e.defines.keys()).map(w => w.replace(/\([\w\s,]*\)/g, ""))).concat(Array.from(e.uniforms.keys())), e.uniforms.forEach((w, C) => s.set(n + C.charAt(0).toUpperCase() + C.slice(1), w)), e.defines.forEach((w, C) => i.set(n + C.charAt(0).toUpperCase() + C.slice(1), w)), op(n, g, i), op(n, g, f), r.set(c.blendFunction, c), h) {
                let w = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/,
                    C = n + "MainImage(color0, UV, ";
                (o & ci.DEPTH) != 0 && w.test(f.get("fragment")) && (C += "depth, ", A = !0), C += `color1);
	`;
                let S = n + "BlendOpacity";
                s.set(S, c.opacity), C += "color0 = blend" + c.getBlendFunction() + "(color0, color1, " + S + `);

	`, t.set(lt.FRAGMENT_MAIN_IMAGE, t.get(lt.FRAGMENT_MAIN_IMAGE) + C), t.set(lt.FRAGMENT_HEAD, t.get(lt.FRAGMENT_HEAD) + "uniform float " + S + `;

`)
            }
            t.set(lt.FRAGMENT_HEAD, t.get(lt.FRAGMENT_HEAD) + f.get("fragment") + `
`), f.get("vertex") !== null && t.set(lt.VERTEX_HEAD, t.get(lt.VERTEX_HEAD) + f.get("vertex") + `
`)
        }
        return {
            varyings: v,
            transformedUv: y,
            readDepth: A
        }
    }
    var Zl = class extends Li {
        constructor(n, ...e) {
            super("EffectPass");
            this.setFullscreenMaterial(new LA(null, null, null, n)), this.effects = e.sort((t, r) => r.attributes - t.attributes), this.skipRendering = !1, this.uniforms = 0, this.varyings = 0, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY
        }
        get encodeOutput() {
            return this.getFullscreenMaterial().defines.ENCODE_OUTPUT !== void 0
        }
        set encodeOutput(n) {
            if (this.encodeOutput !== n) {
                let e = this.getFullscreenMaterial();
                e.needsUpdate = !0, n ? e.defines.ENCODE_OUTPUT = "1" : delete e.defines.ENCODE_OUTPUT
            }
        }
        get dithering() {
            return this.getFullscreenMaterial().dithering
        }
        set dithering(n) {
            let e = this.getFullscreenMaterial();
            e.dithering !== n && (e.dithering = n, e.needsUpdate = !0)
        }
        verifyResources(n) {
            let e = n.capabilities,
                t = Math.min(e.maxFragmentUniforms, e.maxVertexUniforms);
            this.uniforms > t && console.warn("The current rendering context doesn't support more than " + t + " uniforms, but " + this.uniforms + " were defined"), t = e.maxVaryings, this.varyings > t && console.warn("The current rendering context doesn't support more than " + t + " varyings, but " + this.varyings + " were defined")
        }
        updateMaterial() {
            let n = /\bblend\b/g,
                e = new Map([
                    [lt.FRAGMENT_HEAD, ""],
                    [lt.FRAGMENT_MAIN_UV, ""],
                    [lt.FRAGMENT_MAIN_IMAGE, ""],
                    [lt.VERTEX_HEAD, ""],
                    [lt.VERTEX_MAIN_SUPPORT, ""]
                ]),
                t = new Map,
                r = new Map,
                i = new Map,
                s = new Set,
                o = 0,
                l = 0,
                a = 0,
                c = !1,
                f = !1,
                h;
            for (let v of this.effects)
                if (v.blendMode.getBlendFunction() === et.SKIP) a |= v.getAttributes() & ci.DEPTH;
                else if ((a & ci.CONVOLUTION) != 0 && (v.getAttributes() & ci.CONVOLUTION) != 0) console.error("Convolution effects cannot be merged", v);
            else if (a |= v.getAttributes(), h = lb("e" + o++, v, e, t, r, i, a), l += h.varyings.length, c = c || h.transformedUv, f = f || h.readDepth, v.extensions !== null)
                for (let g of v.extensions) s.add(g);
            for (let v of t.values()) e.set(lt.FRAGMENT_HEAD, e.get(lt.FRAGMENT_HEAD) + v.getShaderCode().replace(n, "blend" + v.getBlendFunction()) + `
`);
            (a & ci.DEPTH) != 0 ? (f && e.set(lt.FRAGMENT_MAIN_IMAGE, `float depth = readDepth(UV);

	` + e.get(lt.FRAGMENT_MAIN_IMAGE)), this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1, c ? (e.set(lt.FRAGMENT_MAIN_UV, `vec2 transformedUv = vUv;
` + e.get(lt.FRAGMENT_MAIN_UV)), r.set("UV", "transformedUv")) : r.set("UV", "vUv"), e.forEach((v, g, y) => y.set(g, v.trim().replace(/^#/, `
#`))), this.uniforms = i.size, this.varyings = l, this.skipRendering = o === 0, this.needsSwap = !this.skipRendering;
            let m = this.getFullscreenMaterial();
            if (m.setShaderParts(e).setDefines(r).setUniforms(i), m.extensions = {}, s.size > 0)
                for (let v of s) m.extensions[v] = !0;
            this.needsUpdate = !1
        }
        recompile(n) {
            this.updateMaterial(), n !== void 0 && this.verifyResources(n)
        }
        getDepthTexture() {
            return this.getFullscreenMaterial().uniforms.depthBuffer.value
        }
        setDepthTexture(n, e = Kl.BasicDepthPacking) {
            let t = this.getFullscreenMaterial();
            t.uniforms.depthBuffer.value = n, t.depthPacking = e, t.needsUpdate = !0;
            for (let r of this.effects) r.setDepthTexture(n, e)
        }
        render(n, e, t, r, i) {
            let s = this.getFullscreenMaterial(),
                o = s.uniforms.time.value + r;
            this.needsUpdate && this.recompile(n);
            for (let l of this.effects) l.update(n, e, r);
            (!this.skipRendering || this.renderToScreen) && (s.uniforms.inputBuffer.value = e.texture, s.uniforms.time.value = o <= this.maxTime ? o : this.minTime, n.setRenderTarget(this.renderToScreen ? null : t), n.render(this.scene, this.camera))
        }
        setSize(n, e) {
            this.getFullscreenMaterial().setSize(n, e);
            for (let t of this.effects) t.setSize(n, e)
        }
        initialize(n, e, t) {
            for (let r of this.effects) r.initialize(n, e, t), r.addEventListener("change", i => this.handleEvent(i));
            if (this.updateMaterial(), this.verifyResources(n), t !== void 0 && t !== Kl.UnsignedByteType) {
                let r = this.getFullscreenMaterial();
                r.defines.FRAMEBUFFER_PRECISION_HIGH = "1"
            }
        }
        dispose() {
            super.dispose();
            for (let n of this.effects) n.dispose()
        }
        handleEvent(n) {
            switch (n.type) {
                case "change":
                    this.needsUpdate = !0;
                    break
            }
        }
    };
    var cb = class extends Li {
            constructor({
                width: n = _r.AUTO_SIZE,
                height: e = _r.AUTO_SIZE,
                renderTarget: t,
                luminanceRange: r,
                colorOutput: i
            } = {}) {
                super("LuminancePass");
                this.setFullscreenMaterial(new PA(i, r)), this.needsSwap = !1, this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new ui.WebGLRenderTarget(1, 1, {
                    minFilter: ui.LinearFilter,
                    magFilter: ui.LinearFilter,
                    format: i ? ui.RGBAFormat : ui.LuminanceFormat,
                    stencilBuffer: !1,
                    depthBuffer: !1
                }), this.renderTarget.texture.name = "LuminancePass.Target", this.renderTarget.texture.generateMipmaps = !1), this.resolution = new _r(this, n, e)
            }
            get texture() {
                return this.renderTarget.texture
            }
            render(n, e, t, r, i) {
                let s = this.getFullscreenMaterial();
                s.uniforms.inputBuffer.value = e.texture, n.setRenderTarget(this.renderToScreen ? null : this.renderTarget), n.render(this.scene, this.camera)
            }
            setSize(n, e) {
                let t = this.resolution;
                t.base.set(n, e), this.renderTarget.setSize(t.width, t.height)
            }
            initialize(n, e, t) {
                if (t !== void 0 && t !== ui.UnsignedByteType) {
                    let r = this.getFullscreenMaterial();
                    r.defines.FRAMEBUFFER_PRECISION_HIGH = "1"
                }
            }
        },
        ub = class extends Li {
            constructor(n, e) {
                super("MaskPass", n, e);
                this.needsSwap = !1, this.clearPass = new af(!1, !1, !0), this.inverse = !1
            }
            get clear() {
                return this.clearPass.enabled
            }
            set clear(n) {
                this.clearPass.enabled = n
            }
            render(n, e, t, r, i) {
                let s = n.getContext(),
                    o = n.state.buffers,
                    l = this.scene,
                    a = this.camera,
                    c = this.clearPass,
                    f = this.inverse ? 0 : 1,
                    h = 1 - f;
                o.color.setMask(!1), o.depth.setMask(!1), o.color.setLocked(!0), o.depth.setLocked(!0), o.stencil.setTest(!0), o.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), o.stencil.setFunc(s.ALWAYS, f, 4294967295), o.stencil.setClear(h), o.stencil.setLocked(!0), this.clear && (this.renderToScreen ? c.render(n, null) : (c.render(n, e), c.render(n, t))), this.renderToScreen ? (n.setRenderTarget(null), n.render(l, a)) : (n.setRenderTarget(e), n.render(l, a), n.setRenderTarget(t), n.render(l, a)), o.color.setLocked(!1), o.depth.setLocked(!1), o.stencil.setLocked(!1), o.stencil.setFunc(s.EQUAL, 1, 4294967295), o.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), o.stencil.setLocked(!0)
            }
        };
    var Qi = class extends Li {
            constructor(n, e = "inputBuffer") {
                super("ShaderPass");
                this.setFullscreenMaterial(n), this.uniform = null, this.setInput(e)
            }
            setInput(n) {
                let e = this.getFullscreenMaterial();
                if (this.uniform = null, e !== null) {
                    let t = e.uniforms;
                    t !== void 0 && t[n] !== void 0 && (this.uniform = t[n])
                }
            }
            render(n, e, t, r, i) {
                this.uniform !== null && e !== null && (this.uniform.value = e.texture), n.setRenderTarget(this.renderToScreen ? null : t), n.render(this.scene, this.camera)
            }
            initialize(n, e, t) {
                if (t !== void 0 && t !== ap.UnsignedByteType) {
                    let r = this.getFullscreenMaterial();
                    r.defines.FRAMEBUFFER_PRECISION_HIGH = "1"
                }
            }
        },
        lp = class {
            constructor(n = null, {
                depthBuffer: e = !0,
                stencilBuffer: t = !1,
                alpha: r = !1,
                multisampling: i = 0,
                frameBufferType: s
            } = {}) {
                this.renderer = n, this.inputBuffer = null, this.outputBuffer = null, this.renderer !== null && (this.renderer.autoClear = !1, this.inputBuffer = this.createBuffer(e, t, s, i), this.outputBuffer = this.inputBuffer.clone()), this.copyPass = new Qi(new Zm), this.alpha = r, this.depthTexture = null, this.passes = [], this.autoRenderToScreen = !0
            }
            get multisampling() {
                return this.inputBuffer instanceof gt.WebGLMultisampleRenderTarget ? this.inputBuffer.samples : 0
            }
            set multisampling(n) {
                let e = this.inputBuffer,
                    t = this.multisampling;
                t > 0 && n > 0 ? (this.inputBuffer.samples = n, this.outputBuffer.samples = n) : t !== n && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, n), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone())
            }
            getRenderer() {
                return this.renderer
            }
            replaceRenderer(n, e = !0) {
                let t = this.renderer;
                if (t !== null && t !== n) {
                    let r = t.getSize(new gt.Vector2),
                        i = n.getSize(new gt.Vector2),
                        s = t.domElement.parentNode;
                    this.renderer = n, this.renderer.autoClear = !1, r.equals(i) || this.setSize(), e && s !== null && (s.removeChild(t.domElement), s.appendChild(n.domElement))
                }
                return t
            }
            createDepthTexture() {
                let n = this.depthTexture = new gt.DepthTexture;
                return this.inputBuffer.depthTexture = n, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (n.format = gt.DepthStencilFormat, n.type = gt.UnsignedInt248Type) : n.type = gt.UnsignedIntType, n
            }
            deleteDepthTexture() {
                if (this.depthTexture !== null) {
                    this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
                    for (let n of this.passes) n.setDepthTexture(null)
                }
            }
            createBuffer(n, e, t, r) {
                let i = this.renderer,
                    s = i.getContext(),
                    o = i.getDrawingBufferSize(new gt.Vector2),
                    a = {
                        format: !(this.alpha || s.getContextAttributes().alpha) && t === gt.UnsignedByteType ? gt.RGBFormat : gt.RGBAFormat,
                        minFilter: gt.LinearFilter,
                        magFilter: gt.LinearFilter,
                        stencilBuffer: e,
                        depthBuffer: n,
                        type: t
                    },
                    c = r > 0 ? new gt.WebGLMultisampleRenderTarget(o.width, o.height, a) : new gt.WebGLRenderTarget(o.width, o.height, a);
                return r > 0 && (c.samples = r), c.texture.name = "EffectComposer.Buffer", c.texture.generateMipmaps = !1, c
            }
            addPass(n, e) {
                let t = this.passes,
                    r = this.renderer,
                    i = r.getDrawingBufferSize(new gt.Vector2),
                    s = r.getContext().getContextAttributes().alpha,
                    o = this.inputBuffer.texture.type;
                if (n.setSize(i.width, i.height), n.initialize(r, s, o), this.autoRenderToScreen && (t.length > 0 && (t[t.length - 1].renderToScreen = !1), n.renderToScreen && (this.autoRenderToScreen = !1)), e !== void 0 ? t.splice(e, 0, n) : t.push(n), this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0), n.needsDepthTexture || this.depthTexture !== null)
                    if (this.depthTexture === null) {
                        let l = this.createDepthTexture();
                        for (n of t) n.setDepthTexture(l)
                    } else n.setDepthTexture(this.depthTexture)
            }
            removePass(n) {
                let e = this.passes,
                    t = e.indexOf(n);
                if (t !== -1 && e.splice(t, 1).length > 0) {
                    if (this.depthTexture !== null) {
                        let s = (l, a) => l || a.needsDepthTexture;
                        e.reduce(s, !1) || (n.getDepthTexture() === this.depthTexture && n.setDepthTexture(null), this.deleteDepthTexture())
                    }
                    this.autoRenderToScreen && t === e.length && (n.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0))
                }
            }
            removeAllPasses() {
                let n = this.passes;
                this.deleteDepthTexture(), n.length > 0 && (this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !1), this.passes = [])
            }
            render(n) {
                let e = this.renderer,
                    t = this.copyPass,
                    r = this.inputBuffer,
                    i = this.outputBuffer,
                    s = !1,
                    o, l, a;
                for (let c of this.passes) c.enabled && (c.render(e, r, i, n, s), c.needsSwap && (s && (t.renderToScreen = c.renderToScreen, o = e.getContext(), l = e.state.buffers.stencil, l.setFunc(o.NOTEQUAL, 1, 4294967295), t.render(e, r, i, n, s), l.setFunc(o.EQUAL, 1, 4294967295)), a = r, r = i, i = a), c instanceof ub ? s = !0 : c instanceof UA && (s = !1))
            }
            setSize(n, e, t) {
                let r = this.renderer;
                if (n === void 0 || e === void 0) {
                    let s = r.getSize(new gt.Vector2);
                    n = s.width, e = s.height
                } else r.setSize(n, e, t);
                let i = r.getDrawingBufferSize(new gt.Vector2);
                this.inputBuffer.setSize(i.width, i.height), this.outputBuffer.setSize(i.width, i.height);
                for (let s of this.passes) s.setSize(i.width, i.height)
            }
            reset() {
                this.dispose(), this.autoRenderToScreen = !0
            }
            dispose() {
                for (let n of this.passes) n.dispose();
                this.passes = [], this.inputBuffer !== null && this.inputBuffer.dispose(), this.outputBuffer !== null && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose()
            }
        };
    var fb = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=clamp(texture2D(map,uv)*intensity,0.0,1.0);}`,
        cp = class extends Pi {
            constructor({
                blendFunction: n = et.SCREEN,
                luminanceThreshold: e = .9,
                luminanceSmoothing: t = .025,
                resolutionScale: r = .5,
                intensity: i = 1,
                width: s = _r.AUTO_SIZE,
                height: o = _r.AUTO_SIZE,
                kernelSize: l = Ul.LARGE
            } = {}) {
                super("BloomEffect", fb, {
                    blendFunction: n,
                    uniforms: new Map([
                        ["map", new Jr.Uniform(null)],
                        ["intensity", new Jr.Uniform(i)]
                    ])
                });
                this.renderTarget = new Jr.WebGLRenderTarget(1, 1, {
                    minFilter: Jr.LinearFilter,
                    magFilter: Jr.LinearFilter,
                    stencilBuffer: !1,
                    depthBuffer: !1
                }), this.renderTarget.texture.name = "Bloom.Target", this.renderTarget.texture.generateMipmaps = !1, this.uniforms.get("map").value = this.renderTarget.texture, this.blurPass = new rp({
                    resolutionScale: r,
                    width: s,
                    height: o,
                    kernelSize: l
                }), this.blurPass.resolution.resizable = this, this.luminancePass = new cb({
                    renderTarget: this.renderTarget,
                    colorOutput: !0
                }), this.luminancePass.resolution = this.resolution, this.luminanceMaterial.threshold = e, this.luminanceMaterial.smoothing = t
            }
            get texture() {
                return this.renderTarget.texture
            }
            get luminanceMaterial() {
                return this.luminancePass.getFullscreenMaterial()
            }
            get resolution() {
                return this.blurPass.resolution
            }
            get width() {
                return this.resolution.width
            }
            set width(n) {
                this.resolution.width = n
            }
            get height() {
                return this.resolution.height
            }
            set height(n) {
                this.resolution.height = n
            }
            get dithering() {
                return this.blurPass.dithering
            }
            set dithering(n) {
                this.blurPass.dithering = n
            }
            get kernelSize() {
                return this.blurPass.kernelSize
            }
            set kernelSize(n) {
                this.blurPass.kernelSize = n
            }
            get distinction() {
                return console.warn(this.name, "The distinction field has been removed, use luminanceMaterial.threshold and luminanceMaterial.smoothing instead."), 1
            }
            set distinction(n) {
                console.warn(this.name, "The distinction field has been removed, use luminanceMaterial.threshold and luminanceMaterial.smoothing instead.")
            }
            get intensity() {
                return this.uniforms.get("intensity").value
            }
            set intensity(n) {
                this.uniforms.get("intensity").value = n
            }
            getResolutionScale() {
                return this.resolution.scale
            }
            setResolutionScale(n) {
                this.resolution.scale = n
            }
            update(n, e, t) {
                let r = this.renderTarget;
                this.luminancePass.enabled ? (this.luminancePass.render(n, e, r), this.blurPass.render(n, r, r)) : this.blurPass.render(n, e, r)
            }
            setSize(n, e) {
                this.blurPass.setSize(n, e), this.renderTarget.setSize(this.resolution.width, this.resolution.height)
            }
            initialize(n, e, t) {
                this.blurPass.initialize(n, e, t), !e && t === Jr.UnsignedByteType && (this.renderTarget.texture.format = Jr.RGBFormat), t !== void 0 && (this.renderTarget.texture.type = t)
            }
        };
    var hb = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}",
        up = class extends Pi {
            constructor({
                blendFunction: n = et.NORMAL,
                brightness: e = 0,
                contrast: t = 0
            } = {}) {
                super("BrightnessContrastEffect", hb, {
                    blendFunction: n,
                    uniforms: new Map([
                        ["brightness", new ff.Uniform(e)],
                        ["contrast", new ff.Uniform(t)]
                    ])
                })
            }
        },
        mb = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float sum=inputColor.r+inputColor.g+inputColor.b;outputColor=vec4(vec3(sum/3.0),inputColor.a);}",
        fp = class extends Pi {
            constructor(n = et.NORMAL) {
                super("ColorAverageEffect", mb, {
                    blendFunction: n
                })
            }
        };
    var gb = `varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 color=inputColor;
#ifdef ALPHA
vec2 ra=texture2D(inputBuffer,vUvR).ra;vec2 ba=texture2D(inputBuffer,vUvB).ba;color.r=ra.x;color.b=ba.x;color.a=max(max(ra.y,ba.y),inputColor.a);
#else
color.r=texture2D(inputBuffer,vUvR).r;color.b=texture2D(inputBuffer,vUvB).b;
#endif
outputColor=color;}`,
        vb = "uniform vec2 offset;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vUvR=uv+offset;vUvB=uv-offset;}",
        dp = class extends Pi {
            constructor({
                blendFunction: n = et.NORMAL,
                offset: e = new $l.Vector2(.001, 5e-4)
            } = {}) {
                super("ChromaticAberrationEffect", gb, {
                    vertexShader: vb,
                    blendFunction: n,
                    attributes: ci.CONVOLUTION,
                    uniforms: new Map([
                        ["offset", new $l.Uniform(e)]
                    ])
                })
            }
            get offset() {
                return this.uniforms.get("offset").value
            }
            set offset(n) {
                this.uniforms.get("offset").value = n
            }
            initialize(n, e, t) {
                e ? this.defines.set("ALPHA", "1") : this.defines.delete("ALPHA")
            }
        };
    var yb = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float CoCNear=texture2D(nearCoCBuffer,uv).r;CoCNear=min(CoCNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,CoCNear);outputColor=result;}`,
        hp = class extends Pi {
            constructor(n, {
                blendFunction: e = et.NORMAL,
                focusDistance: t = 0,
                focalLength: r = .1,
                bokehScale: i = 1,
                width: s = _r.AUTO_SIZE,
                height: o = _r.AUTO_SIZE
            } = {}) {
                super("DepthOfFieldEffect", yb, {
                    blendFunction: e,
                    attributes: ci.DEPTH,
                    uniforms: new Map([
                        ["nearColorBuffer", new qt.Uniform(null)],
                        ["farColorBuffer", new qt.Uniform(null)],
                        ["nearCoCBuffer", new qt.Uniform(null)],
                        ["scale", new qt.Uniform(1)]
                    ])
                });
                this.camera = n, this.renderTarget = new qt.WebGLRenderTarget(1, 1, {
                    minFilter: qt.LinearFilter,
                    magFilter: qt.LinearFilter,
                    stencilBuffer: !1,
                    depthBuffer: !1
                }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTarget.texture.generateMipmaps = !1, this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.format = qt.RGBFormat, this.renderTargetCoC.texture.name = "DoF.CoC", this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture, this.cocPass = new Qi(new bA(n));
                let l = this.circleOfConfusionMaterial;
                l.uniforms.focusDistance.value = t, l.uniforms.focalLength.value = r, this.blurPass = new rp({
                    width: s,
                    height: o,
                    kernelSize: Ul.MEDIUM
                }), this.blurPass.resolution.resizable = this, this.maskPass = new Qi(new OA(this.renderTargetCoC.texture));
                let a = this.maskPass.getFullscreenMaterial();
                a.maskFunction = ep.MULTIPLY, a.colorChannel = Xm.GREEN, this.bokehNearBasePass = new Qi(new zl(!1, !0)), this.bokehNearFillPass = new Qi(new zl(!0, !0)), this.bokehFarBasePass = new Qi(new zl(!1, !1)), this.bokehFarFillPass = new Qi(new zl(!0, !1)), this.bokehScale = i, this.target = null
            }
            get circleOfConfusionMaterial() {
                return this.cocPass.getFullscreenMaterial()
            }
            get resolution() {
                return this.blurPass.resolution
            }
            get bokehScale() {
                return this.uniforms.get("scale").value
            }
            set bokehScale(n) {
                [this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass].map(t => t.getFullscreenMaterial().uniforms.scale).forEach(t => {
                    t.value = n
                }), this.maskPass.getFullscreenMaterial().uniforms.strength.value = n, this.uniforms.get("scale").value = n
            }
            calculateFocusDistance(n) {
                let e = this.camera,
                    t = e.far - e.near,
                    r = e.position.distanceTo(n);
                return Math.min(Math.max(r / t, 0), 1)
            }
            setDepthTexture(n, e = qt.BasicDepthPacking) {
                let t = this.circleOfConfusionMaterial;
                t.uniforms.depthBuffer.value = n, t.depthPacking = e
            }
            update(n, e, t) {
                let r = this.renderTarget,
                    i = this.renderTargetCoC,
                    s = this.renderTargetCoCBlurred,
                    o = this.renderTargetMasked,
                    l = this.bokehFarBasePass,
                    a = this.bokehFarFillPass,
                    c = l.getFullscreenMaterial().uniforms,
                    f = a.getFullscreenMaterial().uniforms,
                    h = this.bokehNearBasePass,
                    m = this.bokehNearFillPass,
                    v = h.getFullscreenMaterial().uniforms,
                    g = m.getFullscreenMaterial().uniforms;
                if (this.target !== null) {
                    let y = this.calculateFocusDistance(this.target);
                    this.circleOfConfusionMaterial.uniforms.focusDistance.value = y
                }
                this.cocPass.render(n, null, i), this.blurPass.render(n, i, s), this.maskPass.render(n, e, o), c.cocBuffer.value = f.cocBuffer.value = i.texture, l.render(n, o, r), a.render(n, r, this.renderTargetFar), v.cocBuffer.value = g.cocBuffer.value = s.texture, h.render(n, e, r), m.render(n, r, this.renderTargetNear)
            }
            setSize(n, e) {
                let t = this.resolution,
                    r = [this.cocPass, this.blurPass, this.maskPass, this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass];
                r.push(this.renderTargetCoC, this.renderTargetMasked), r.forEach(l => l.setSize(n, e));
                let i = t.width,
                    s = t.height;
                r = [this.renderTarget, this.renderTargetNear, this.renderTargetFar, this.renderTargetCoCBlurred], r.forEach(l => l.setSize(i, s)), [this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass].forEach(l => l.getFullscreenMaterial().setTexelSize(1 / i, 1 / s))
            }
            initialize(n, e, t) {
                [this.cocPass, this.maskPass, this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass].forEach(i => i.initialize(n, e, t)), this.blurPass.initialize(n, e, qt.UnsignedByteType), !e && t === qt.UnsignedByteType && (this.renderTargetNear.texture.type = qt.RGBFormat), t !== void 0 && (this.renderTarget.texture.type = t, this.renderTargetNear.texture.type = t, this.renderTargetFar.texture.type = t, this.renderTargetMasked.texture.type = t)
            }
        };
    var kO = new Ir.Vector3,
        UO = new Ir.Matrix4;
    var Ab = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}",
        gp = class extends Pi {
            constructor({
                blendFunction: n = et.NORMAL,
                hue: e = 0,
                saturation: t = 0
            } = {}) {
                super("HueSaturationEffect", Ab, {
                    blendFunction: n,
                    uniforms: new Map([
                        ["hue", new ga.Uniform(new ga.Vector3)],
                        ["saturation", new ga.Uniform(t)]
                    ])
                });
                this.setHue(e)
            }
            setHue(n) {
                let e = Math.sin(n),
                    t = Math.cos(n);
                this.uniforms.get("hue").value.set(2 * t, -Math.sqrt(3) * e - t, Math.sqrt(3) * e - t).addScalar(1).divideScalar(3)
            }
        };
    var jO = new Rr.Color;
    var bb = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`,
        vp = class extends Pi {
            constructor({
                blendFunction: n = et.SCREEN,
                premultiply: e = !1
            } = {}) {
                super("NoiseEffect", bb, {
                    blendFunction: n
                });
                this.premultiply = e
            }
            get premultiply() {
                return this.defines.has("PREMULTIPLY")
            }
            set premultiply(n) {
                this.premultiply !== n && (n ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged())
            }
        };
    var wb = "uniform bool active;uniform vec2 d;void mainUv(inout vec2 uv){if(active){uv=vec2(d.x*(floor(uv.x/d.x)+0.5),d.y*(floor(uv.y/d.y)+0.5));}}",
        yp = class extends Pi {
            constructor(n = 30) {
                super("PixelationEffect", wb, {
                    uniforms: new Map([
                        ["active", new Qs.Uniform(!1)],
                        ["d", new Qs.Uniform(new Qs.Vector2)]
                    ])
                });
                this.resolution = new Qs.Vector2, this.granularity = n
            }
            getGranularity() {
                return this.granularity
            }
            setGranularity(n) {
                n = Math.floor(n), n % 2 > 0 && (n += 1);
                let e = this.uniforms;
                e.get("active").value = n > 0, e.get("d").value.set(n, n).divide(this.resolution), this.granularity = n
            }
            setSize(n, e) {
                this.resolution.set(n, e), this.setGranularity(this.granularity)
            }
        };
    var VO = Math.PI * .5,
        HO = new va.Vector3,
        WO = new va.Vector3;
    var bp = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
        wp = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC",
        Nb = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}",
        Cb = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
        Sp = class extends Pi {
            constructor(n, e, t = qn.HIGH, r = Wl.COLOR) {
                super("SMAAEffect", Nb, {
                    vertexShader: Cb,
                    blendFunction: et.NORMAL,
                    attributes: ci.CONVOLUTION | ci.DEPTH,
                    uniforms: new Map([
                        ["weightMap", new Nt.Uniform(null)]
                    ])
                });
                this.renderTargetEdges = new Nt.WebGLRenderTarget(1, 1, {
                    minFilter: Nt.LinearFilter,
                    stencilBuffer: !1,
                    depthBuffer: !1,
                    format: Nt.RGBFormat
                }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.renderTargetWeights.texture.format = Nt.RGBAFormat, this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new af(!0, !1, !1), this.clearPass.overrideClearColor = new Nt.Color(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new Qi(new MA(new Nt.Vector2, r)), this.weightsPass = new Qi(new GA);
                let i = new Nt.Texture(n);
                i.name = "SMAA.Search", i.magFilter = Nt.NearestFilter, i.minFilter = Nt.NearestFilter, i.format = Nt.RGBAFormat, i.generateMipmaps = !1, i.needsUpdate = !0, i.flipY = !0;
                let s = new Nt.Texture(e);
                s.name = "SMAA.Area", s.magFilter = Nt.LinearFilter, s.minFilter = Nt.LinearFilter, s.format = Nt.RGBAFormat, s.generateMipmaps = !1, s.needsUpdate = !0, s.flipY = !1;
                let o = this.weightsPass.getFullscreenMaterial();
                o.uniforms.searchTexture.value = i, o.uniforms.areaTexture.value = s, this.applyPreset(t)
            }
            get edgeDetectionMaterial() {
                return this.edgeDetectionPass.getFullscreenMaterial()
            }
            get colorEdgesMaterial() {
                return this.edgeDetectionMaterial
            }
            get weightsMaterial() {
                return this.weightsPass.getFullscreenMaterial()
            }
            setEdgeDetectionThreshold(n) {
                this.edgeDetectionPass.getFullscreenMaterial().setEdgeDetectionThreshold(n)
            }
            setOrthogonalSearchSteps(n) {
                this.weightsPass.getFullscreenMaterial().setOrthogonalSearchSteps(n)
            }
            applyPreset(n) {
                let e = this.edgeDetectionMaterial,
                    t = this.weightsMaterial;
                switch (n) {
                    case qn.LOW:
                        e.setEdgeDetectionThreshold(.15), t.setOrthogonalSearchSteps(4), t.diagonalDetection = !1, t.cornerRounding = !1;
                        break;
                    case qn.MEDIUM:
                        e.setEdgeDetectionThreshold(.1), t.setOrthogonalSearchSteps(8), t.diagonalDetection = !1, t.cornerRounding = !1;
                        break;
                    case qn.HIGH:
                        e.setEdgeDetectionThreshold(.1), t.setOrthogonalSearchSteps(16), t.setDiagonalSearchSteps(8), t.setCornerRounding(25), t.diagonalDetection = !0, t.cornerRounding = !0;
                        break;
                    case qn.ULTRA:
                        e.setEdgeDetectionThreshold(.05), t.setOrthogonalSearchSteps(32), t.setDiagonalSearchSteps(16), t.setCornerRounding(25), t.diagonalDetection = !0, t.cornerRounding = !0;
                        break
                }
            }
            setDepthTexture(n, e = Nt.BasicDepthPacking) {
                let t = this.edgeDetectionMaterial;
                t.uniforms.depthBuffer.value = n, t.depthPacking = e
            }
            update(n, e, t) {
                this.clearPass.render(n, this.renderTargetEdges), this.edgeDetectionPass.render(n, e, this.renderTargetEdges), this.weightsPass.render(n, this.renderTargetEdges, this.renderTargetWeights)
            }
            setSize(n, e) {
                let t = this.edgeDetectionPass.getFullscreenMaterial(),
                    r = this.weightsPass.getFullscreenMaterial();
                this.renderTargetEdges.setSize(n, e), this.renderTargetWeights.setSize(n, e), r.uniforms.resolution.value.set(n, e), r.uniforms.texelSize.value.set(1 / n, 1 / e), t.uniforms.texelSize.value.copy(r.uniforms.texelSize.value)
            }
            dispose() {
                let n = this.weightsPass.getFullscreenMaterial().uniforms;
                n.searchTexture.value.dispose(), n.areaTexture.value.dispose(), super.dispose()
            }
            static get searchImageDataURL() {
                return bp
            }
            static get areaImageDataURL() {
                return wp
            }
        },
        qn = {
            LOW: 0,
            MEDIUM: 1,
            HIGH: 2,
            ULTRA: 3
        };
    var Tb = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#ifdef ESKIL
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#else
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#endif
outputColor=vec4(color,inputColor.a);}`,
        Np = class extends Pi {
            constructor(n = {}) {
                let e = Object.assign({
                    blendFunction: et.NORMAL,
                    eskil: !1,
                    offset: .5,
                    darkness: .5
                }, n);
                super("VignetteEffect", Tb, {
                    blendFunction: e.blendFunction,
                    uniforms: new Map([
                        ["offset", new df.Uniform(e.offset)],
                        ["darkness", new df.Uniform(e.darkness)]
                    ])
                });
                this.eskil = e.eskil
            }
            get eskil() {
                return this.defines.has("ESKIL")
            }
            set eskil(n) {
                this.eskil !== n && (n ? this.defines.set("ESKIL", "1") : this.defines.delete("ESKIL"), this.setChanged())
            }
        },
        JO = [new Float32Array(3), new Float32Array(3)],
        QO = [new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3)],
        YO = [
            [new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1])],
            [new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1])],
            [new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1])],
            [new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1])],
            [new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1])],
            [new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1])]
        ];
    var KO = [new Float32Array(2), new Float32Array(2)];
    var XO = new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]),
        qO = [new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125])],
        ZO = [new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4])],
        $O = [new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3])];
    var eR = new Map([
        [sr(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])],
        [sr(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])],
        [sr(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])],
        [sr(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])],
        [sr(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])],
        [sr(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])],
        [sr(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])],
        [sr(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])],
        [sr(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])],
        [sr(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])],
        [sr(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])],
        [sr(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])],
        [sr(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])],
        [sr(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])],
        [sr(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])],
        [sr(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]
    ]);

    function hf(n, e, t) {
        return n + (e - n) * t
    }

    function sr(n, e, t, r) {
        let i = hf(n, e, 1 - .25),
            s = hf(t, r, 1 - .25);
        return hf(i, s, 1 - .125)
    }
    var Cp = class extends tc.Loader {
        load(n = () => {}, e = null) {
            arguments.length === 4 ? (n = arguments[1], e = arguments[3]) : (arguments.length === 3 || typeof arguments[0] != "function") && (n = arguments[1], e = null);
            let t = this.manager,
                r = new tc.LoadingManager;
            return new Promise((i, s) => {
                let o = new Image,
                    l = new Image;
                r.onError = a => {
                    t.itemError(a), e !== null ? (e(`Failed to load ${a}`), i()) : s(`Failed to load ${a}`)
                }, r.onLoad = () => {
                    let a = [o, l];
                    n(a), i(a)
                }, o.addEventListener("error", a => {
                    r.itemError("smaa-search")
                }), l.addEventListener("error", a => {
                    r.itemError("smaa-area")
                }), o.addEventListener("load", () => {
                    t.itemEnd("smaa-search"), r.itemEnd("smaa-search")
                }), l.addEventListener("load", () => {
                    t.itemEnd("smaa-area"), r.itemEnd("smaa-area")
                }), t.itemStart("smaa-search"), t.itemStart("smaa-area"), r.itemStart("smaa-search"), r.itemStart("smaa-area"), o.src = bp, l.src = wp
            })
        }
    };
    var fr = W(J());
    var Ft = class {
        constructor(e, t) {
            this.enabled = !1;
            this.effect = new e(t), Object.defineProperty(this, "opacity", {
                enumerable: !0,
                set(r) {
                    this.effect.blendMode.opacity.value = r
                },
                get() {
                    return this.effect.blendMode.opacity.value
                }
            }), Object.defineProperty(this, "blendFunction", {
                enumerable: !0,
                set(r) {
                    this.effect.blendMode.setBlendFunction(Number(r))
                },
                get() {
                    return this.effect.blendMode.blendFunction
                }
            }), this.blendFunction = et.NORMAL
        }
        toJSON() {
            let e = ["constructor", "effect", "subscriptions"],
                t = Ne({}, this),
                r = Object.getPrototypeOf(this),
                i = Object.getOwnPropertyNames(r);
            for (let s of i) {
                let o = Object.getOwnPropertyDescriptor(r, s);
                o && typeof o.get == "function" && (t[s] = this[s])
            }
            return e.forEach(s => delete t[s]), t
        }
    };
    var Aa = class extends Ft {
        constructor() {
            super(cp);
            this.blendFunction = et.SCREEN
        }
        set intensity(e) {
            this.effect.intensity = e
        }
        get intensity() {
            return this.effect.intensity
        }
        set luminanceThreshold(e) {
            this.effect.luminanceMaterial.threshold = e
        }
        get luminanceThreshold() {
            return this.effect.luminanceMaterial.threshold
        }
        set luminanceSmoothing(e) {
            this.effect.luminanceMaterial.smoothing = e
        }
        get luminanceSmoothing() {
            return this.effect.luminanceMaterial.smoothing
        }
        set blurScale(e) {
            this.effect.blurPass.scale = e
        }
        get blurScale() {
            return this.effect.blurPass.scale
        }
        set kernelSize(e) {
            this.effect.blurPass.kernelSize = e
        }
        get kernelSize() {
            return this.effect.blurPass.kernelSize
        }
    };
    var ba = class extends Ft {
        constructor() {
            super(up)
        }
        set contrast(e) {
            this.effect.uniforms.get("contrast").value = e
        }
        get contrast() {
            return this.effect.uniforms.get("contrast").value
        }
        set brightness(e) {
            this.effect.uniforms.get("brightness").value = e
        }
        get brightness() {
            return this.effect.uniforms.get("brightness").value
        }
    };
    var Tp = W(J());
    var wa = class extends Ft {
        constructor() {
            super(dp);
            this.effect.offset = new Tp.Vector2(.01, .01)
        }
        set offset(e) {
            this.effect.offset.set(e[0] / 1e3, e[1] / 1e3)
        }
        get offset() {
            return [this.effect.offset.x * 1e3, this.effect.offset.y * 1e3]
        }
    };
    var Sa = class extends Ft {
        constructor() {
            super(fp)
        }
    };
    var Na = class extends Ft {
        constructor() {
            super(gp);
            this._hue = 0
        }
        set hue(e) {
            this._hue = e, this.effect.setHue(e)
        }
        get hue() {
            return this._hue
        }
        set saturation(e) {
            this.effect.uniforms.get("saturation").value = e
        }
        get saturation() {
            return this.effect.uniforms.get("saturation").value
        }
    };
    var Ca = class extends Ft {
        constructor() {
            super(vp);
            this.blendFunction = et.OVERLAY
        }
    };
    var Ta = class extends Ft {
        constructor() {
            super(Np)
        }
        get eskil() {
            return this.effect.eskil
        }
        set eskil(e) {
            this.effect.eskil = e
        }
        get darkness() {
            return this.effect.uniforms.get("darkness").value
        }
        set darkness(e) {
            this.effect.uniforms.get("darkness").value = e
        }
        get offset() {
            return this.effect.uniforms.get("offset").value
        }
        set offset(e) {
            this.effect.uniforms.get("offset").value = e
        }
    };
    var Ea = class extends Ft {
        constructor(e) {
            super(hp, e)
        }
        set focalLength(e) {
            this.effect.circleOfConfusionMaterial.uniforms.focalLength.value = e
        }
        get focalLength() {
            return this.effect.circleOfConfusionMaterial.uniforms.focalLength.value
        }
        set focusDistance(e) {
            this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value = e
        }
        get focusDistance() {
            return this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value
        }
        get bokehScale() {
            return this.effect.bokehScale
        }
        set bokehScale(e) {
            this.effect.bokehScale = e
        }
    };
    var Ma = class extends Ft {
        constructor() {
            super(yp)
        }
        get granularity() {
            return this.effect.getGranularity()
        }
        set granularity(e) {
            this.effect.setGranularity(e)
        }
    };

    function Ep(n, e) {
        return e && e.enabled && n.push(e.effect), n
    }
    var _a = class {
        constructor() {
            this._scene = new fr.Scene;
            this._camera = new Un;
            this.effects = new Map;
            this.loadingManager = new fr.LoadingManager;
            this.smaaImageLoader = new Cp(this.loadingManager);
            this.renderPass = new Ql;
            this.depthPass = new cf;
            this._renderToScreen = !0;
            this.clock = new fr.Clock, this.enabled = !1, this.debug = !1, this.effects.set("bloom", new Aa), this.effects.set("chromaticAberration", new wa), this.effects.set("vignette", new Ta), this.effects.set("noise", new Ca), this.effects.set("colorAverage", new Sa), this.effects.set("hueSaturation", new Na), this.effects.set("brightnessContrast", new ba), this.effects.set("depthOfField", new Ea), this.effects.set("pixelation", new Ma)
        }
        get scene() {
            return this._scene
        }
        set scene(e) {
            this._scene = e, this._initPasses()
        }
        get camera() {
            return this._camera
        }
        set camera(e) {
            this._camera = e, this._initPasses()
        }
        _initSmaa() {
            let e = this.effectComposer.passes.length;
            this.smaaImageLoader.load(([t, r]) => {
                if (!this.effectComposer) return;
                let i = new Sp(t, r, qn.ULTRA, Wl.COLOR);
                i.edgeDetectionMaterial.setPredicationMode($m.DEPTH), i.edgeDetectionMaterial.setEdgeDetectionThreshold(.05), i.edgeDetectionMaterial.setPredicationThreshold(.002), i.edgeDetectionMaterial.setPredicationScale(1), this.effectComposer.addPass(new Zl(this.camera, i), e)
            })
        }
        _initPasses() {
            if (!(!this.effectComposer || !this.renderer))
                if (this.effectComposer.removeAllPasses(), this.renderPass = new Ql(this.scene, this.camera), this.enabled) {
                    this.depthPass = new cf(this.scene, this.camera), this.effectComposer.addPass(this.renderPass), this.effectComposer.addPass(this.depthPass), this._initSmaa();
                    let e = [this.effects.get("chromaticAberration"), this.effects.get("bloom"), this.effects.get("colorAverage"), this.effects.get("hueSaturation"), this.effects.get("brightnessContrast"), this.effects.get("vignette"), this.effects.get("noise")].reduce(Ep, []),
                        t = [this.effects.get("pixelation")].reduce(Ep, []);
                    t.length > 0 && this.effectComposer.addPass(new Zl(this.camera, ...t)), this.effectComposer.addPass(new Zl(this.camera, ...e))
                } else this.effectComposer.addPass(this.renderPass)
        }
        reinit() {
            !this.renderer || (this.effectComposer = new lp(this.renderer), this._initPasses())
        }
        init({
            renderer: e,
            camera: t,
            scene: r
        }) {
            this.renderer = e, this.scene = r, this.camera = t, this._initSavePass(), this.reinit()
        }
        _initSavePass() {
            if (this._savePass) return;
            let e = new fr.Vector2;
            this.renderer.getDrawingBufferSize(e);
            let t = this.renderer.capabilities.isWebGL2 ? fr.WebGLMultisampleRenderTarget : fr.WebGLRenderTarget;
            this._rt = new t(e.x, e.y, {
                depthBuffer: !1,
                stencilBuffer: !1,
                wrapS: fr.RepeatWrapping,
                wrapT: fr.RepeatWrapping
            }), this._savePass = new tp(this._rt, !1), this._savePass.renderToScreen = !1
        }
        get renderToScreen() {
            return this._renderToScreen
        }
        set renderToScreen(e) {
            let t = this.effectComposer;
            !t || (e === !0 ? (this.renderer?.capabilities.isWebGL2 && (t.multisampling = 0), t.removePass(this._savePass), t.passes[t.passes.length - 1].renderToScreen = !0, t.autoRenderToScreen = !0) : (this.renderer?.capabilities.isWebGL2 && (t.multisampling = 4), t.autoRenderToScreen = !1, t.passes[t.passes.length - 1].renderToScreen = !1, this._savePass.renderToScreen = !1, t.addPass(this._savePass)), this._renderToScreen = e)
        }
        get texture() {
            return this._rt && this._rt.texture
        }
        fromJSON(e) {
            e && (Object.keys(e).forEach(t => {
                let r = e[t],
                    i = this.effects.get(t);
                Object.keys(r).forEach(s => {
                    i[s] = r[s]
                })
            }), this.enabled = e.enabled)
        }
        toJSON() {
            let e = {};
            return this.effects.forEach((t, r) => {
                e[r] = t.toJSON()
            }, e), Ne({
                enabled: this.enabled
            }, e)
        }
        render() {
            this.effectComposer?.render(this.clock.getDelta())
        }
        resize(e, t) {
            if (this.effectComposer?.setSize(e, t), this._rt) {
                let r = this.renderer?.getPixelRatio() || window.devicePixelRatio;
                this._rt.setSize(e * r, t * r)
            }
        }
    };
    var Ks = class extends Il(Jt.Scene) {
        constructor() {
            super();
            this.objectType = "Scene";
            this.alpha = 1;
            this.backupFog = new Jt.Fog(16777215, .1, 2e3);
            this.fogUseBGColor = !1;
            this.directionalLightState = !0;
            this.ambientLightState = !0;
            this.wireframeState = !1;
            this._color = new Jt.Color(1644825);
            this.canvas = {
                mode: 1,
                preset: "fullscreen",
                size: {
                    width: 512,
                    height: 512
                },
                editorSize: {
                    width: 1,
                    height: 1
                },
                color: [0, 0, 0, .5]
            };
            this.name = "Untitled"
        }
        get color() {
            return this._color
        }
        set color(e) {
            this.fogUseBGColor === !0 && this.backupFog.color.copy(e), this._color.copy(e)
        }
        get enableFog() {
            return this.fog !== null
        }
        set enableFog(e) {
            this.fog = e === !0 ? this.backupFog : null
        }
        init(e, t) {
            this.camera = new Un(e, t), this.camera.setDefault(), this.camera.orthoCamera.near = -5e4, this.camera.perspCamera.near = 50, this.camera.orthoCamera.far = 1e5, this.camera.perspCamera.far = 1e5, this.camera.updateProjectionMatrix(), this.camera.position.set(0, 0, this.camera.targetOffset), this.camera.lookAt(new Jt.Vector3(0, 0, -1)), this.add(this.camera), this.canvas.size.width = e, this.canvas.size.height = t, this.ambientLight = new Jt.HemisphereLight(13882323, 8553090, .75), this.ambientLight.name = "Default Ambient Light", this.add(this.ambientLight), this.directionalLight = new Jt.DirectionalLight(16777215, .75), this.directionalLight.name = "Default Directional Light", this.directionalLight.position.set(85e4, 13e5, 1e6), this.activeCamera = this.camera, this.activeCamera.add(this.directionalLight), this.postprocessing = new _a
        }
        initFromObjectLoader(e) {
            return this.traverse(t => {
                t.uuid === e.ambientLight ? this.ambientLight = t : t.uuid === e.directionalLight ? this.directionalLight = t : (t.uuid === e.activeCamera && (this.activeCamera = t), t.uuid === e.camera && (this.camera = t, this.camera.setDefault()))
            }), this
        }
        raycast(e) {
            let t = [],
                r = i => {
                    for (let s of i.children) Sr(s) && !s.raycastLock && s.visible && ((br(s) || bl(s) && s.enableHelper) && e.intersectObject(s, !1, t), r(s))
                };
            return r(this), t
        }
        traverseEntity(e) {
            for (let t of this.children) Sr(t) && this.camera !== t && t.traverseEntity(e)
        }
        toJSON(e) {
            let t = super.toJSON(e),
                r = t.object;
            return r.objectType = "Scene", r.activeCamera = this.activeCamera?.uuid, r.camera = this.camera?.uuid, r.directionalLight = this.directionalLight?.uuid, r.ambientLight = this.ambientLight?.uuid, r.color = this.color.toArray(), r.alpha = this.alpha, this.background instanceof Jt.Texture ? r.background = this.background.toJSON(e) : this.background instanceof Jt.Color && (r.background = this.background.toArray()), this.environment !== null && (r.environment = this.environment.toJSON(e)), this.enableFog === !0 && (r.enableFog = !0, this.fogUseBGColor === !0 && (r.fogUseBGColor = !0), this.fog !== null && (r.fog = this.fog.toJSON())), this.directionalLightState === !0 && (r.directionalLightState = !0), this.ambientLightState === !0 && (r.ambientLightState = !0), this.wireframeState === !0 && (r.wireframeState = !0), r.canvas = {
                mode: this.canvas.mode,
                preset: this.canvas.preset,
                editorSize: {
                    width: window.innerWidth,
                    height: window.innerHeight
                },
                color: this.canvas.color
            }, this.canvas.mode !== 1 && (r.canvas.size = {
                width: this.canvas.size.width,
                height: this.canvas.size.height
            }), r.postprocessing = this.postprocessing?.toJSON(), t
        }
        fromJSON(e) {
            super.fromJSON(e), this.postprocessing = new _a, this.color.fromArray(e.color), this.alpha = e.alpha, e.background !== void 0 && Array.isArray(e.background) && (this.background = new Jt.Color().fromArray(e.background)), e.fog !== void 0 && (e.fog.type === "FogExp2" ? this.backupFog = new Jt.FogExp2(e.fog.color, e.fog.density) : this.backupFog = new Jt.Fog(e.fog.color, e.fog.near, e.fog.far)), this.fogUseBGColor = e.fogUseBGColor ?? !1, this.enableFog = e.enableFog ?? !1, this.directionalLightState = e.directionalLightState ?? !1, this.ambientLightState = e.ambientLightState ?? !1, this.wireframeState = e.wireframeState ?? !1;
            let t = e.canvas;
            return this.canvas.mode = t.mode, t.size && (this.canvas.size = {
                width: t.size.width,
                height: t.size.height
            }), this.canvas.editorSize = t.editorSize ? {
                width: t.editorSize.width,
                height: t.editorSize.height
            } : {
                width: window.innerWidth,
                height: window.innerHeight
            }, t.color && (this.canvas.color = [...t.color]), this.postprocessing.fromJSON(e.postprocessing), this
        }
        dispose() {
            this.traverseEntity(e => {
                "geometry" in e && e.geometry.dispose(), "material" in e && (e.material instanceof Array ? e.material.forEach(t => t.dispose()) : e.material.dispose())
            })
        }
    };
    var Ip = W(J());
    var mf = class extends _e {
        constructor(e = "", t) {
            super(t);
            this.nodeType = "Attribute";
            this.name = e
        }
        getAttributeType(e) {
            return typeof this.type == "number" ? e.getConstructorFromLength(this.type) : this.type
        }
        getType(e) {
            let t = this.getAttributeType(e);
            return e.getTypeByFormat(t)
        }
        generate(e, t, r, i, s) {
            i = this.getAttributeType(e);
            let o = e.getAttribute(this.name, i),
                l = e.isShader("vertex") ? this.name : o.varying.name;
            return e.format(l, this.getType(e), t)
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return t.nodeType = this.nodeType, t.name = this.name, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.scope && (this.scope = e.scope), e.name && (this.name = e.name), this
        }
    };
    var pf = class extends we {
        constructor(e = "", t = 0) {
            super(e);
            this.nodeType = "Varying";
            this.value = t
        }
        getType(e) {
            return e.getTypeByFormat(this.type)
        }
        generate(e, t, r, i, s) {
            let o = e.getVar(this.uuid, this.type);
            return this.value && e.isShader("vertex") && e.addNodeCode(o.name + " = " + this.value.build(e, this.getType(e)) + ";"), e.format(o.name, this.getType(e), t)
        }
        copy(e) {
            return super.copy(e), this.value = e.value, this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), this.value && (t.value = this.value)), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.value && (this.value = e.value), this
        }
    };
    var Mp = W(J());
    var gf = class extends At {
        constructor(e) {
            super("m4");
            this.nodeType = "Matrix4";
            this.value = e ?? new Mp.Matrix4
        }
        generateReadonly(e, t, r, i, s, o) {
            return e.format("mat4(" + this.value.elements.join(", ") + ")", i, t)
        }
        copy(e) {
            return super.copy(e), this.elements = e.elements, this
        }
        toJSON(e) {
            let t = this.getJSONNode(e);
            return t || (t = this.createJSONNode(e), t.elements = this.value.elements.concat()), t.nodeType = this.nodeType, t
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t), e.elements && (this.elements = e.elements), this
        }
        get elements() {
            return this.value.elements
        }
        set elements(e) {
            this.value.fromArray(e)
        }
    };
    var Bi;
    (function(a) {
        a.EQUAL = "==", a.NOT_EQUAL = "!=", a.GREATER = ">", a.GREATER_EQUAL = ">=", a.LESS = "<", a.LESS_EQUAL = "<=", a.AND = "&&", a.OR = "||"
    })(Bi || (Bi = {}));
    var vf = class extends _e {
            constructor(e = new we, t = new we, r = vf.GREATER, i = new we, s = new we) {
                super();
                this.nodeType = "Cond";
                this.a = e, this.b = t, this.op = r, this.ifNode = i, this.elseNode = s
            }
            getType(e) {
                if (this.ifNode) {
                    let t = this.ifNode.getType(e),
                        r = this.elseNode.getType(e);
                    return e.getTypeLength(r) > e.getTypeLength(t) ? r : t
                }
                return "b"
            }
            getCondType(e) {
                return e.getTypeLength(this.b.getType(e)) > e.getTypeLength(this.a.getType(e)) ? this.b.getType(e) : this.a.getType(e)
            }
            generate(e, t) {
                let r = this.getType(e),
                    i = this.getCondType(e),
                    s = this.a.build(e, i),
                    o = this.b.build(e, i),
                    l;
                if (this.type = r, this.ifNode) {
                    let a = this.ifNode.build(e, r),
                        c = this.elseNode.build(e, r);
                    l = "( " + [s, this.op, o, "?", a, ":", c].join(" ") + " )"
                } else l = "( " + s + " " + this.op + " " + o + " )";
                return e.format(l, this.getType(e), t)
            }
            copy(e) {
                return super.copy(e), this.a.copy(e.a), this.b.copy(e.b), this.op = e.op, this.ifNode.copy(e.ifNode), this.elseNode.copy(e.elseNode), this
            }
            toJSON(e) {
                let t = this.getJSONNode(e);
                return t || (t = this.createJSONNode(e), t.a = this.a.toJSON(e).uuid, t.b = this.b.toJSON(e).uuid, t.op = this.op, this.ifNode && (t.ifNode = this.ifNode.toJSON(e).uuid), this.elseNode && (t.elseNode = this.elseNode.toJSON(e).uuid)), t.nodeType = this.nodeType, t
            }
            fromJSON(e, t) {
                return super.fromJSON(e, t), e.a && (this.a = t.getNode(e.a)), e.b && (this.b = t.getNode(e.b)), e.op && (this.op = e.op), e.ifNode && (this.ifNode = t.getNode(e.ifNode)), e.elseNode && (this.elseNode = t.getNode(e.elseNode)), this
            }
        },
        fi = vf;
    fi.EQUAL = Bi.EQUAL, fi.NOT_EQUAL = Bi.NOT_EQUAL, fi.GREATER = Bi.GREATER, fi.GREATER_EQUAL = Bi.GREATER_EQUAL, fi.LESS = Bi.LESS, fi.LESS_EQUAL = Bi.LESS_EQUAL, fi.AND = Bi.AND, fi.OR = Bi.OR;
    var _p = {
        Int: Qe,
        Float: ve,
        Bool: wo,
        Vector2: ei,
        Vector3: gr,
        Vector4: No,
        Matrix3: ki,
        Matrix4: gf,
        FloatArray: ds,
        Vector4Array: fs,
        Normal: jt,
        Position: Qt,
        Reflect: ti,
        UV: Tn,
        Attribute: mf,
        Const: Ve,
        Struct: In,
        Varying: pf,
        SpecularMIPLevel: Pn,
        MaxMIPLevel: _s,
        ColorSpace: St,
        Noise: bs,
        TextureCubeUV: Ln,
        TextureCube: Co,
        Operator: or,
        Math: Pe,
        Cond: fi,
        Fresnel: gs,
        Rainbow: ys,
        Depth: Ns,
        Blend: Ss,
        Raw: Es,
        CubeTexture: To,
        Texture: yr,
        CustomTexture: ps,
        VertexDisplacement: _n,
        CustomNormal: xs,
        Gradient: As,
        Matcap: Cs,
        Expression: Ye,
        Color: qe,
        Phong: _o,
        Basic: Eo,
        Lambert: Lo,
        Standard: Ro,
        Toon: Bo
    };
    var rc = class {
        constructor() {
            this._nodes = {};
            this._dataNodes = {};
            this._textures = {};
            this.uuid = Ip.MathUtils.generateUUID()
        }
        init(e, t) {
            this._dataNodes = e, this._textures = t
        }
        clear() {
            this._nodes = {}, this._dataNodes = {}, this._textures = {}
        }
        getNode(e) {
            let t = this._nodes[e];
            return t || (t = this.createNode(e)), t
        }
        getNodeData(e) {
            return this._dataNodes[e]
        }
        getTexture(e) {
            let t = this._textures[e];
            if (!t) throw new Error("This texture does not exist in the library " + e);
            return t
        }
        createNode(e) {
            let t = this._dataNodes[e];
            if (!t) throw new Error("Failed to create Node from uuid: " + e + ", its data does not seem to exist");
            let r = _p[t.nodeType];
            if (!r) throw new Error("Failed to create Node from uuid: " + e + " and nodeType: " + t.nodeType + ", constructor for this not is not registered");
            let i = new r().fromJSON(t, this);
            return this._nodes[e] = i, i
        }
    };
    var co = W(J());
    var $n = W(J());

    function Lp(n) {
        Mb(n.geometries), _b(n.interactionStates), Dp(n.object), Ib(n.materials)
    }

    function Mb(n) {
        if (n !== void 0) {
            for (let e of n)
                if (e.userData?.type !== void 0) {
                    let t = e.userData.parameters;
                    "extrudeDepth" in t || Object.assign(t, {
                        extrudeDepth: 0
                    }), "extrudeBevelSize" in t || Object.assign(t, {
                        extrudeBevelSize: 0
                    }), "extrudeBevelSegments" in t || Object.assign(t, {
                        extrudeBevelSegments: 1
                    })
                }
        }
    }

    function _b(n) {
        if (n !== void 0) {
            for (let e of n)
                if (e.quaternion !== void 0) {
                    let t = new $n.Quaternion().fromArray(e.quaternion);
                    Object.assign(e, {
                        rotation: new $n.Euler().setFromQuaternion(t).toArray()
                    })
                }
        }
    }

    function Dp(n) {
        if (n.userData?.type === void 0)
            if (n.type === "OrthographicCamera" || n.type === "PerspectiveCamera") {
                let e = n;
                Object.assign(n, {
                    objectType: "CombinedCamera",
                    cameraType: e.type,
                    isDefaultCamera: !0,
                    hiddenMatrix: new $n.Matrix4().toArray(),
                    name: "Default Camera",
                    far: 1e5,
                    zoomOrtho: e.zoom,
                    zoomPersp: 1,
                    nearOrtho: -5e4,
                    nearPersp: 50
                }), delete n.type, e.typeCamera !== void 0 && (Object.assign(n, {
                    cameraType: e.typeCamera
                }), delete n.typeCamera)
            } else n.type === "Scene" ? (Object.assign(n, {
                objectType: n.type
            }), delete n.type) : n.type === "HemisphereLight" ? Object.assign(n, {
                isDefaultAmbientLight: !0
            }) : n.type === "DirectionalLight" && Object.assign(n, {
                isDefaultDirectionalLight: !0
            });
        if (n.userData !== void 0) {
            let e = n.userData;
            e.type !== void 0 && (Object.assign(n, {
                objectType: e.type
            }), delete e.type), e.interaction !== void 0 && (Object.assign(n, {
                interaction: e.interaction
            }), delete e.interaction), e.isDefaultAmbientLight === !0 ? (Object.assign(n, {
                isDefaultAmbientLight: !0
            }), delete e.isDefaultAmbientLight) : e.isDefaultDirectionalLight === !0 ? (Object.assign(n, {
                isDefaultDirectionalLight: !0
            }), delete e.isDefaultDirectionalLight) : e.isDefaultCamera === !0 && (Object.assign(n, {
                isDefaultCamera: !0
            }), delete e.isDefaultCamera), Object.assign(n, {
                raycastLock: e.lock,
                scaleLock: e.scaleLock,
                hiddenMatrix: e.hiddenMatrix?.elements ?? new $n.Matrix4().toArray()
            }), delete e.lock, delete e.scaleLock, delete e.hiddenMatrix, delete e.isEntity
        }
        if (n.interaction?.events !== void 0) {
            for (let e of n.interaction.events)
                if (e.targets !== void 0)
                    for (let t of e.targets) t.springControls !== void 0 && (Object.assign(t, {
                        springParameters: {
                            mass: t.springControls[0],
                            stiffness: t.springControls[1],
                            damping: t.springControls[2],
                            velocity: t.springControls[3]
                        }
                    }), delete t.springControls)
        }
        if (n.children !== void 0)
            for (let e of n.children) Dp(e)
    }

    function Ib(n) {
        if (n !== void 0)
            for (let e of n) {
                let r = e.userData.layers.head;
                for (; r;) {
                    for (let i in r.uniforms) {
                        let s = `f${r.id}_tex`,
                            o = `f${r.id}_texture`;
                        i === s && (r.uniforms[o] = r.uniforms[s], delete r.uniforms[s])
                    }
                    r = r.next
                }
            }
    }

    function Pp(n) {
        Bp(n.object, n.object)
    }

    function Bp(n, e) {
        if (n.type === "HemisphereLight" || n.isDefaultAmbientLight === !0 ? e.ambientLight = n.uuid : n.userData?.isDefaultDirectionalLight === !0 || n.isDefaultDirectionalLight === !0 ? e.directionalLight = n.uuid : n.isDefaultCamera === !0 && (e.camera = n.uuid, e.activeCamera = n.uuid, Object.assign(n, {
                name: "Default Camera"
            })), n.children !== void 0)
            for (let t of n.children) Bp(t, e)
    }
    var Op = W(J());

    function Rp(n) {
        Lb(n.object)
    }

    function Lb(n) {
        if (n.objectType === "Scene") {
            let e = n.userData,
                t = e.rgb ?? {
                    r: 25,
                    g: 25,
                    b: 25
                },
                r = e.fogColor ?? {
                    r: 25,
                    g: 25,
                    b: 25
                };
            Object.assign(n, {
                color: [t.r / 255, t.g / 255, t.b / 255],
                alpha: e.alpha,
                enableFog: e.fogEnable,
                fogUseBGColor: e.fogUseBGColor,
                fog: {
                    color: new Op.Color().setRGB(r.r / 255, r.g / 255, r.b / 255).getHex(),
                    near: e.fogNear,
                    far: e.fogFar
                },
                directionalLightState: e.directionalLightState,
                ambientLightState: e.ambientLightState,
                shadowsState: e.shadowsState,
                wireframeState: e.wireframeState,
                canvas: {
                    mode: e.canvasMode ?? 1,
                    size: {
                        width: e.canvasCustomSize?.width ?? 512,
                        height: e.canvasCustomSize?.height ?? 512
                    }
                }
            }), delete e.rgb, delete e.alpha, delete e.fogEnable, delete e.fogUseBGColor, delete e.fogColor, delete e.fogNear, delete e.fogFar, delete e.directionalLightState, delete e.ambientLightState, delete e.shadowsState, delete e.wireframeState, delete e.canvasMode, delete e.canvasFullScreen, delete e.canvasCustomSize
        }
    }
    var Xi = W(J());
    var Lr = W(J());

    function Fp(n) {
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "b",
            value: n,
            nodeType: "Bool"
        }
    }

    function Fr(n, e) {
        let t = new Lr.Color().set(n);
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "c",
            r: t.r,
            g: t.g,
            b: t.b,
            value: n,
            alpha: e?.uuid,
            nodeType: "Color"
        }
    }

    function Gp(n, e) {
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "f[]",
            size: n,
            value: e,
            nodeType: "FloatArray"
        }
    }

    function ut(n) {
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "f",
            value: n,
            nodeType: "Float"
        }
    }

    function Bt(n) {
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "i",
            value: n,
            nodeType: "Int"
        }
    }

    function Xs(n) {
        let {
            x: e,
            y: t
        } = n;
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "v2",
            x: e,
            y: t,
            nodeType: "Vector2"
        }
    }

    function yf(n) {
        let {
            x: e,
            y: t,
            z: r
        } = n;
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "v3",
            x: e,
            y: t,
            z: r,
            nodeType: "Vector3"
        }
    }

    function zp(n, e) {
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "v4[]",
            size: n,
            value: e,
            nodeType: "Vector4Array"
        }
    }

    function kp(n) {
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "m3",
            elements: n.elements,
            nodeType: "Matrix3"
        }
    }

    function Up(n, e) {
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "v4",
            value: n,
            uv: e.uuid,
            project: !1,
            nodeType: "Texture"
        }
    }

    function jp(n) {
        return {
            uuid: Lr.MathUtils.generateUUID(),
            type: "v2",
            index: n,
            nodeType: "UV"
        }
    }

    function xf(n, e) {
        let t = {
            uuid: Xi.MathUtils.generateUUID(),
            type: "v3",
            nodeType: "Blend",
            a: n?.uuid,
            b: e.uuid
        };
        return "mode" in e && (t.mode = e.mode), t
    }

    function Vp(n, e) {
        let t = n.uniforms,
            r = n.id,
            i = ut(t[`f${r}_alpha`].value),
            s = Bt(t[`f${r}_mode`].value);
        return [i, s].forEach(o => e[o.uuid] = o), Object.assign(n, {
            uniforms: {
                [`f${r}_alpha`]: i.uuid,
                [`f${r}_mode`]: s.uuid
            }
        }), {
            uuid: Xi.MathUtils.generateUUID(),
            type: "v3",
            nodeType: "CustomTexture",
            alpha: i.uuid,
            mode: s.uuid
        }
    }

    function Af(n, e) {
        let t = n.uniforms,
            r = n.id,
            i = Bt(t[`f${r}_mode`].value),
            s = ut(t[`f${r}_alpha`].value),
            o = Fr(t[`f${r}_color`].value, s);
        return [o, s, i].forEach(l => e[l.uuid] = l), Object.assign(n, {
            uniforms: {
                [`f${r}_color`]: o.uuid,
                [`f${r}_alpha`]: s.uuid,
                [`f${r}_mode`]: i.uuid
            }
        }), o
    }

    function Hp(n, e) {
        let t = n.uniforms,
            r = n.id,
            i = Bt(t[`f${r}_mode`].value),
            s = ut(t[`f${r}_alpha`].value),
            o = yf(t[`f${r}_cnormal`].value);
        return [o, s, i].forEach(l => e[l.uuid] = l), Object.assign(n, {
            uniforms: {
                [`f${r}_cnormal`]: o.uuid,
                [`f${r}_alpha`]: s.uuid,
                [`f${r}_mode`]: i.uuid
            }
        }), {
            uuid: Xi.MathUtils.generateUUID(),
            type: "v3",
            nodeType: "CustomNormal",
            cnormal: o.uuid,
            alpha: s.uuid,
            mode: i.uuid
        }
    }

    function Wp(n, e) {
        let t = n.uniforms,
            r = n.id,
            i = Bt(t[`f${r}_mode`].value),
            s = ut(t[`f${r}_alpha`].value),
            o = ut(t[`f${r}_near`].value),
            l = ut(t[`f${r}_far`].value),
            a = ut(t[`f${r}_isVector`].value),
            c = yf(t[`f${r}_origin`].value),
            f = Fr(t[`f${r}_colorA`].value),
            h = Fr(t[`f${r}_colorB`].value);
        return [o, l, a, c, f, h, s, i].forEach(m => e[m.uuid] = m), Object.assign(n, {
            uniforms: {
                [`f${r}_near`]: o.uuid,
                [`f${r}_far`]: l.uuid,
                [`f${r}_isVector`]: a.uuid,
                [`f${r}_origin`]: c.uuid,
                [`f${r}_colorA`]: f.uuid,
                [`f${r}_colorB`]: h.uuid,
                [`f${r}_alpha`]: s.uuid,
                [`f${r}_mode`]: i.uuid
            }
        }), {
            uuid: Xi.MathUtils.generateUUID(),
            type: "v3",
            nodeType: "Depth",
            near: o.uuid,
            far: l.uuid,
            isVector: a.uuid,
            origin: c.uuid,
            colorA: f.uuid,
            colorB: h.uuid,
            alpha: s.uuid,
            mode: i.uuid
        }
    }

    function Jp(n, e) {
        let t = n.uniforms,
            r = n.id,
            i = Bt(t[`f${r}_mode`].value),
            s = ut(t[`f${r}_alpha`].value),
            o = Fr(t[`f${r}_color`].value),
            l = ut(t[`f${r}_bias`].value),
            a = ut(t[`f${r}_scale`].value),
            c = ut(t[`f${r}_intensity`].value),
            f = ut(t[`f${r}_factor`].value);
        return [o, l, a, c, f, s, i].forEach(h => e[h.uuid] = h), Object.assign(n, {
            uniforms: {
                [`f${r}_color`]: o.uuid,
                [`f${r}_bias`]: l.uuid,
                [`f${r}_scale`]: a.uuid,
                [`f${r}_intensity`]: c.uuid,
                [`f${r}_factor`]: f.uuid,
                [`f${r}_alpha`]: s.uuid,
                [`f${r}_mode`]: i.uuid
            }
        }), {
            uuid: Xi.MathUtils.generateUUID(),
            type: "v3",
            nodeType: "Fresnel",
            color: o.uuid,
            bias: l.uuid,
            scale: a.uuid,
            intensity: c.uuid,
            factor: f.uuid,
            alpha: s.uuid,
            mode: i.uuid
        }
    }

    function Qp(n, e) {
        let t = n.uniforms,
            r = n.id,
            i = Bt(t[`f${r}_mode`].value),
            s = ut(t[`f${r}_alpha`].value),
            o = Bt(t[`f${r}_gl_type`].value),
            l = Bt(t[`f${r}_num`].value),
            a = Fp(t[`f${r}_smooth`].value),
            c = zp(10, t[`f${r}_colors`].value),
            f = Gp(10, t[`f${r}_steps`].value),
            h = Xs(t[`f${r}_offset`].value),
            m = Xs(t[`f${r}_morph`].value),
            v = ut(t[`f${r}_angle`].value);
        return [o, l, a, c, f, h, m, v, s, i].forEach(g => e[g.uuid] = g), Object.assign(n, {
            uniforms: {
                [`f${r}_gl_type`]: o.uuid,
                [`f${r}_num`]: l.uuid,
                [`f${r}_smooth`]: a.uuid,
                [`f${r}_colors`]: c.uuid,
                [`f${r}_steps`]: f.uuid,
                [`f${r}_offset`]: h.uuid,
                [`f${r}_morph`]: m.uuid,
                [`f${r}_angle`]: v.uuid,
                [`f${r}_alpha`]: s.uuid,
                [`f${r}_mode`]: i.uuid
            }
        }), {
            uuid: Xi.MathUtils.generateUUID(),
            type: "v3",
            nodeType: "Gradient",
            gl_type: o.uuid,
            num: l.uuid,
            smooth: a.uuid,
            colors: c.uuid,
            steps: f.uuid,
            offset: h.uuid,
            morph: m.uuid,
            angle: v.uuid,
            alpha: s.uuid,
            mode: i.uuid
        }
    }

    function Yp(n, e) {
        let t = n.uniforms,
            r = n.id,
            i = Xi.MathUtils.generateUUID(),
            s = Bt(t[`f${r}_mode`].value),
            o = ut(t[`f${r}_alpha`].value),
            l = ut(t[`f${r}_crop`].value),
            a = jp(0),
            c = Up(t[`f${r}_texture`].value, a),
            f = kp(t[`f${r}_mat`].value);
        return [c, a, f, l, o, s].forEach(h => e[h.uuid] = h), Object.assign(n, {
            uniforms: {
                [`f${r}_texture`]: c.uuid,
                [`f${r}_mat`]: f.uuid,
                [`f${r}_crop`]: l.uuid,
                [`f${r}_alpha`]: o.uuid,
                [`f${r}_mode`]: s.uuid
            }
        }), {
            uuid: i,
            type: "v3",
            nodeType: "CustomTexture",
            texture: c.uuid,
            crop: l.uuid,
            alpha: o.uuid,
            mode: s.uuid
        }
    }

    function Kp(n, e) {
        let t = n.uniforms,
            r = n.id,
            i = Bt(t[`f${r}_mode`].value),
            s = ut(t[`f${r}_alpha`].value),
            o = ut(t[`f${r}_scale`].value),
            l = ut(t[`f${r}_move`].value),
            a = Xs(t[`f${r}_fA`].value),
            c = Xs(t[`f${r}_fB`].value),
            f = Xs(t[`f${r}_distortion`].value),
            h = Fr(t[`f${r}_colorA`].value),
            m = Fr(t[`f${r}_colorB`].value),
            v = Fr(t[`f${r}_colorC`].value),
            g = Fr(t[`f${r}_colorD`].value),
            y = Bt(t[`f${r}_intA`].value),
            A = Bt(t[`f${r}_intB`].value),
            w = Bt(t[`f${r}_intC`].value),
            C = Bt(t[`f${r}_intD`].value);
        return [o, l, a, c, f, h, m, v, g, y, A, w, C, s, i].forEach(S => e[S.uuid] = S), Object.assign(n, {
            uniforms: {
                [`f${r}_scale`]: o.uuid,
                [`f${r}_move`]: l.uuid,
                [`f${r}_fA`]: a.uuid,
                [`f${r}_fB`]: c.uuid,
                [`f${r}_distortion`]: f.uuid,
                [`f${r}_colorA`]: h.uuid,
                [`f${r}_colorB`]: m.uuid,
                [`f${r}_colorC`]: v.uuid,
                [`f${r}_colorD`]: g.uuid,
                [`f${r}_intA`]: y.uuid,
                [`f${r}_intB`]: A.uuid,
                [`f${r}_intC`]: w.uuid,
                [`f${r}_intD`]: C.uuid,
                [`f${r}_alpha`]: s.uuid,
                [`f${r}_mode`]: i.uuid
            }
        }), {
            uuid: Xi.MathUtils.generateUUID(),
            type: "v3",
            nodeType: "Noise",
            scale: o.uuid,
            move: l.uuid,
            fA: a.uuid,
            fB: c.uuid,
            distortion: f.uuid,
            colorA: h.uuid,
            colorB: m.uuid,
            colorC: v.uuid,
            colorD: g.uuid,
            intA: y.uuid,
            intB: A.uuid,
            intC: w.uuid,
            intD: C.uuid,
            alpha: s.uuid,
            mode: i.uuid
        }
    }
    var qs = W(J());

    function bf(n, e, t) {
        let r = e.uniforms,
            i = e.id,
            s = ut(r[`f${i}_alpha`].value),
            o = Bt(r[`f${i}_mode`].value);
        return [s, o].forEach(l => t[l.uuid] = l), Object.assign(e, {
            uniforms: {
                [`f${i}_alpha`]: s.uuid,
                [`f${i}_mode`]: o.uuid
            }
        }), {
            uuid: qs.MathUtils.generateUUID(),
            type: "basic",
            nodeType: "Basic",
            shadingAlpha: s.uuid,
            shadingBlend: o.uuid
        }
    }

    function Xp(n, e, t) {
        let r = e.uniforms,
            i = e.id,
            s = Fr(n.specular ?? 69905),
            o = ut(n.shininess ?? 30),
            l = ut(r[`f${i}_alpha`].value),
            a = Bt(r[`f${i}_mode`].value);
        return [s, o, l, a].forEach(c => t[c.uuid] = c), Object.assign(e, {
            uniforms: {
                [`f${i}_alpha`]: l.uuid,
                [`f${i}_mode`]: a.uuid
            }
        }), {
            uuid: qs.MathUtils.generateUUID(),
            type: "phong",
            nodeType: "Phong",
            specular: s.uuid,
            shininess: o.uuid,
            shadingAlpha: l.uuid,
            shadingBlend: a.uuid
        }
    }

    function qp(n, e, t) {
        let r = e.uniforms,
            i = e.id,
            s = Fr(n.emissive ?? 0),
            o = ut(n.emissiveIntensity ?? 1),
            l = ut(r[`f${i}_alpha`].value),
            a = Bt(r[`f${i}_mode`].value);
        return [o, s, l, a].forEach(c => t[c.uuid] = c), Object.assign(e, {
            uniforms: {
                [`f${i}_alpha`]: l.uuid,
                [`f${i}_mode`]: a.uuid
            }
        }), {
            uuid: qs.MathUtils.generateUUID(),
            type: "lambert",
            nodeType: "Lambert",
            emissiveIntensity: o.uuid,
            emissive: s.uuid,
            shadingAlpha: l.uuid,
            shadingBlend: a.uuid
        }
    }

    function Zp(n, e, t) {
        let r = e.uniforms,
            i = e.id,
            s = Fr(n.specular ?? 69905),
            o = ut(n.shininess ?? 30),
            l = ut(r[`f${i}_alpha`].value),
            a = Bt(r[`f${i}_mode`].value);
        return [s, o, l, a].forEach(c => t[c.uuid] = c), Object.assign(e, {
            uniforms: {
                [`f${i}_alpha`]: l.uuid,
                [`f${i}_mode`]: a.uuid
            }
        }), {
            uuid: qs.MathUtils.generateUUID(),
            type: "toon",
            nodeType: "Toon",
            specular: s.uuid,
            shininess: o.uuid,
            shadingAlpha: l.uuid,
            shadingBlend: a.uuid
        }
    }

    function $p(n, e, t) {
        let r = e.uniforms,
            i = e.id,
            s = ut(n.roughness ?? .3),
            o = ut(n.metalness ?? 0),
            l = ut(n.reflectivity ?? .5),
            a = ut(r[`f${i}_alpha`].value),
            c = Bt(r[`f${i}_mode`].value);
        return [s, o, l, a, c].forEach(f => t[f.uuid] = f), Object.assign(e, {
            uniforms: {
                [`f${i}_alpha`]: a.uuid,
                [`f${i}_mode`]: c.uuid
            }
        }), {
            uuid: qs.MathUtils.generateUUID(),
            type: "standard",
            nodeType: "Standard",
            roughness: s.uuid,
            metalness: o.uuid,
            reflectivity: l.uuid,
            shadingAlpha: a.uuid,
            shadingBlend: c.uuid
        }
    }
    var ic = W(J()),
        eg = new ic.Matrix4,
        Db = ["RectangleGeometry", "TriangleGeometry", "PolygonGeometry", "StarGeometry"];

    function tg(n) {
        let e = {};
        Ob(n.materials, e), Bb(n.interactionStates, e), Pb(n.geometries, n.object), Object.keys(e).length && (n.nodes = Gb(e))
    }

    function rg(n, e) {
        let t = n.geometry;
        if (t && t === e) return n;
        let r = n.children;
        if (r)
            for (let i = 0, s = r.length; i < s; i++) {
                let o = r[i],
                    l = rg(o, e);
                if (l !== void 0) return l
            }
    }

    function Pb(n, e) {
        if (n !== void 0) {
            for (let t of n)
                if (t.userData && Db.includes(t.userData?.type)) {
                    let r = t.userData.parameters,
                        i = r.extrudeBevelSize;
                    if (i > 0) {
                        r.width += i * 2, r.height += i * 2, r.extrudeDepth += i * 2;
                        let s = rg(e, t.uuid);
                        if (s !== void 0) {
                            let o = new ic.Object3D;
                            eg.fromArray(s.matrix), o.applyMatrix4(eg), o.position.z -= i, o.updateMatrix(), s.matrix = o.matrix.toArray()
                        }
                    }
                }
        }
    }

    function Bb(n, e) {
        if (n !== void 0) {
            for (let t of n)
                if (t.material)
                    if (Array.isArray(t.material))
                        for (let r of t.material)
                            for (let i of r.layersList) Ia(i, e);
                    else
                        for (let r of t.material.layersList) Ia(r, e)
        }
    }

    function Ob(n, e) {
        if (n !== void 0)
            for (let t of n) {
                let {
                    beforeLayers: r,
                    lightingLayer: i,
                    afterLayers: s
                } = Rb(t.userData.layers);
                if (!i) {
                    console.error("Material upgrade: could not find a ligthing layer");
                    continue
                }
                let o = Fb(t, i, e);
                if (e[o.uuid] = o, r.length > 0) {
                    let l = Ia(r[0], e);
                    e[l.uuid] = l;
                    for (let a = 1, c = r.length; a < c; ++a) {
                        let f = r[a],
                            h = Ia(f, e),
                            m = xf(l, h);
                        e[m.uuid] = m, e[h.uuid] = h, l = m
                    }
                    o.color = l.uuid
                }
                if (s.length > 0) {
                    let l;
                    for (let a of s) {
                        let c = Ia(a, e),
                            f = xf(l, c);
                        e[f.uuid] = f, e[c.uuid] = c, l = f
                    }
                    o.afterColor = l?.uuid
                }
                Object.assign(t, {
                    type: "ShaderMaterial",
                    wireframeLinecap: "",
                    wireframeLinejoin: "",
                    vertex: o?.uuid,
                    fragment: o?.uuid
                }), delete t.color, delete t.emissive, delete t.specular, delete t.shininess, delete t.roughness, delete t.metalness
            }
    }

    function Rb(n) {
        let e = [],
            t = [],
            r, i = n.head;
        for (; i;) {
            if (i.type === "light") {
                r = i, i = i.next;
                break
            }
            e.push(i), i = i.next
        }
        for (; i;) t.unshift(i), i = i.next;
        return {
            beforeLayers: e,
            lightingLayer: r,
            afterLayers: t
        }
    }

    function Fb(n, e, t) {
        let r, i;
        switch (n.userData.type) {
            case "BasicMaterial":
                r = bf(n, e, t), i = "BasicNodeMaterial";
                break;
            case "PhongMaterial":
                r = Xp(n, e, t), i = "PhongNodeMaterial";
                break;
            case "LambertMaterial":
                r = qp(n, e, t), i = "LambertNodeMaterial";
                break;
            case "ToonMaterial":
                r = Zp(n, e, t), i = "ToonNodeMaterial";
                break;
            case "PhysicalMaterial":
                r = $p(n, e, t), i = "StandardNodeMaterial";
                break;
            default:
                console.warn(`Material upgrade: could not find a properly material node to ${n.userData.type}`), r = bf(n, e, t), i = "BasicNodeMaterial"
        }
        return Object.assign(n.userData, {
            nodeType: i
        }), r
    }

    function Ia(n, e) {
        switch (n.type) {
            case "light":
                return Vp(n, e);
            case "color":
                return Af(n, e);
            case "depth":
                return Wp(n, e);
            case "fresnel":
                return Jp(n, e);
            case "gradient":
                return Qp(n, e);
            case "noise":
                return Kp(n, e);
            case "normal":
                return Hp(n, e);
            case "texture":
                return Yp(n, e);
            default:
                return console.warn(`Material upgrade: could not find a properly "layer" node to ${n.type}`), Af(n, e)
        }
    }

    function Gb(n) {
        let e = [];
        for (let t in n) e.push(n[t]);
        return e
    }

    function wf(n) {
        let e = n.metadata;
        return console.info(`File format version ${e?.version}`), e?.version === void 0 ? (console.warn("Unknow file version"), !1) : ((e.version <= 1.1 || e.version === 4.5) && (Lp(n), e.version = 1.2, console.warn("File upgraded from v1.1 or inferior to v1.2")), e.version === 1.2 && (Pp(n), e.version = 1.3, console.warn("File upgraded from v1.2 to v1.3")), e.version === 1.3 && (Rp(n), e.version = 1.4, console.warn("File upgraded from v1.3 to v1.4")), e.version === 1.4 && (tg(n), e.version = 1.5, console.warn("File upgraded from v1.4 to v1.5")), !0)
    }
    var La = class extends Nr {
        constructor(e = Si.create({}), t = new zr) {
            super(e, t);
            this.objectType = "SubdivObject";
            this.resized = !1;
            this.newlyPasted = !1;
            this.castShadow = !0, this.receiveShadow = !0, this.forceComputeSize = !1, this.subdivPointer = Si.activeSubdivPtr
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return t.object.objectType = "SubdivObject", t
        }
        updateGeometry(e) {
            let t = this.geometry,
                r = Xo[t.userData.type],
                i = this.objectType === "SubdivObject" ? Object.assign({}, t.userData, {
                    geometry: t,
                    subdivPointer: this.subdivPointer,
                    smoothShading: this.smoothShading
                }) : t.userData,
                s = r.build(r.normalizeInputs(e, i));
            this.geometry.dispose(), this.geometry = s
        }
        clone(e) {
            let t = this.material.clone(),
                r = Si.clone(Ne({}, this.geometry.userData.parameters), this.subdivPointer, this.smoothShading),
                i = this.geometry.originalGeometry ?? this.geometry,
                s = r.originalGeometry ?? r;
            s.boundingSphere = i.boundingSphere.clone();
            let o = new La(r, t).copy(this, e);
            return o.subdivPointer = Si.activeSubdivPtr, o
        }
        raycast(e, t) {
            let r = this.geometry.originalGeometry;
            if (r) {
                let i = this.geometry;
                this.geometry = r, Nr.prototype.raycast.call(this, e, t), this.geometry = i
            } else Nr.prototype.raycast.call(this, e, t)
        }
    };
    var nc = W(J()),
        Sf = class {
            constructor() {
                this._buffers = []
            }
            parse(e) {
                let t = new nc.BufferGeometry;
                if (this._vertexData = e.vertexData, this._loadBuffers(this._vertexData.buffers), t.uuid = e.uuid, this._vertexData.accessors)
                    for (let r = 0, i = this._vertexData.accessors.length; r < i; ++r) {
                        let s = this._vertexData.accessors[r].attributeName;
                        s === "indices" ? t.setIndex(this._loadAccessor(r)) : t.setAttribute(s, this._loadAccessor(r))
                    }
                if (e.data?.groups)
                    for (let r of e.data.groups) t.addGroup(r.start, r.count, r.materialIndex);
                return t
            }
            _loadAccessor(e) {
                let t = this._vertexData.accessors[e],
                    r = this._loadBufferView(t.bufferView),
                    i = kb[t.type],
                    s = zb[t.componentType],
                    o = new s(r.buffer);
                return new nc.BufferAttribute(o, i)
            }
            _loadBufferView(e) {
                let t = this._vertexData.bufferViews[e],
                    r = this._buffers[t.buffer],
                    i = t.byteLength || 0,
                    s = t.byteOffset || 0;
                return r.slice(s, s + i)
            }
            _loadBuffers(e) {
                for (let t of e) {
                    if (!t.uri) continue;
                    let r = t.uri.slice(t.uri.indexOf("base64") + 7),
                        i = atob(r),
                        s = new Uint8Array(i.length);
                    for (let o = 0; o < i.length; o++) s[o] = i.charCodeAt(o);
                    this._buffers.push(s)
                }
            }
        },
        zb = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        kb = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        };
    var Oi = W(J()),
        Nf = new WeakMap,
        Cf = class extends Oi.Loader {
            constructor(e) {
                super(e);
                this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                }, this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(e) {
                return this.decoderPath = e, this
            }
            setDecoderConfig(e) {
                return this.decoderConfig = e, this
            }
            setWorkerLimit(e) {
                return this.workerLimit = e, this
            }
            load(e, t, r, i) {
                let s = new Oi.FileLoader(this.manager);
                s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, o => {
                    let l = {
                        attributeIDs: this.defaultAttributeIDs,
                        attributeTypes: this.defaultAttributeTypes,
                        useUniqueIDs: !1
                    };
                    this.decodeGeometry(o, l).then(t).catch(i)
                }, r, i)
            }
            decodeDracoFile(e, t, r, i) {
                let s = {
                    attributeIDs: r || this.defaultAttributeIDs,
                    attributeTypes: i || this.defaultAttributeTypes,
                    useUniqueIDs: !!r
                };
                this.decodeGeometry(e, s).then(t)
            }
            decodeGeometry(e, t) {
                for (let a in t.attributeTypes) {
                    let c = t.attributeTypes[a];
                    c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[a] = c.name)
                }
                let r = JSON.stringify(t);
                if (Nf.has(e)) {
                    let a = Nf.get(e);
                    if (a.key === r) return a.promise;
                    if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let i, s = this.workerNextTaskID++,
                    o = e.byteLength,
                    l = this._getWorker(s, o).then(a => (i = a, new Promise((c, f) => {
                        i._callbacks[s] = {
                            resolve: c,
                            reject: f
                        }, i.postMessage({
                            type: "decode",
                            id: s,
                            taskConfig: t,
                            buffer: e
                        }, [e])
                    }))).then(a => this._createGeometry(a.geometry));
                return l.catch(() => !0).then(() => {
                    i && s && this._releaseTask(i, s)
                }), Nf.set(e, {
                    key: r,
                    promise: l
                }), l
            }
            _createGeometry(e) {
                let t = new Oi.BufferGeometry;
                e.index && t.setIndex(new Oi.BufferAttribute(e.index.array, 1));
                for (let r = 0; r < e.attributes.length; r++) {
                    let i = e.attributes[r],
                        s = i.name,
                        o = i.array,
                        l = i.itemSize;
                    t.setAttribute(s, new Oi.BufferAttribute(o, l))
                }
                return t
            }
            _loadLibrary(e, t) {
                let r = new Oi.FileLoader(this.manager);
                return r.setPath(this.decoderPath), r.setResponseType(t), r.setWithCredentials(this.withCredentials), new Promise((i, s) => {
                    r.load(e, i, void 0, s)
                })
            }
            preload() {
                return this._initDecoder(), this
            }
            _initDecoder() {
                if (this.decoderPending) return this.decoderPending;
                let e = typeof WebAssembly != "object" || this.decoderConfig.type === "js",
                    t = [];
                return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(r => {
                    let i = r[0];
                    e || (this.decoderConfig.wasmBinary = r[1]);
                    let s = Ub.toString(),
                        o = ["/* draco decoder */", i, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
                    this.workerSourceURL = URL.createObjectURL(new Blob([o]))
                }), this.decoderPending
            }
            _getWorker(e, t) {
                return this._initDecoder().then(() => {
                    if (this.workerPool.length < this.workerLimit) {
                        let i = new Worker(this.workerSourceURL);
                        i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }), i.onmessage = function(s) {
                            let o = s.data;
                            switch (o.type) {
                                case "decode":
                                    i._callbacks[o.id].resolve(o);
                                    break;
                                case "error":
                                    i._callbacks[o.id].reject(o);
                                    break;
                                default:
                                    console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                            }
                        }, this.workerPool.push(i)
                    } else this.workerPool.sort(function(i, s) {
                        return i._taskLoad > s._taskLoad ? -1 : 1
                    });
                    let r = this.workerPool[this.workerPool.length - 1];
                    return r._taskCosts[e] = t, r._taskLoad += t, r
                })
            }
            _releaseTask(e, t) {
                e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
            }
            dispose() {
                for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                return this.workerPool.length = 0, this
            }
        };

    function Ub() {
        let n, e;
        onmessage = function(o) {
            let l = o.data;
            switch (l.type) {
                case "init":
                    n = l.decoderConfig, e = new Promise(function(f) {
                        n.onModuleLoaded = function(h) {
                            f({
                                draco: h
                            })
                        }, DracoDecoderModule(n)
                    });
                    break;
                case "decode":
                    let a = l.buffer,
                        c = l.taskConfig;
                    e.then(f => {
                        let h = f.draco,
                            m = new h.Decoder,
                            v = new h.DecoderBuffer;
                        v.Init(new Int8Array(a), a.byteLength);
                        try {
                            let g = t(h, m, v, c),
                                y = g.attributes.map(A => A.array.buffer);
                            g.index && y.push(g.index.array.buffer), self.postMessage({
                                type: "decode",
                                id: l.id,
                                geometry: g
                            }, y)
                        } catch (g) {
                            console.error(g), self.postMessage({
                                type: "error",
                                id: l.id,
                                error: g.message
                            })
                        } finally {
                            h.destroy(v), h.destroy(m)
                        }
                    });
                    break
            }
        };

        function t(o, l, a, c) {
            let f = c.attributeIDs,
                h = c.attributeTypes,
                m, v, g = l.GetEncodedGeometryType(a);
            if (g === o.TRIANGULAR_MESH) m = new o.Mesh, v = l.DecodeBufferToMesh(a, m);
            else if (g === o.POINT_CLOUD) m = new o.PointCloud, v = l.DecodeBufferToPointCloud(a, m);
            else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
            if (!v.ok() || m.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + v.error_msg());
            let y = {
                index: null,
                attributes: []
            };
            for (let A in f) {
                let w = self[h[A]],
                    C, S;
                if (c.useUniqueIDs) S = f[A], C = l.GetAttributeByUniqueId(m, S);
                else {
                    if (S = l.GetAttributeId(m, o[f[A]]), S === -1) continue;
                    C = l.GetAttribute(m, S)
                }
                y.attributes.push(i(o, l, m, A, w, C))
            }
            return g === o.TRIANGULAR_MESH && (y.index = r(o, l, m)), o.destroy(m), y
        }

        function r(o, l, a) {
            let f = a.num_faces() * 3,
                h = f * 4,
                m = o._malloc(h);
            l.GetTrianglesUInt32Array(a, h, m);
            let v = new Uint32Array(o.HEAPF32.buffer, m, f).slice();
            return o._free(m), {
                array: v,
                itemSize: 1
            }
        }

        function i(o, l, a, c, f, h) {
            let m = h.num_components(),
                g = a.num_points() * m,
                y = g * f.BYTES_PER_ELEMENT,
                A = s(o, f),
                w = o._malloc(y);
            l.GetAttributeDataArrayForAllPoints(a, h, A, y, w);
            let C = new f(o.HEAPF32.buffer, w, g).slice();
            return o._free(w), {
                name: c,
                array: C,
                itemSize: m
            }
        }

        function s(o, l) {
            switch (l) {
                case Float32Array:
                    return o.DT_FLOAT32;
                case Int8Array:
                    return o.DT_INT8;
                case Int16Array:
                    return o.DT_INT16;
                case Int32Array:
                    return o.DT_INT32;
                case Uint8Array:
                    return o.DT_UINT8;
                case Uint16Array:
                    return o.DT_UINT16;
                case Uint32Array:
                    return o.DT_UINT32
            }
        }
    }
    var jb = typeof global == "object" && global && global.Object === Object && global,
        sc = jb;
    var Vb = typeof self == "object" && self && self.Object === Object && self,
        Hb = sc || Vb || Function("return this")(),
        Gt = Hb;
    var Wb = Gt.Symbol,
        Qr = Wb;
    var ig = Object.prototype,
        Jb = ig.hasOwnProperty,
        Qb = ig.toString,
        Da = Qr ? Qr.toStringTag : void 0;

    function Yb(n) {
        var e = Jb.call(n, Da),
            t = n[Da];
        try {
            n[Da] = void 0;
            var r = !0
        } catch (s) {}
        var i = Qb.call(n);
        return r && (e ? n[Da] = t : delete n[Da]), i
    }
    var ng = Yb;
    var Kb = Object.prototype,
        Xb = Kb.toString;

    function qb(n) {
        return Xb.call(n)
    }
    var sg = qb;
    var Zb = "[object Null]",
        $b = "[object Undefined]",
        og = Qr ? Qr.toStringTag : void 0;

    function ew(n) {
        return n == null ? n === void 0 ? $b : Zb : og && og in Object(n) ? ng(n) : sg(n)
    }
    var di = ew;

    function tw(n) {
        return n != null && typeof n == "object"
    }
    var hi = tw;
    var rw = "[object Symbol]";

    function iw(n) {
        return typeof n == "symbol" || hi(n) && di(n) == rw
    }
    var mi = iw;

    function nw(n, e) {
        for (var t = -1, r = n == null ? 0 : n.length, i = Array(r); ++t < r;) i[t] = e(n[t], t, n);
        return i
    }
    var Zs = nw;
    var sw = Array.isArray,
        Dt = sw;
    var ow = 1 / 0,
        ag = Qr ? Qr.prototype : void 0,
        lg = ag ? ag.toString : void 0;

    function cg(n) {
        if (typeof n == "string") return n;
        if (Dt(n)) return Zs(n, cg) + "";
        if (mi(n)) return lg ? lg.call(n) : "";
        var e = n + "";
        return e == "0" && 1 / n == -ow ? "-0" : e
    }
    var ug = cg;
    var aw = /\s/;

    function lw(n) {
        for (var e = n.length; e-- && aw.test(n.charAt(e)););
        return e
    }
    var fg = lw;
    var cw = /^\s+/;

    function uw(n) {
        return n && n.slice(0, fg(n) + 1).replace(cw, "")
    }
    var dg = uw;

    function fw(n) {
        var e = typeof n;
        return n != null && (e == "object" || e == "function")
    }
    var pi = fw;
    var hg = 0 / 0,
        dw = /^[-+]0x[0-9a-f]+$/i,
        hw = /^0b[01]+$/i,
        mw = /^0o[0-7]+$/i,
        pw = parseInt;

    function gw(n) {
        if (typeof n == "number") return n;
        if (mi(n)) return hg;
        if (pi(n)) {
            var e = typeof n.valueOf == "function" ? n.valueOf() : n;
            n = pi(e) ? e + "" : e
        }
        if (typeof n != "string") return n === 0 ? n : +n;
        n = dg(n);
        var t = hw.test(n);
        return t || mw.test(n) ? pw(n.slice(2), t ? 2 : 8) : dw.test(n) ? hg : +n
    }
    var Tf = gw;

    function vw(n) {
        return n
    }
    var oc = vw;
    var yw = "[object AsyncFunction]",
        xw = "[object Function]",
        Aw = "[object GeneratorFunction]",
        bw = "[object Proxy]";

    function ww(n) {
        if (!pi(n)) return !1;
        var e = di(n);
        return e == xw || e == Aw || e == yw || e == bw
    }
    var ac = ww;
    var Sw = Gt["__core-js_shared__"],
        lc = Sw;
    var mg = function() {
        var n = /[^.]+$/.exec(lc && lc.keys && lc.keys.IE_PROTO || "");
        return n ? "Symbol(src)_1." + n : ""
    }();

    function Nw(n) {
        return !!mg && mg in n
    }
    var pg = Nw;
    var Cw = Function.prototype,
        Tw = Cw.toString;

    function Ew(n) {
        if (n != null) {
            try {
                return Tw.call(n)
            } catch (e) {}
            try {
                return n + ""
            } catch (e) {}
        }
        return ""
    }
    var qi = Ew;
    var Mw = /[\\^$.*+?()[\]{}|]/g,
        _w = /^\[object .+?Constructor\]$/,
        Iw = Function.prototype,
        Lw = Object.prototype,
        Dw = Iw.toString,
        Pw = Lw.hasOwnProperty,
        Bw = RegExp("^" + Dw.call(Pw).replace(Mw, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

    function Ow(n) {
        if (!pi(n) || pg(n)) return !1;
        var e = ac(n) ? Bw : _w;
        return e.test(qi(n))
    }
    var gg = Ow;

    function Rw(n, e) {
        return n == null ? void 0 : n[e]
    }
    var vg = Rw;

    function Fw(n, e) {
        var t = vg(n, e);
        return gg(t) ? t : void 0
    }
    var Yr = Fw;
    var Gw = Yr(Gt, "WeakMap"),
        cc = Gw;
    var zw = 9007199254740991,
        kw = /^(?:0|[1-9]\d*)$/;

    function Uw(n, e) {
        var t = typeof n;
        return e = e ?? zw, !!e && (t == "number" || t != "symbol" && kw.test(n)) && n > -1 && n % 1 == 0 && n < e
    }
    var uc = Uw;

    function jw(n, e) {
        return n === e || n !== n && e !== e
    }
    var fc = jw;
    var Vw = 9007199254740991;

    function Hw(n) {
        return typeof n == "number" && n > -1 && n % 1 == 0 && n <= Vw
    }
    var $s = Hw;

    function Ww(n) {
        return n != null && $s(n.length) && !ac(n)
    }
    var eo = Ww;
    var Jw = Object.prototype;

    function Qw(n) {
        var e = n && n.constructor,
            t = typeof e == "function" && e.prototype || Jw;
        return n === t
    }
    var yg = Qw;

    function Yw(n, e) {
        for (var t = -1, r = Array(n); ++t < n;) r[t] = e(t);
        return r
    }
    var xg = Yw;
    var Kw = "[object Arguments]";

    function Xw(n) {
        return hi(n) && di(n) == Kw
    }
    var Ef = Xw;
    var Ag = Object.prototype,
        qw = Ag.hasOwnProperty,
        Zw = Ag.propertyIsEnumerable,
        $w = Ef(function() {
            return arguments
        }()) ? Ef : function(n) {
            return hi(n) && qw.call(n, "callee") && !Zw.call(n, "callee")
        },
        dc = $w;

    function eS() {
        return !1
    }
    var bg = eS;
    var wg = typeof exports == "object" && exports && !exports.nodeType && exports,
        Sg = wg && typeof module == "object" && module && !module.nodeType && module,
        tS = Sg && Sg.exports === wg,
        Ng = tS ? Gt.Buffer : void 0,
        rS = Ng ? Ng.isBuffer : void 0,
        iS = rS || bg,
        Pa = iS;
    var nS = "[object Arguments]",
        sS = "[object Array]",
        oS = "[object Boolean]",
        aS = "[object Date]",
        lS = "[object Error]",
        cS = "[object Function]",
        uS = "[object Map]",
        fS = "[object Number]",
        dS = "[object Object]",
        hS = "[object RegExp]",
        mS = "[object Set]",
        pS = "[object String]",
        gS = "[object WeakMap]",
        vS = "[object ArrayBuffer]",
        yS = "[object DataView]",
        xS = "[object Float32Array]",
        AS = "[object Float64Array]",
        bS = "[object Int8Array]",
        wS = "[object Int16Array]",
        SS = "[object Int32Array]",
        NS = "[object Uint8Array]",
        CS = "[object Uint8ClampedArray]",
        TS = "[object Uint16Array]",
        ES = "[object Uint32Array]",
        Et = {};
    Et[xS] = Et[AS] = Et[bS] = Et[wS] = Et[SS] = Et[NS] = Et[CS] = Et[TS] = Et[ES] = !0;
    Et[nS] = Et[sS] = Et[vS] = Et[oS] = Et[yS] = Et[aS] = Et[lS] = Et[cS] = Et[uS] = Et[fS] = Et[dS] = Et[hS] = Et[mS] = Et[pS] = Et[gS] = !1;

    function MS(n) {
        return hi(n) && $s(n.length) && !!Et[di(n)]
    }
    var Cg = MS;

    function _S(n) {
        return function(e) {
            return n(e)
        }
    }
    var hc = _S;
    var Tg = typeof exports == "object" && exports && !exports.nodeType && exports,
        Ba = Tg && typeof module == "object" && module && !module.nodeType && module,
        IS = Ba && Ba.exports === Tg,
        Mf = IS && sc.process,
        LS = function() {
            try {
                var n = Ba && Ba.require && Ba.require("util").types;
                return n || Mf && Mf.binding && Mf.binding("util")
            } catch (e) {}
        }(),
        _f = LS;
    var Eg = _f && _f.isTypedArray,
        DS = Eg ? hc(Eg) : Cg,
        mc = DS;
    var PS = Object.prototype,
        BS = PS.hasOwnProperty;

    function OS(n, e) {
        var t = Dt(n),
            r = !t && dc(n),
            i = !t && !r && Pa(n),
            s = !t && !r && !i && mc(n),
            o = t || r || i || s,
            l = o ? xg(n.length, String) : [],
            a = l.length;
        for (var c in n)(e || BS.call(n, c)) && !(o && (c == "length" || i && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || uc(c, a))) && l.push(c);
        return l
    }
    var Mg = OS;

    function RS(n, e) {
        return function(t) {
            return n(e(t))
        }
    }
    var _g = RS;
    var FS = _g(Object.keys, Object),
        Ig = FS;
    var GS = Object.prototype,
        zS = GS.hasOwnProperty;

    function kS(n) {
        if (!yg(n)) return Ig(n);
        var e = [];
        for (var t in Object(n)) zS.call(n, t) && t != "constructor" && e.push(t);
        return e
    }
    var Lg = kS;

    function US(n) {
        return eo(n) ? Mg(n) : Lg(n)
    }
    var to = US;
    var jS = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        VS = /^\w*$/;

    function HS(n, e) {
        if (Dt(n)) return !1;
        var t = typeof n;
        return t == "number" || t == "symbol" || t == "boolean" || n == null || mi(n) ? !0 : VS.test(n) || !jS.test(n) || e != null && n in Object(e)
    }
    var ro = HS;
    var WS = Yr(Object, "create"),
        Zi = WS;

    function JS() {
        this.__data__ = Zi ? Zi(null) : {}, this.size = 0
    }
    var Dg = JS;

    function QS(n) {
        var e = this.has(n) && delete this.__data__[n];
        return this.size -= e ? 1 : 0, e
    }
    var Pg = QS;
    var YS = "__lodash_hash_undefined__",
        KS = Object.prototype,
        XS = KS.hasOwnProperty;

    function qS(n) {
        var e = this.__data__;
        if (Zi) {
            var t = e[n];
            return t === YS ? void 0 : t
        }
        return XS.call(e, n) ? e[n] : void 0
    }
    var Bg = qS;
    var ZS = Object.prototype,
        $S = ZS.hasOwnProperty;

    function eN(n) {
        var e = this.__data__;
        return Zi ? e[n] !== void 0 : $S.call(e, n)
    }
    var Og = eN;
    var tN = "__lodash_hash_undefined__";

    function rN(n, e) {
        var t = this.__data__;
        return this.size += this.has(n) ? 0 : 1, t[n] = Zi && e === void 0 ? tN : e, this
    }
    var Rg = rN;

    function io(n) {
        var e = -1,
            t = n == null ? 0 : n.length;
        for (this.clear(); ++e < t;) {
            var r = n[e];
            this.set(r[0], r[1])
        }
    }
    io.prototype.clear = Dg;
    io.prototype.delete = Pg;
    io.prototype.get = Bg;
    io.prototype.has = Og;
    io.prototype.set = Rg;
    var If = io;

    function iN() {
        this.__data__ = [], this.size = 0
    }
    var Fg = iN;

    function nN(n, e) {
        for (var t = n.length; t--;)
            if (fc(n[t][0], e)) return t;
        return -1
    }
    var vn = nN;
    var sN = Array.prototype,
        oN = sN.splice;

    function aN(n) {
        var e = this.__data__,
            t = vn(e, n);
        if (t < 0) return !1;
        var r = e.length - 1;
        return t == r ? e.pop() : oN.call(e, t, 1), --this.size, !0
    }
    var Gg = aN;

    function lN(n) {
        var e = this.__data__,
            t = vn(e, n);
        return t < 0 ? void 0 : e[t][1]
    }
    var zg = lN;

    function cN(n) {
        return vn(this.__data__, n) > -1
    }
    var kg = cN;

    function uN(n, e) {
        var t = this.__data__,
            r = vn(t, n);
        return r < 0 ? (++this.size, t.push([n, e])) : t[r][1] = e, this
    }
    var Ug = uN;

    function no(n) {
        var e = -1,
            t = n == null ? 0 : n.length;
        for (this.clear(); ++e < t;) {
            var r = n[e];
            this.set(r[0], r[1])
        }
    }
    no.prototype.clear = Fg;
    no.prototype.delete = Gg;
    no.prototype.get = zg;
    no.prototype.has = kg;
    no.prototype.set = Ug;
    var yn = no;
    var fN = Yr(Gt, "Map"),
        xn = fN;

    function dN() {
        this.size = 0, this.__data__ = {
            hash: new If,
            map: new(xn || yn),
            string: new If
        }
    }
    var jg = dN;

    function hN(n) {
        var e = typeof n;
        return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null
    }
    var Vg = hN;

    function mN(n, e) {
        var t = n.__data__;
        return Vg(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map
    }
    var An = mN;

    function pN(n) {
        var e = An(this, n).delete(n);
        return this.size -= e ? 1 : 0, e
    }
    var Hg = pN;

    function gN(n) {
        return An(this, n).get(n)
    }
    var Wg = gN;

    function vN(n) {
        return An(this, n).has(n)
    }
    var Jg = vN;

    function yN(n, e) {
        var t = An(this, n),
            r = t.size;
        return t.set(n, e), this.size += t.size == r ? 0 : 1, this
    }
    var Qg = yN;

    function so(n) {
        var e = -1,
            t = n == null ? 0 : n.length;
        for (this.clear(); ++e < t;) {
            var r = n[e];
            this.set(r[0], r[1])
        }
    }
    so.prototype.clear = jg;
    so.prototype.delete = Hg;
    so.prototype.get = Wg;
    so.prototype.has = Jg;
    so.prototype.set = Qg;
    var es = so;
    var xN = "Expected a function";

    function Lf(n, e) {
        if (typeof n != "function" || e != null && typeof e != "function") throw new TypeError(xN);
        var t = function() {
            var r = arguments,
                i = e ? e.apply(this, r) : r[0],
                s = t.cache;
            if (s.has(i)) return s.get(i);
            var o = n.apply(this, r);
            return t.cache = s.set(i, o) || s, o
        };
        return t.cache = new(Lf.Cache || es), t
    }
    Lf.Cache = es;
    var Yg = Lf;
    var AN = 500;

    function bN(n) {
        var e = Yg(n, function(r) {
                return t.size === AN && t.clear(), r
            }),
            t = e.cache;
        return e
    }
    var Kg = bN;
    var wN = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        SN = /\\(\\)?/g,
        NN = Kg(function(n) {
            var e = [];
            return n.charCodeAt(0) === 46 && e.push(""), n.replace(wN, function(t, r, i, s) {
                e.push(i ? s.replace(SN, "$1") : r || t)
            }), e
        }),
        Xg = NN;

    function CN(n) {
        return n == null ? "" : ug(n)
    }
    var qg = CN;

    function TN(n, e) {
        return Dt(n) ? n : ro(n, e) ? [n] : Xg(qg(n))
    }
    var pc = TN;
    var EN = 1 / 0;

    function MN(n) {
        if (typeof n == "string" || mi(n)) return n;
        var e = n + "";
        return e == "0" && 1 / n == -EN ? "-0" : e
    }
    var bn = MN;

    function _N(n, e) {
        e = pc(e, n);
        for (var t = 0, r = e.length; n != null && t < r;) n = n[bn(e[t++])];
        return t && t == r ? n : void 0
    }
    var oo = _N;

    function IN(n, e, t) {
        var r = n == null ? void 0 : oo(n, e);
        return r === void 0 ? t : r
    }
    var Zg = IN;

    function LN(n, e) {
        for (var t = -1, r = e.length, i = n.length; ++t < r;) n[i + t] = e[t];
        return n
    }
    var $g = LN;

    function DN() {
        this.__data__ = new yn, this.size = 0
    }
    var ev = DN;

    function PN(n) {
        var e = this.__data__,
            t = e.delete(n);
        return this.size = e.size, t
    }
    var tv = PN;

    function BN(n) {
        return this.__data__.get(n)
    }
    var rv = BN;

    function ON(n) {
        return this.__data__.has(n)
    }
    var iv = ON;
    var RN = 200;

    function FN(n, e) {
        var t = this.__data__;
        if (t instanceof yn) {
            var r = t.__data__;
            if (!xn || r.length < RN - 1) return r.push([n, e]), this.size = ++t.size, this;
            t = this.__data__ = new es(r)
        }
        return t.set(n, e), this.size = t.size, this
    }
    var nv = FN;

    function ao(n) {
        var e = this.__data__ = new yn(n);
        this.size = e.size
    }
    ao.prototype.clear = ev;
    ao.prototype.delete = tv;
    ao.prototype.get = rv;
    ao.prototype.has = iv;
    ao.prototype.set = nv;
    var lo = ao;

    function GN(n, e) {
        for (var t = -1, r = n == null ? 0 : n.length, i = 0, s = []; ++t < r;) {
            var o = n[t];
            e(o, t, n) && (s[i++] = o)
        }
        return s
    }
    var sv = GN;

    function zN() {
        return []
    }
    var ov = zN;
    var kN = Object.prototype,
        UN = kN.propertyIsEnumerable,
        av = Object.getOwnPropertySymbols,
        jN = av ? function(n) {
            return n == null ? [] : (n = Object(n), sv(av(n), function(e) {
                return UN.call(n, e)
            }))
        } : ov,
        lv = jN;

    function VN(n, e, t) {
        var r = e(n);
        return Dt(n) ? r : $g(r, t(n))
    }
    var cv = VN;

    function HN(n) {
        return cv(n, to, lv)
    }
    var Df = HN;
    var WN = Yr(Gt, "DataView"),
        gc = WN;
    var JN = Yr(Gt, "Promise"),
        vc = JN;
    var QN = Yr(Gt, "Set"),
        yc = QN;
    var uv = "[object Map]",
        YN = "[object Object]",
        fv = "[object Promise]",
        dv = "[object Set]",
        hv = "[object WeakMap]",
        mv = "[object DataView]",
        KN = qi(gc),
        XN = qi(xn),
        qN = qi(vc),
        ZN = qi(yc),
        $N = qi(cc),
        ts = di;
    (gc && ts(new gc(new ArrayBuffer(1))) != mv || xn && ts(new xn) != uv || vc && ts(vc.resolve()) != fv || yc && ts(new yc) != dv || cc && ts(new cc) != hv) && (ts = function(n) {
        var e = di(n),
            t = e == YN ? n.constructor : void 0,
            r = t ? qi(t) : "";
        if (r) switch (r) {
            case KN:
                return mv;
            case XN:
                return uv;
            case qN:
                return fv;
            case ZN:
                return dv;
            case $N:
                return hv
        }
        return e
    });
    var Pf = ts;
    var e1 = Gt.Uint8Array,
        Bf = e1;
    var t1 = "__lodash_hash_undefined__";

    function r1(n) {
        return this.__data__.set(n, t1), this
    }
    var pv = r1;

    function i1(n) {
        return this.__data__.has(n)
    }
    var gv = i1;

    function xc(n) {
        var e = -1,
            t = n == null ? 0 : n.length;
        for (this.__data__ = new es; ++e < t;) this.add(n[e])
    }
    xc.prototype.add = xc.prototype.push = pv;
    xc.prototype.has = gv;
    var vv = xc;

    function n1(n, e) {
        for (var t = -1, r = n == null ? 0 : n.length; ++t < r;)
            if (e(n[t], t, n)) return !0;
        return !1
    }
    var yv = n1;

    function s1(n, e) {
        return n.has(e)
    }
    var xv = s1;
    var o1 = 1,
        a1 = 2;

    function l1(n, e, t, r, i, s) {
        var o = t & o1,
            l = n.length,
            a = e.length;
        if (l != a && !(o && a > l)) return !1;
        var c = s.get(n),
            f = s.get(e);
        if (c && f) return c == e && f == n;
        var h = -1,
            m = !0,
            v = t & a1 ? new vv : void 0;
        for (s.set(n, e), s.set(e, n); ++h < l;) {
            var g = n[h],
                y = e[h];
            if (r) var A = o ? r(y, g, h, e, n, s) : r(g, y, h, n, e, s);
            if (A !== void 0) {
                if (A) continue;
                m = !1;
                break
            }
            if (v) {
                if (!yv(e, function(w, C) {
                        if (!xv(v, C) && (g === w || i(g, w, t, r, s))) return v.push(C)
                    })) {
                    m = !1;
                    break
                }
            } else if (!(g === y || i(g, y, t, r, s))) {
                m = !1;
                break
            }
        }
        return s.delete(n), s.delete(e), m
    }
    var Ac = l1;

    function c1(n) {
        var e = -1,
            t = Array(n.size);
        return n.forEach(function(r, i) {
            t[++e] = [i, r]
        }), t
    }
    var Av = c1;

    function u1(n) {
        var e = -1,
            t = Array(n.size);
        return n.forEach(function(r) {
            t[++e] = r
        }), t
    }
    var bv = u1;
    var f1 = 1,
        d1 = 2,
        h1 = "[object Boolean]",
        m1 = "[object Date]",
        p1 = "[object Error]",
        g1 = "[object Map]",
        v1 = "[object Number]",
        y1 = "[object RegExp]",
        x1 = "[object Set]",
        A1 = "[object String]",
        b1 = "[object Symbol]",
        w1 = "[object ArrayBuffer]",
        S1 = "[object DataView]",
        wv = Qr ? Qr.prototype : void 0,
        Of = wv ? wv.valueOf : void 0;

    function N1(n, e, t, r, i, s, o) {
        switch (t) {
            case S1:
                if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset) return !1;
                n = n.buffer, e = e.buffer;
            case w1:
                return !(n.byteLength != e.byteLength || !s(new Bf(n), new Bf(e)));
            case h1:
            case m1:
            case v1:
                return fc(+n, +e);
            case p1:
                return n.name == e.name && n.message == e.message;
            case y1:
            case A1:
                return n == e + "";
            case g1:
                var l = Av;
            case x1:
                var a = r & f1;
                if (l || (l = bv), n.size != e.size && !a) return !1;
                var c = o.get(n);
                if (c) return c == e;
                r |= d1, o.set(n, e);
                var f = Ac(l(n), l(e), r, i, s, o);
                return o.delete(n), f;
            case b1:
                if (Of) return Of.call(n) == Of.call(e)
        }
        return !1
    }
    var Sv = N1;
    var C1 = 1,
        T1 = Object.prototype,
        E1 = T1.hasOwnProperty;

    function M1(n, e, t, r, i, s) {
        var o = t & C1,
            l = Df(n),
            a = l.length,
            c = Df(e),
            f = c.length;
        if (a != f && !o) return !1;
        for (var h = a; h--;) {
            var m = l[h];
            if (!(o ? m in e : E1.call(e, m))) return !1
        }
        var v = s.get(n),
            g = s.get(e);
        if (v && g) return v == e && g == n;
        var y = !0;
        s.set(n, e), s.set(e, n);
        for (var A = o; ++h < a;) {
            m = l[h];
            var w = n[m],
                C = e[m];
            if (r) var S = o ? r(C, w, m, e, n, s) : r(w, C, m, n, e, s);
            if (!(S === void 0 ? w === C || i(w, C, t, r, s) : S)) {
                y = !1;
                break
            }
            A || (A = m == "constructor")
        }
        if (y && !A) {
            var E = n.constructor,
                M = e.constructor;
            E != M && "constructor" in n && "constructor" in e && !(typeof E == "function" && E instanceof E && typeof M == "function" && M instanceof M) && (y = !1)
        }
        return s.delete(n), s.delete(e), y
    }
    var Nv = M1;
    var _1 = 1,
        Cv = "[object Arguments]",
        Tv = "[object Array]",
        bc = "[object Object]",
        I1 = Object.prototype,
        Ev = I1.hasOwnProperty;

    function L1(n, e, t, r, i, s) {
        var o = Dt(n),
            l = Dt(e),
            a = o ? Tv : Pf(n),
            c = l ? Tv : Pf(e);
        a = a == Cv ? bc : a, c = c == Cv ? bc : c;
        var f = a == bc,
            h = c == bc,
            m = a == c;
        if (m && Pa(n)) {
            if (!Pa(e)) return !1;
            o = !0, f = !1
        }
        if (m && !f) return s || (s = new lo), o || mc(n) ? Ac(n, e, t, r, i, s) : Sv(n, e, a, t, r, i, s);
        if (!(t & _1)) {
            var v = f && Ev.call(n, "__wrapped__"),
                g = h && Ev.call(e, "__wrapped__");
            if (v || g) {
                var y = v ? n.value() : n,
                    A = g ? e.value() : e;
                return s || (s = new lo), i(y, A, t, r, s)
            }
        }
        return m ? (s || (s = new lo), Nv(n, e, t, r, i, s)) : !1
    }
    var Mv = L1;

    function _v(n, e, t, r, i) {
        return n === e ? !0 : n == null || e == null || !hi(n) && !hi(e) ? n !== n && e !== e : Mv(n, e, t, r, _v, i)
    }
    var wc = _v;
    var D1 = 1,
        P1 = 2;

    function B1(n, e, t, r) {
        var i = t.length,
            s = i,
            o = !r;
        if (n == null) return !s;
        for (n = Object(n); i--;) {
            var l = t[i];
            if (o && l[2] ? l[1] !== n[l[0]] : !(l[0] in n)) return !1
        }
        for (; ++i < s;) {
            l = t[i];
            var a = l[0],
                c = n[a],
                f = l[1];
            if (o && l[2]) {
                if (c === void 0 && !(a in n)) return !1
            } else {
                var h = new lo;
                if (r) var m = r(c, f, a, n, e, h);
                if (!(m === void 0 ? wc(f, c, D1 | P1, r, h) : m)) return !1
            }
        }
        return !0
    }
    var Iv = B1;

    function O1(n) {
        return n === n && !pi(n)
    }
    var Sc = O1;

    function R1(n) {
        for (var e = to(n), t = e.length; t--;) {
            var r = e[t],
                i = n[r];
            e[t] = [r, i, Sc(i)]
        }
        return e
    }
    var Lv = R1;

    function F1(n, e) {
        return function(t) {
            return t == null ? !1 : t[n] === e && (e !== void 0 || n in Object(t))
        }
    }
    var Nc = F1;

    function G1(n) {
        var e = Lv(n);
        return e.length == 1 && e[0][2] ? Nc(e[0][0], e[0][1]) : function(t) {
            return t === n || Iv(t, n, e)
        }
    }
    var Dv = G1;

    function z1(n, e) {
        return n != null && e in Object(n)
    }
    var Pv = z1;

    function k1(n, e, t) {
        e = pc(e, n);
        for (var r = -1, i = e.length, s = !1; ++r < i;) {
            var o = bn(e[r]);
            if (!(s = n != null && t(n, o))) break;
            n = n[o]
        }
        return s || ++r != i ? s : (i = n == null ? 0 : n.length, !!i && $s(i) && uc(o, i) && (Dt(n) || dc(n)))
    }
    var Bv = k1;

    function U1(n, e) {
        return n != null && Bv(n, e, Pv)
    }
    var Ov = U1;
    var j1 = 1,
        V1 = 2;

    function H1(n, e) {
        return ro(n) && Sc(e) ? Nc(bn(n), e) : function(t) {
            var r = Zg(t, n);
            return r === void 0 && r === e ? Ov(t, n) : wc(e, r, j1 | V1)
        }
    }
    var Rv = H1;

    function W1(n) {
        return function(e) {
            return e == null ? void 0 : e[n]
        }
    }
    var Fv = W1;

    function J1(n) {
        return function(e) {
            return oo(e, n)
        }
    }
    var Gv = J1;

    function Q1(n) {
        return ro(n) ? Fv(bn(n)) : Gv(n)
    }
    var zv = Q1;

    function Y1(n) {
        return typeof n == "function" ? n : n == null ? oc : typeof n == "object" ? Dt(n) ? Rv(n[0], n[1]) : Dv(n) : zv(n)
    }
    var kv = Y1;

    function K1(n) {
        return function(e, t, r) {
            for (var i = -1, s = Object(e), o = r(e), l = o.length; l--;) {
                var a = o[n ? l : ++i];
                if (t(s[a], a, s) === !1) break
            }
            return e
        }
    }
    var Uv = K1;
    var X1 = Uv(),
        jv = X1;

    function q1(n, e) {
        return n && jv(n, e, to)
    }
    var Vv = q1;

    function Z1(n, e) {
        return function(t, r) {
            if (t == null) return t;
            if (!eo(t)) return n(t, r);
            for (var i = t.length, s = e ? i : -1, o = Object(t);
                (e ? s-- : ++s < i) && r(o[s], s, o) !== !1;);
            return t
        }
    }
    var Hv = Z1;
    var $1 = Hv(Vv),
        Wv = $1;
    var eC = function() {
            return Gt.Date.now()
        },
        Cc = eC;
    var tC = "Expected a function",
        rC = Math.max,
        iC = Math.min;

    function nC(n, e, t) {
        var r, i, s, o, l, a, c = 0,
            f = !1,
            h = !1,
            m = !0;
        if (typeof n != "function") throw new TypeError(tC);
        e = Tf(e) || 0, pi(t) && (f = !!t.leading, h = "maxWait" in t, s = h ? rC(Tf(t.maxWait) || 0, e) : s, m = "trailing" in t ? !!t.trailing : m);

        function v(L) {
            var I = r,
                z = i;
            return r = i = void 0, c = L, o = n.apply(z, I), o
        }

        function g(L) {
            return c = L, l = setTimeout(w, e), f ? v(L) : o
        }

        function y(L) {
            var I = L - a,
                z = L - c,
                O = e - I;
            return h ? iC(O, s - z) : O
        }

        function A(L) {
            var I = L - a,
                z = L - c;
            return a === void 0 || I >= e || I < 0 || h && z >= s
        }

        function w() {
            var L = Cc();
            if (A(L)) return C(L);
            l = setTimeout(w, y(L))
        }

        function C(L) {
            return l = void 0, m && r ? v(L) : (r = i = void 0, o)
        }

        function S() {
            l !== void 0 && clearTimeout(l), c = 0, r = a = i = l = void 0
        }

        function E() {
            return l === void 0 ? o : C(Cc())
        }

        function M() {
            var L = Cc(),
                I = A(L);
            if (r = arguments, i = this, a = L, I) {
                if (l === void 0) return g(a);
                if (h) return clearTimeout(l), l = setTimeout(w, e), v(a)
            }
            return l === void 0 && (l = setTimeout(w, e)), o
        }
        return M.cancel = S, M.flush = E, M
    }
    var Rf = nC;

    function sC(n, e) {
        var t = -1,
            r = eo(n) ? Array(n.length) : [];
        return Wv(n, function(i, s, o) {
            r[++t] = e(i, s, o)
        }), r
    }
    var Jv = sC;

    function oC(n, e) {
        var t = n.length;
        for (n.sort(e); t--;) n[t] = n[t].value;
        return n
    }
    var Qv = oC;

    function aC(n, e) {
        if (n !== e) {
            var t = n !== void 0,
                r = n === null,
                i = n === n,
                s = mi(n),
                o = e !== void 0,
                l = e === null,
                a = e === e,
                c = mi(e);
            if (!l && !c && !s && n > e || s && o && a && !l && !c || r && o && a || !t && a || !i) return 1;
            if (!r && !s && !c && n < e || c && t && i && !r && !s || l && t && i || !o && i || !a) return -1
        }
        return 0
    }
    var Yv = aC;

    function lC(n, e, t) {
        for (var r = -1, i = n.criteria, s = e.criteria, o = i.length, l = t.length; ++r < o;) {
            var a = Yv(i[r], s[r]);
            if (a) {
                if (r >= l) return a;
                var c = t[r];
                return a * (c == "desc" ? -1 : 1)
            }
        }
        return n.index - e.index
    }
    var Kv = lC;

    function cC(n, e, t) {
        e.length ? e = Zs(e, function(s) {
            return Dt(s) ? function(o) {
                return oo(o, s.length === 1 ? s[0] : s)
            } : s
        }) : e = [oc];
        var r = -1;
        e = Zs(e, hc(kv));
        var i = Jv(n, function(s, o, l) {
            var a = Zs(e, function(c) {
                return c(s)
            });
            return {
                criteria: a,
                index: ++r,
                value: s
            }
        });
        return Qv(i, function(s, o) {
            return Kv(s, o, t)
        })
    }
    var Xv = cC;

    function uC(n, e, t, r) {
        return n == null ? [] : (Dt(e) || (e = e == null ? [] : [e]), t = r ? void 0 : t, Dt(t) || (t = t == null ? [] : [t]), Xv(n, e, t))
    }
    var Ff = uC;

    function uo(n) {
        let e;
        return n instanceof Array ? (e = {}, n.forEach(t => {
            e[t.uuid] = t
        })) : e = n, e
    }

    function fC(n, e) {
        return n[e] === void 0 && console.warn("ObjectLoader > getGeometry: undefined geometry", e), n[e]
    }

    function dC(n, e) {
        if (e !== void 0) {
            if (e instanceof Array) {
                let t = [];
                for (let r = 0, i = e.length; r < i; r++) {
                    let s = e[r];
                    n[s] === void 0 && console.warn("ObjectLoader > getMaterial: undefined material", s), t.push(n[s])
                }
                return t
            }
            return n[e] === void 0 && console.warn("ObjectLoader > getMaterial: undefined material", e), n[e]
        }
    }
    var Gf = class extends md(co.ObjectLoader) {
        constructor() {
            super(...arguments);
            this.path = "";
            this.resourcePath = ""
        }
        async loadFromFile(e) {
            let t = await Sm(e, this.manager, hn.TEXT),
                {
                    object: r,
                    materials: i
                } = this.parse(JSON.parse(t));
            return r.name = e.name.split(".").shift() ?? e.name, this.manager.itemEnd(e.name), {
                scene: r,
                materials: i
            }
        }
        load(e, t, r, i) {
            let s = this.path === "" ? co.LoaderUtils.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || s;
            let o = new co.FileLoader(this.manager);
            o.setPath(this.path), o.load(e, l => {
                let a = null;
                try {
                    a = JSON.parse(l)
                } catch (f) {
                    i !== void 0 && i(f), console.warn(`ObjectLoader > load: can't parse ${e}.`), console.error(f);
                    return
                }
                let c = a.metadata;
                if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry") {
                    console.error("ObjectLoader: Can't load " + e);
                    return
                }
                this.parse(a, t)
            }, r, i)
        }
        parse(e, t) {
            if (wf(e) === !1) return console.error("File can not be parser"), {
                object: new Ks,
                materials: {}
            };
            let r = {},
                i = this.parseGeometries(e.geometries),
                s = this.loader.parseImages(e.images, () => {
                    t !== void 0 && t(f)
                }),
                o = this.parseTextures(e.textures, s),
                l = new rc;
            l.init(uo(e.nodes ?? []), uo(o));
            let a = uo(this.loader.parseMaterials(e.materials, o)),
                c = this.customParseMaterials(a, e.materials, l),
                f = this.parseObject(e.object, i, c, r),
                h = this.parseInteractionStates(e.interactionStates, l);
            return this.parseInteractions(e.object, r, h), (e.images === void 0 || e.images.length === 0) && t !== void 0 && t(f), {
                object: f,
                materials: c
            }
        }
        parseGeometries(e) {
            let t = {};
            if (e !== void 0)
                for (let r = 0, i = e.length; r < i; r++) {
                    let s = e[r],
                        o;
                    try {
                        switch (s.userData?.type) {
                            case void 0:
                                o = this.loader.parseGeometries([s])[s.uuid];
                                break;
                            case "NonParametricGeometry":
                                s.vertexData ? o = new Sf().parse(s) : o = this.loader.parseGeometries([s])[s.uuid], o.userData = {};
                                let l = Object.assign({}, s.userData, {
                                    geometry: o
                                });
                                o = Fn.create(l);
                                break;
                            case "SubdivGeometry":
                                o = this.loader.parseGeometries([s])[s.uuid], o = Si.create({
                                    parameters: s.userData.parameters,
                                    geometry: o
                                });
                                break;
                            default:
                                o = qo(s.userData)
                        }
                        o.uuid = s.uuid, s.name !== void 0 && (o.name = s.name), t[s.uuid] = o
                    } catch (l) {
                        console.warn("ObjectLoader > parseGeometries: error parsing geometry of type .", s.userData?.type), console.error(l)
                    }
                }
            return t
        }
        async parseAsync(e) {
            if (wf(e) === !1) return console.error("File can not be parser"), new Ks;
            let t = new rc,
                r = {},
                i = await this.parseGeometriesAsync(e.geometries),
                s = this.loader.parseImages(e.images, () => {}),
                o = this.parseTextures(e.textures, s);
            t.init(uo(e.nodes ?? []), uo(o));
            let l = uo(this.loader.parseMaterials(e.materials, o)),
                a = this.customParseMaterials(l, e.materials, t),
                c = this.parseObject(e.object, i, a, r),
                f = this.parseInteractionStates(e.interactionStates, t);
            return this.parseInteractions(e.object, r, f), c
        }
        async parseGeometriesAsync(e) {
            let t = {};
            if (e !== void 0)
                for (let r = 0, i = e.length; r < i; r++) {
                    let s = e[r],
                        o;
                    try {
                        switch (s.userData?.type) {
                            case void 0:
                                o = this.loader.parseGeometries([s])[s.uuid];
                                break;
                            case "NonParametricGeometry":
                                if (s.gltf) {
                                    if (!this.gltfLoader) {
                                        this.gltfLoader = new qu;
                                        let f = new Cf;
                                        f.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/"), this.gltfLoader.setDRACOLoader(f)
                                    }
                                    let a = await new Promise(f => {
                                            this.gltfLoader.parse(JSON.stringify(s.gltf), "", f)
                                        }),
                                        c = [];
                                    a.scene.traverse(f => {
                                        let h = f;
                                        h.isMesh && c.push(h.geometry)
                                    }), c.length === 1 ? o = c[0] : (c = Ff(c, f => s.gltf.meshes.findIndex(m => {
                                        let v = m.primitives[0].attributes.POSITION,
                                            g = s.gltf.accessors[v];
                                        return f.index !== null ? g.count === f.index.count : g.count === f.attributes.position.count
                                    })), o = Rs.mergeBufferGeometries(c, !0))
                                } else o = this.loader.parseGeometries([s])[s.uuid];
                                o.userData = {};
                                let l = Object.assign({}, s.userData, {
                                    geometry: o
                                });
                                o = Fn.create(l);
                                break;
                            default:
                                o = qo(s.userData)
                        }
                        o.uuid = s.uuid, s.name !== void 0 && (o.name = s.name), t[s.uuid] = o
                    } catch (l) {
                        console.warn("ObjectLoader > parseGeometries: error parsing geometry of type .", s.userData?.type), console.error(l)
                    }
                }
            return t
        }
        parseTextures(e, t) {
            let r = this.loader.parseTextures(e, t);
            return Object.keys(r).forEach(i => {
                let s = new zi().copy(r[i]);
                s.uuid = i, r[i] = s
            }), r
        }
        customParseMaterials(e, t, r) {
            let i = {};
            if (t !== void 0)
                for (let s = 0, o = t.length; s < o; s++) {
                    let l = t[s],
                        a = e[l.uuid],
                        c = a.userData;
                    if (c.type !== void 0) {
                        let f = Ed[c.type];
                        i[l.uuid] = f.fromJSON(a, l, r)
                    }
                }
            return i
        }
        parseObject(e, t, r, i) {
            let s;
            if (e.geometry !== void 0) {
                let o = fC(t, e.geometry),
                    l = dC(r, e.material);
                if (o) {
                    switch (e.objectType) {
                        case "Mesh2D":
                            s = new la(o, l).fromJSON(e);
                            break;
                        case "Mesh3D":
                            s = new ca(o, l).fromJSON(e);
                            break;
                        case "NonParametric":
                            s = new Xu(o, l).fromJSON(e);
                            break;
                        case "TextFrame":
                            s = new Qn(o, l), s.fromJSONasync(e).then(() => {}).catch(() => {});
                            break;
                        case "VectorObject":
                            s = new aa(o, l).fromJSON(e);
                            break;
                        case "SubdivObject":
                            s = new La(o, l).fromJSON(e), s.subdivPointer = o.subdivPointer;
                            break;
                        default:
                            console.warn("ObjectLoader > parseObject: unsupported object type", e.objectType);
                            return
                    }
                    l || (s.name += " (Recovered)")
                } else s = new dn().fromJSON(e), s.name += " (Recovered)", console.warn("An empty object is created instead")
            } else switch (e.objectType) {
                case "Scene":
                    s = new Ks().fromJSON(e);
                    break;
                case "CombinedCamera":
                    s = new Un().fromJSON(e);
                    break;
                case "LightDirectional":
                    s = new Qu().fromJSON(e);
                    break;
                case "LightPoint":
                    s = new Yu().fromJSON(e);
                    break;
                case "LightSpot":
                    s = new Ku().fromJSON(e);
                    break;
                case "EmptyObject":
                    s = new dn().fromJSON(e);
                    break;
                default:
                    if (e.type === "HemisphereLight" || e.type === "DirectionalLight") s = this.loader.parseObject(e, t, r);
                    else {
                        console.warn("ObjectLoader > parseObject: unsupported object type", e.objectType);
                        return
                    }
            }
            if (Sr(s) && (i[e.uuid] = s), e.children !== void 0)
                for (let o of e.children) {
                    let l = this.parseObject(o, t, r, i);
                    l !== void 0 && s.add(l)
                }
            return s instanceof Ks && s.initFromObjectLoader(e), s
        }
        parseInteractionStates(e, t) {
            let r = {};
            if (e !== void 0)
                for (let i = 0, s = e.length; i < s; i++) {
                    let o = new cn().fromJSON(e[i], t);
                    r[o.uuid] = o
                }
            return r
        }
        parseInteractions(e, t, r) {
            let i = t[e.uuid];
            if (e.interaction !== void 0 && i !== void 0 && (i.interaction = new kn(i).fromJSON(e.interaction, t, r)), e.children !== void 0)
                for (let s of e.children) this.parseInteractions(s, t, r)
        }
    };
    var fo = W(J());
    var zf = class {
        constructor(e, t, r) {
            this.isEnable = !1;
            this._enableEvent = {};
            this._map = {};
            this._prevAncestors = [];
            this._raycaster = new Vc;
            this._intersection = new fo.Vector3;
            this._plane = new fo.Plane;
            this._normal = new fo.Vector3;
            this._position = new fo.Vector3;
            this._onMouseDown = e => {
                this._raycaster.setFromCamera(this._getPointer(e.clientX, e.clientY), this._camera), this._handleMouseDownEvent()
            };
            this._onMouseUp = e => {
                this._raycaster.setFromCamera(this._getPointer(e.clientX, e.clientY), this._camera), this._handleMouseUpEvent()
            };
            this._onMouseMove = e => {
                this._raycaster.setFromCamera(this._getPointer(e.clientX, e.clientY), this._camera), this._camera.getWorldDirection(this._normal), this._normal.negate(), this._handleMouseHoverEvent(), this._handleLookAtEvent(), this._handleFollowEvent()
            };
            this._onTouchStart = e => {
                e.touches.length === 1 && (e.preventDefault(), this._raycaster.setFromCamera(this._getPointer(e.touches[0].clientX, e.touches[0].clientY), this._camera), this._camera.getWorldDirection(this._normal), this._normal.negate(), this._handleMouseDownEvent(), this._handleMouseHoverEvent(), this._handleLookAtEvent(), this._handleFollowEvent())
            };
            this._onTouchEnd = () => {
                this._handleMouseUpEvent(), this._handleMouseHoverEvent(!0)
            };
            this._onTouchMove = e => {
                e.touches.length === 1 && (e.preventDefault(), e.stopPropagation(), this._raycaster.setFromCamera(this._getPointer(e.touches[0].clientX, e.touches[0].clientY), this._camera), this._camera.getWorldDirection(this._normal), this._normal.negate(), this._handleMouseHoverEvent(), this._handleLookAtEvent(), this._handleFollowEvent())
            };
            this._onKeyDown = e => {
                this._handleKeyDownEvent(e.key)
            };
            this._onKeyUp = e => {
                this._handleKeyUpEvent(e.key)
            };
            this._domElement = e, this._scene = t, this._camera = r
        }
        activate() {
            this.isEnable = !0, this._scene.traverseEntity(e => {
                if (e.interaction !== void 0) {
                    e.interaction.start();
                    for (let t of e.interaction.events) {
                        let r = t.type;
                        this._enableEvent[r] = !0, (r === Re.KEY_DOWN || r === Re.KEY_UP || r === Re.START || r === Re.LOOK_AT || r === Re.FOLLOW) && (this._map[r] === void 0 && (this._map[r] = []), this._map[r].push(e))
                    }
                }
            }), this._enableEvent[Re.START] !== void 0 && this._handleStartEvent(), this._enableEvent[Re.MOUSE_DOWN] !== void 0 && (this._domElement.addEventListener("pointerdown", this._onMouseDown, !1), this._domElement.addEventListener("touchstart", this._onTouchStart, !1)), this._enableEvent[Re.MOUSE_UP] !== void 0 && (this._domElement.addEventListener("pointerup", this._onMouseUp, !1), this._domElement.addEventListener("touchend", this._onTouchEnd, !1)), (this._enableEvent[Re.MOUSE_HOVER] !== void 0 || this._enableEvent[Re.LOOK_AT] !== void 0 || this._enableEvent[Re.FOLLOW] !== void 0) && (this._domElement.addEventListener("pointermove", this._onMouseMove, !1), this._domElement.addEventListener("touchstart", this._onTouchStart, !1), this._domElement.addEventListener("touchend", this._onTouchEnd, !1), this._domElement.addEventListener("touchmove", this._onTouchMove, !1)), this._enableEvent[Re.KEY_DOWN] !== void 0 && document.addEventListener("keydown", this._onKeyDown, !1), this._enableEvent[Re.KEY_UP] !== void 0 && document.addEventListener("keyup", this._onKeyUp, !1)
        }
        deactivate() {
            this._scene.traverseEntity(e => {
                e.interaction !== void 0 && e.interaction.end(), e.interaction.cache = void 0
            }), this._domElement.removeEventListener("pointerdown", this._onMouseDown), this._domElement.removeEventListener("pointerup", this._onMouseUp), this._domElement.removeEventListener("pointermove", this._onMouseMove), this._domElement.removeEventListener("touchstart", this._onTouchStart), this._domElement.removeEventListener("touchend", this._onTouchEnd), this._domElement.removeEventListener("touchmove", this._onTouchMove), document.removeEventListener("keydown", this._onKeyDown), document.removeEventListener("keyup", this._onKeyUp), this._enableEvent = {}, this._map = {}, this.isEnable = !1
        }
        reset() {
            this._scene.traverseEntity(e => {
                e.interaction.start()
            }), this._handleStartEvent()
        }
        _getPointer(e, t) {
            let r = this._domElement.getBoundingClientRect();
            return {
                x: (e - r.left) / r.width * 2 - 1,
                y: -((t - r.top) / r.height) * 2 + 1
            }
        }
        _handleStartEvent() {
            this._map[Re.START]?.forEach(e => {
                e.interactionCache.start?.dispatch()
            })
        }
        _handleMouseDownEvent() {
            let e = this._raycastMesh(this._raycaster);
            for (let t = 0, r = e.length; t < r; ++t) {
                let i = e[t].object;
                if (i.interactionCache.mouseDown?.dispatch(), i.traverseAncestors(s => {
                        s instanceof dn && s.interactionCache.mouseDown?.dispatch()
                    }), !i.interactionCache.follow) break
            }
        }
        _handleMouseUpEvent() {
            let e = this._raycastMesh(this._raycaster);
            for (let t = 0, r = e.length; t < r; ++t) {
                let i = e[t].object;
                if (i.interactionCache.mouseUp?.dispatch(), i.traverseAncestors(s => {
                        s instanceof dn && s.interactionCache.mouseUp?.dispatch()
                    }), !i.interactionCache.follow) break
            }
        }
        _handleMouseHoverEvent(e = !1) {
            if (this._enableEvent[Re.MOUSE_HOVER] !== void 0) {
                let t;
                if (!e) {
                    let i = this._raycastMesh(this._raycaster).find(s => !s.object.interactionCache.follow);
                    t = i ? i.object : void 0
                }
                if (this._prevObject !== t) {
                    this._prevObject !== void 0 && this._prevObject.interactionCache.mouseHover?.dispatchReverse(), t !== void 0 && t.interactionCache.mouseHover?.dispatch();
                    let r = [];
                    t?.traverseAncestors(o => {
                        o instanceof dn && o.interactionCache.mouseHover && r.push(o)
                    }), this._prevAncestors.filter(o => r.includes(o) ? !1 : (o.interactionCache.mouseHover?.dispatchReverse(), !0));
                    let i = r.filter(o => this._prevAncestors.includes(o) ? !1 : (o.interactionCache.mouseHover?.dispatch(), !0)),
                        s = this._prevAncestors.filter(o => r.includes(o));
                    this._prevAncestors = [...s, ...i]
                }
                this._prevObject = t
            }
        }
        _handleLookAtEvent() {
            this._map[Re.LOOK_AT]?.forEach(e => {
                let t = e.interactionCache.lookAt?.distance;
                t !== void 0 && (this._plane.set(this._normal, -t), this._raycaster.ray.intersectPlane(this._plane, this._intersection), e.interaction.lookAt(this._intersection))
            })
        }
        _handleFollowEvent() {
            this._map[Re.FOLLOW]?.forEach(e => {
                this._plane.setFromNormalAndCoplanarPoint(this._normal, e.getWorldPosition(this._position)), this._raycaster.ray.intersectPlane(this._plane, this._intersection), e.interaction.follow(this._intersection)
            })
        }
        _handleKeyDownEvent(e) {
            this._map[Re.KEY_DOWN]?.forEach(t => {
                t.interactionCache.keyDown?.find(i => i.key === e)?.dispatch()
            })
        }
        _handleKeyUpEvent(e) {
            this._map[Re.KEY_UP]?.forEach(t => {
                t.interactionCache.keyUp?.find(i => i.key === e)?.dispatch()
            })
        }
        _raycastMesh(e) {
            let t = [],
                r = i => {
                    for (let s of i.children) Sr(s) && !s.raycastLock && s.visible && (om(s) && e.intersectObject(s, !1, t), r(s))
                };
            return r(this._scene), t
        }
    };
    var kf = W(J()),
        Uf = class {
            constructor(e, t, r, i, s) {
                this._aspect = 1;
                this._renderer = e, this._camera = t, this._frameSize = new kf.Vector2().copy(r), this._editorSize = new kf.Vector2().copy(i), this._fov = s ?? t.fov
            }
            set frameSize(e) {
                this._frameSize.copy(e)
            }
            updateRenderer() {
                !this._renderer || this._renderer.setSize(this._frameSize.x, this._frameSize.y)
            }
            updateViewport() {
                if (!this._renderer || !this._camera || this._camera.cameraType !== "PerspectiveCamera") return;
                let e = this._frameSize.x,
                    t = this._frameSize.y,
                    r = this._editorSize.x,
                    i = this._editorSize.y,
                    s = 0,
                    o = 0,
                    l = e,
                    a = t;
                e < r && (s = (r - e) * .5, s = -s, l = r), t < i && (o = (i - t) * .5, o = -o, a = i), this._aspect = l / a, this._renderer.setViewport(s, o, l, a)
            }
            updateCamera() {
                if (!!this._camera)
                    if (this._camera.cameraType === "PerspectiveCamera") {
                        let e = this._frameSize.y,
                            t = this._editorSize.y,
                            r = this._fov;
                        if (e > t) {
                            let i = hC(e, 1080, 2160, 1, 15) / 100;
                            r *= e / t, r *= 1 - i
                        }
                        this._camera.aspect = this._aspect, this._camera.fov = r, this._camera.updateProjectionMatrix()
                    } else this._camera.setViewplaneSize(this._frameSize.x, this._frameSize.y)
            }
            revert() {
                let e = window.innerWidth,
                    t = window.innerHeight;
                this._renderer && (this._renderer.setViewport(0, 0, e, t), this._renderer.setSize(e, t)), this._camera && (this._camera.aspect = e / t, this._camera.fov = this._fov, this._camera.setViewplaneSize(e, t), this._camera.updateProjectionMatrix())
            }
        };

    function hC(n, e, t, r, i) {
        return (n - e) / (t - e) * (i - r) + r
    }
    var $i = W(J());
    var rs;
    (function(t) {
        t[t.FULLSCREEN = 1] = "FULLSCREEN", t[t.CUSTOM = 2] = "CUSTOM"
    })(rs || (rs = {}));
    var qv = class {
        constructor() {
            this._viewportMode = 1;
            this._viewportWidth = window.innerWidth;
            this._viewportHeight = window.innerHeight;
            this._running = !1;
            window.addEventListener("resize", Rf(this.resize.bind(this), 200))
        }
        start(e) {
            fetch(e).then(t => t.json()).then(t => (this._editorData = t.editor, new Gf().parseAsync(t))).then(t => {
                this._scene = t, this._camera = this._scene.activeCamera, this.init(), this._running = !0, this.run(), this.resize()
            }).catch(t => {
                console.error(t)
            })
        }
        run() {
            requestAnimationFrame(this.run.bind(this)), this.render()
        }
        render() {
            if (!!this._running) {
                if (!this._renderer) {
                    console.error("Application::render >>> tried to renderer without a renderer");
                    return
                }
                this._controls && (this._controls.enableDamping || this._controls.autoRotate) && this._controls.update(), this._playmode && !this._playmode.isEnable && this._playmode.activate(), this._scene && this._camera && (this._scene.postprocessing?.enabled ? (this._renderer.autoClear = !1, this._scene.postprocessing.render()) : (this._renderer.autoClear = !0, this._renderer.render(this._scene, this._camera)))
            }
        }
        resize() {
            !this._running || !this._renderer || (this._viewportMode === 1 && (this._viewportWidth = window.innerWidth, this._viewportHeight = window.innerHeight, this._frameView && (this._frameView.frameSize = new $i.Vector2(this._viewportWidth, this._viewportHeight))), this._frameView?.updateRenderer(), this._scene?.postprocessing && this._scene.postprocessing.resize(this._viewportWidth, this._viewportHeight), this._viewportMode !== 1 && this._frameView?.updateViewport(), this._camera && (this._frameView?.updateCamera(), this._camera.cameraType === "PerspectiveCamera" && this._viewportMode === 1 && (this._camera.aspect = this._viewportWidth / this._viewportHeight), this._camera.updateProjectionMatrix()))
        }
        init() {
            let e = document.getElementById("canvas3d");
            if (!this._scene || !this._camera) return;
            this._scene.postprocessing?.enabled ? (this._renderer = new $i.WebGLRenderer({
                canvas: e,
                antialias: !1,
                stencil: !1,
                depth: !1,
                powerPreference: "high-performance"
            }), this._scene.postprocessing.init({
                renderer: this._renderer,
                camera: this._camera,
                scene: this._scene
            })) : this._renderer = new $i.WebGLRenderer({
                canvas: e,
                antialias: !0,
                alpha: !0,
                stencil: !0,
                depth: !0,
                powerPreference: "high-performance"
            }), this._viewportMode = this._scene.canvas.mode ?? 1, this._viewportWidth = this._scene.canvas.size.width ?? window.innerWidth, this._viewportHeight = this._scene.canvas.size.height ?? window.innerHeight, this._renderer.setPixelRatio(window.devicePixelRatio), this._renderer.setSize(this._viewportWidth, this._viewportHeight), this._scene.postprocessing && this._scene.postprocessing.resize(this._viewportWidth, this._viewportHeight), this._renderer.shadowMap.enabled = !0, this._renderer.shadowMap.type = $i.PCFSoftShadowMap, this._renderer.setClearColor(this._scene.color, this._scene.alpha), this._frameView = new Uf(this._renderer, this._camera, new $i.Vector2(this._viewportWidth, this._viewportHeight), new $i.Vector2(this._scene.canvas.editorSize.width, this._scene.canvas.editorSize.height)), !0 && (this._controls = new jc(this._camera, this._renderer.domElement), this._editorData && (this._controls.fromJSON(this._editorData.orbitControls), this._controls.useKeyEvents = !1)), this._playmode = new zf(this._renderer.domElement, this._scene, this._camera)
        }
    };
    Vr.FONTS_PATH = "_assets/_fonts/";
    return mC;
})();